
// Generated from NeoBasicParser.g4 by ANTLR 4.13.2


#include "NeoBasicParserListener.h"

#include "NeoBasicParser.h"


using namespace antlrcpp;
using namespace parser;

using namespace antlr4;

namespace {

struct NeoBasicParserStaticData final {
  NeoBasicParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  NeoBasicParserStaticData(const NeoBasicParserStaticData&) = delete;
  NeoBasicParserStaticData(NeoBasicParserStaticData&&) = delete;
  NeoBasicParserStaticData& operator=(const NeoBasicParserStaticData&) = delete;
  NeoBasicParserStaticData& operator=(NeoBasicParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag neobasicparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
std::unique_ptr<NeoBasicParserStaticData> neobasicparserParserStaticData = nullptr;

void neobasicparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (neobasicparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(neobasicparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<NeoBasicParserStaticData>(
    std::vector<std::string>{
      "neoProgram", "oneLinerProgram", "scriptFileProgram", "instructionSentence", 
      "directive", "interpreterDirective", "pragmaDirective", "canaryTestDirective", 
      "declaration", "constDeclaration", "constClause", "constants", "constant", 
      "valDeclaration", "valClause", "varDeclaration", "varClause", "variables", 
      "variable", "statement", "labeledStatement", "debugingStatement", 
      "loggingStatement", "sExpressionStatement", "simpleStatement", "emptyStatement", 
      "expressionStatement", "assignmentStatement", "compoundStatement", 
      "conditionalStatement", "ifStatement", "ifThenClause", "unlessStatement", 
      "unlessClause", "prefixUnaryOperator", "posfixUnaryOperator", "unaryArithmeticOperator", 
      "unaryBitwiseOperator", "unaryLogicalOperator", "unarySpreadOperator", 
      "unarySortOperator", "unaryCloneOperator", "unaryMetaOperator", "binaryExponentialOperator", 
      "binaryMultiplicativeOperator", "binaryAdditiveOperator", "bitShiftOperator", 
      "bitConjunctionOperator", "bitExclusiveDisjunctionOperator", "bitDisjunctionOperator", 
      "binaryComparisonOperator", "binaryRelationalOperator", "binaryConditionalOperator", 
      "binaryConjunctionOperator", "binaryExclusiveDisjunctionOperator", 
      "binaryDisjunctionOperator", "binaryCoalescingOperator", "assignmentOperator", 
      "singleAssignmentOperator", "compoundAssignmentOperator", "symbolIdentifier", 
      "qualifiedIdentifier", "identifiers", "symbolIdentifiers", "qualifiedIdentifiers", 
      "type", "nativeType", "posfixTypeWrapper", "escalarType", "booleanType", 
      "numericType", "numericDigit", "numericNatural", "numericInteger", 
      "numericReal", "numericDecimal", "numericRatio", "numericComplex", 
      "numericQuaternion", "temporalType", "characterType", "sequenceType", 
      "compositeType", "metaType", "expressions", "juxtapositionExpression", 
      "primaryExpressions", "expression", "primaryExpression", "operand", 
      "factScope", "converter", "selector", "indexing", "slicing", "slicingRange", 
      "arguments", "assignmentExpression", "condicionalExpression", "guardsExpression", 
      "guardClause", "guardDefault", "literal", "predeclaredValue", "valueConstruct", 
      "escalarLiteral", "booleanLiteral", "numericLiteral", "temporalLiteral", 
      "characterLiteral", "sequenceLiteral", "compositeLiteral", "optionLiteral", 
      "resultLiteral", "maybeLiteral", "eitherLiteral", "streamLiteral"
    },
    std::vector<std::string>{
      "", "'('", "')'", "'['", "']'", "'{'", "'}'", "'<'", "'>'", "'.'", 
      "','", "';'", "':'", "'!'", "'\\u003F'", "'''", "'\"'", "'`'", "'@'", 
      "'#'", "'$'", "'&'", "'*'", "'/'", "'\\u00F7'", "'%'", "'\\'", "'~'", 
      "'^'", "'|'", "'_'", "'='", "'+'", "'-'", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "'f'", "'s'", "", "", "", "", "", "", "", "", 
      "", "", "'\\uEFBBBF'", "'\\uFEFF'", "'\\u0000FEFF'", "", "", "", "", 
      "", "", "'const'", "'val'", "'var'", "'if'", "'then'", "'unless'", 
      "'orelse'", "'this'", "'iota'", "'all'", "'any'", "'one'", "'two'", 
      "'nil'", "'typeof'", "'instanceof'", "'sizeof'", "'is'", "'in'", "'between'", 
      "'like'", "'not'", "'and'", "'or'", "'xor'", "'nand'", "'nor'", "'nxor'", 
      "'atom'", "'auto'", "'void'", "'Bool8'", "'Bool16'", "'Bool32'", "'Bool64'", 
      "'Bool128'", "'Bool'", "'Dig'", "'Bit'", "'Oct'", "'Hex'", "'Nibble'", 
      "'Byte'", "'Number'", "'Nat8'", "'Nat16'", "'Nat32'", "'Nat64'", "'Nat128'", 
      "'Nat'", "'Bignat'", "'Int8'", "'Int16'", "'Int32'", "'Int64'", "'Int128'", 
      "'Int'", "'Bigint'", "'Real16'", "'Real32'", "'Real64'", "'Real128'", 
      "'Real'", "'Bigreal'", "'Dec1'", "'Dec2'", "'Dec3'", "'Dec4'", "'Dec5'", 
      "'Dec6'", "'Dec7'", "'Dec8'", "'Decimal'", "'Money'", "'Bigdecimal'", 
      "'Ratio8'", "'Ratio16'", "'Ratio32'", "'Ratio64'", "'Ratio128'", "'Ratio'", 
      "'Complex16'", "'Complex32'", "'Complex64'", "'Complex128'", "'Complex'", 
      "'Quatern16'", "'Quatern32'", "'Quatern64'", "'Quatern128'", "'Quatern'", 
      "'Date'", "'Elapse'", "'Ascii'", "'Char8'", "'Char16'", "'Char32'", 
      "'Char'", "'Str'", "'String8'", "'String16'", "'String32'", "'String'", 
      "'Regex'", "'Binary'", "'Range'", "'True'", "'False'", "'Nonzero'", 
      "'Zero'", "'MinValue'", "'MaxValue'", "'NaN'", "'PositiveInfinity'", 
      "'NegativeInfinity'", "'LocalDate'", "'LocalDateTime'", "'OffsetDate'", 
      "'OffsetDateTime'", "'ZonedDate'", "'ZonedDateTime'", "'Tomorrow'", 
      "'Today'", "'Now'", "'Yesterday'", "'Eon'", "'Epoch'", "'Letter'", 
      "'Mark'", "'Digit'", "'Punctuation'", "'Symbol'", "'Separator'", "'NonPrintable'", 
      "'Null'", "'Blank'", "'Nonblank'", "'Okay'", "'Fail'", "'Some'", "'None'", 
      "'Yea'", "'Nay'", "'Data'", "'EoT'", "'scan'", "'echo'", "'till'", 
      "'since'", "'play'", "'cls'", "'cd'", "'pwd'", "'ls'", "'mkdir'", 
      "'rmdir'", "'touch'", "'rm'", "'cp'", "'mv'", "'rename'", "'chmod'", 
      "'chown'", "'chgrp'", "'raise'", "'panic'", "'trace'", "'debug'", 
      "'info'", "'warn'", "'error'", "'fatal'"
    },
    std::vector<std::string>{
      "", "LEFT_PARENTHESIS", "RIGHT_PARENTHESIS", "LEFT_BRACKET", "RIGHT_BRACKET", 
      "LEFT_CURLY", "RIGHT_CURLY", "LEFT_ANGLE", "RIGHT_ANGLE", "DOT", "COMMA", 
      "SEMICOLON", "COLON", "EXCLAMATION", "QUESTION", "APOSTROPHE", "QUOTE", 
      "BACKTICK", "AT", "HASH", "DOLLAR", "AMPERSAND", "ASTERISK", "SLASH", 
      "DIVISION", "PERCENT", "BACKSLASH", "TILDE", "CARET", "PIPE", "UNDERSCORE", 
      "EQUAL", "PLUS", "MINUS", "POSITIVE", "NEGATIVE", "INCREMENT", "DECREMENT", 
      "BIT_NOT", "BIT_NEGATION", "SQUARE_POWER", "SQUARE_ROOT", "FACTORIAL", 
      "ADDITION", "SUBTRACTION", "MULTIPLICATION", "REAL_DIVISION", "INTEGER_DIVISION", 
      "MODULO", "NTH_POWER", "NTH_ROOT", "PERCENTAGE_RATE", "PERCENTAGE_AMOUNT", 
      "PERCENTAGE_INCREASE", "PERCENTAGE_DECREASE", "PERCENTAGE_VARIATION", 
      "BIT_AND", "BIT_CLEAR", "BIT_XOR", "BIT_OR", "LEFT_SHIFT", "SIGNED_RIGHT_SHIFT", 
      "UNSIGNED_RIGHT_SHIFT", "IDENTITY", "NOT_IDENTITY", "MEMBERSHIP", 
      "NOT_MEMBERSHIP", "BETWEEN_RANGE", "NOT_BETWEEN_RANGE", "MATCHING", 
      "NOT_MATCHING", "DIVISIBLE_BY", "NOT_DIVISIBLE_BY", "ELVIS_TEST", 
      "THREE_WAY_TEST", "EQUALS", "NOT_EQUALS", "LESS", "LESS_OR_EQUALS", 
      "GREATER", "GREATER_OR_EQUALS", "LOGICAL_AND", "LOGICAL_XOR", "LOGICAL_OR", 
      "LOGICAL_NOT", "LOGICAL_NAND", "LOGICAL_NXOR", "LOGICAL_NOR", "ERROR_PROPAGATION", 
      "ERROR_COALESCING", "ERROR_PROPAGATION_NONE_COALESCING", "ERROR_TO_NONE_CONVERTION", 
      "EXCEPTION_COALESCING", "EXCEPTION_STATEMENT", "BASIC_ASSIGNMENT", 
      "DESTRUCTURING_ASSIGNMENT", "MACRO_ASSIGNMENT", "ADDITION_ASSIGNMENT", 
      "SUBTRACTION_ASSIGNMENT", "MULTIPLICATION_ASSIGNMENT", "REAL_DIVISION_ASSIGNMENT", 
      "INTEGER_DIVISION_ASSIGNMENT", "MODULO_ASSIGNMENT", "NTH_POWER_ASSIGNMENT", 
      "NTH_ROOT_ASSIGNMENT", "PERCENTAGE_RATE_ASSIGNMENT", "PERCENTAGE_AMOUNT_ASSIGNMENT", 
      "PERCENTAGE_INCREASE_ASSIGNMENT", "PERCENTAGE_DECREASE_ASSIGNMENT", 
      "PERCENTAGE_VARIATION_ASSIGNMENT", "BIT_AND_ASSIGNMENT", "BIT_OR_ASSIGNMENT", 
      "BIT_XOR_ASSIGNMENT", "BIT_CLEAR_ASSIGNMENT", "BIT_NOT_ASSIGNMENT", 
      "LEFT_SHIFT_ASSIGNMENT", "SIGNED_RIGHT_SHIFT_ASSIGNMENT", "UNSIGNED_RIGHT_SHIFT_ASSIGNMENT", 
      "NONE_COALESCING_ASSIGNMENT", "INTERVAL", "ELLIPSIS", "FRACTION", 
      "IMPLICIT_RETURN", "MONAD_BIND", "NUMBER_LIT", "TIME_LIT", "SEQUENCE_LIT", 
      "HEREDOC_LITERAL", "HEREDOC_CONTENT", "BINARY_LIT", "REGULAR_EXPRESSION_LIT", 
      "REGULAR_EXPRESSION_CONTENT", "STRING_LIT", "VERBATIM_STRING_LIT", 
      "TEMPLATE_STRING_LIT", "STRING_PLACEHOLDER", "CHAR_LIT", "ASCII_LIT", 
      "ATOM_DOT_LIT", "DOT_FRACTION", "RANGE_LIT", "KEYWORD", "IDENTIFIER", 
      "ATOM_IDENTIFIER", "MUSIC_NOTE", "MUSIC_ALPHABET", "OCTAVE_DIGIT", 
      "PITCH_FLAT", "PITCH_SHARP", "SHEBANG", "SHEBANG_INTERPRETER", "WOODSTOCK", 
      "RUBBERDUCK", "TRACERBIRD", "LOGGING_LEVEL", "HASHTAG", "EOS", "EOL", 
      "BOM", "UTF8_BOM", "UTF16_BOM", "UTF32_BOM", "WSP", "EXPLICIT_LINE_JOINING", 
      "LINE_COMMENT", "BLOCK_COMMENT", "DOCUMENTATION_COMMENT", "UnexpectedCharacter", 
      "CONST", "VAL", "VAR", "IF", "THEN", "UNLESS", "ORELSE", "THIS", "IOTA", 
      "ALL", "ANY", "ONE", "TWO", "NIL", "TYPEOF", "INSTANCEOF", "SIZEOF", 
      "IS", "IN", "BETWEEN", "LIKE", "NOT", "AND", "OR", "XOR", "NAND", 
      "NOR", "NXOR", "ATOM", "AUTO", "VOID", "BOOL8", "BOOL16", "BOOL32", 
      "BOOL64", "BOOL128", "BOOL", "DIG", "BIT", "OCT", "HEX", "NIBBLE", 
      "BYTE", "NUMBER", "NAT8", "NAT16", "NAT32", "NAT64", "NAT128", "NAT", 
      "BIGNAT", "INT8", "INT16", "INT32", "INT64", "INT128", "INT", "BIGINT", 
      "REAL16", "REAL32", "REAL64", "REAL128", "REAL", "BIGREAL", "DEC1", 
      "DEC2", "DEC3", "DEC4", "DEC5", "DEC6", "DEC7", "DEC8", "DECIMAL", 
      "MONEY", "BIGDECIMAL", "RATIO8", "RATIO16", "RATIO32", "RATIO64", 
      "RATIO128", "RATIO", "COMPLEX16", "COMPLEX32", "COMPLEX64", "COMPLEX128", 
      "COMPLEX", "QUATERN16", "QUATERN32", "QUATERN64", "QUATERN128", "QUATERN", 
      "DATE", "ELAPSE", "ASCII", "CHAR8", "CHAR16", "CHAR32", "CHAR", "STR", 
      "STRING8", "STRING16", "STRING32", "STRING", "REGEX", "BINARY", "RANGE", 
      "TRUE", "FALSE", "NONZERO", "ZERO", "MINVALUE", "MAXVALUE", "NAN", 
      "POSITIVEINFINITY", "NEGATIVEINFINITY", "LOCALDATE", "LOCALDATETIME", 
      "OFFSETDATE", "OFFSETDATETIME", "ZONEDDATE", "ZONEDDATETIME", "TOMORROW", 
      "TODAY", "NOW", "YESTERDAY", "EON", "EPOCH", "LETTER", "MARK", "DIGIT", 
      "PUNCTUATION", "SYMBOL", "SEPARATOR", "NONPRINTABLE", "NULL", "BLANK", 
      "NONBLANK", "OKAY", "FAIL", "SOME", "NONE", "YEA", "NAY", "DATA", 
      "EOT", "SCAN", "ECHO", "TILL", "SINCE", "PLAY", "CLS", "CD", "PWD", 
      "LS", "MKDIR", "RMDIR", "TOUCH", "RM", "CP", "MV", "RENAME", "CHMOD", 
      "CHOWN", "CHGRP", "RAISE", "PANIC", "TRACE", "DEBUG", "INFO", "WARN", 
      "ERROR", "FATAL"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,339,886,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
  	7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,
  	14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,
  	21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,
  	28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,
  	35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,
  	42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,
  	49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,
  	56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,
  	63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,
  	70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,
  	77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,
  	84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
  	91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,7,
  	98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,7,
  	104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,1,0,1,0,3,0,237,8,0,1,1,1,1,1,2,3,2,242,8,2,1,2,1,2,1,2,5,2,247,
  	8,2,10,2,12,2,250,9,2,1,3,1,3,1,3,3,3,255,8,3,1,4,1,4,1,4,3,4,260,8,4,
  	1,5,1,5,1,6,1,6,1,6,3,6,267,8,6,1,7,1,7,1,7,1,7,3,7,273,8,7,1,8,1,8,1,
  	8,3,8,278,8,8,1,9,1,9,1,10,1,10,1,10,1,11,1,11,1,11,5,11,288,8,11,10,
  	11,12,11,291,9,11,1,12,1,12,1,12,1,12,1,13,1,13,1,14,1,14,1,14,1,15,1,
  	15,1,16,1,16,1,16,1,17,1,17,1,17,5,17,310,8,17,10,17,12,17,313,9,17,1,
  	18,1,18,3,18,317,8,18,1,18,1,18,1,18,3,18,322,8,18,1,19,1,19,1,19,1,19,
  	1,19,1,19,3,19,330,8,19,1,20,1,20,3,20,334,8,20,1,21,1,21,3,21,338,8,
  	21,1,22,1,22,3,22,342,8,22,1,23,1,23,1,23,1,23,1,24,1,24,1,24,3,24,351,
  	8,24,1,25,1,25,1,26,1,26,1,27,1,27,1,27,1,27,1,28,1,28,1,29,1,29,3,29,
  	365,8,29,1,30,1,30,1,31,1,31,1,31,1,31,1,31,1,32,1,32,1,33,1,33,1,33,
  	1,33,1,34,1,34,1,34,1,34,1,34,1,34,3,34,386,8,34,1,35,1,35,3,35,390,8,
  	35,1,36,1,36,1,37,1,37,1,38,1,38,1,39,1,39,1,40,1,40,1,40,3,40,403,8,
  	40,1,41,1,41,1,41,1,41,3,41,409,8,41,1,42,1,42,1,43,1,43,1,44,1,44,1,
  	45,1,45,1,46,1,46,1,47,1,47,1,48,1,48,1,49,1,49,1,50,1,50,1,51,1,51,1,
  	52,1,52,1,53,1,53,1,54,1,54,1,55,1,55,1,56,1,56,1,57,1,57,3,57,443,8,
  	57,1,58,1,58,1,59,1,59,1,60,1,60,1,61,1,61,1,61,5,61,454,8,61,10,61,12,
  	61,457,9,61,1,62,1,62,1,62,5,62,462,8,62,10,62,12,62,465,9,62,1,63,1,
  	63,1,63,5,63,470,8,63,10,63,12,63,473,9,63,1,64,1,64,1,64,5,64,478,8,
  	64,10,64,12,64,481,9,64,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,1,65,
  	1,65,1,65,1,65,1,65,3,65,496,8,65,1,66,1,66,1,66,3,66,501,8,66,1,67,1,
  	67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,67,3,67,517,
  	8,67,1,68,1,68,1,68,1,68,1,68,3,68,524,8,68,1,69,1,69,1,70,1,70,1,70,
  	1,70,1,70,1,70,1,70,1,70,1,70,3,70,537,8,70,1,71,1,71,1,72,1,72,1,73,
  	1,73,1,74,1,74,1,75,1,75,1,76,1,76,1,77,1,77,1,78,1,78,1,79,1,79,1,80,
  	1,80,1,81,1,81,1,82,1,82,1,83,1,83,1,84,1,84,1,84,5,84,568,8,84,10,84,
  	12,84,571,9,84,1,85,1,85,5,85,575,8,85,10,85,12,85,578,9,85,1,86,1,86,
  	1,86,5,86,583,8,86,10,86,12,86,586,9,86,1,87,1,87,1,87,1,87,1,87,1,87,
  	1,87,3,87,595,8,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,
  	1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,
  	1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,
  	1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,
  	1,87,1,87,1,87,1,87,1,87,3,87,654,8,87,5,87,656,8,87,10,87,12,87,659,
  	9,87,1,88,1,88,1,88,1,88,1,88,1,88,1,88,1,88,1,88,1,88,1,88,1,88,1,88,
  	5,88,674,8,88,10,88,12,88,677,9,88,1,89,1,89,1,89,1,89,1,89,1,89,1,89,
  	1,89,1,89,1,89,1,89,1,89,1,89,1,89,1,89,3,89,694,8,89,1,90,1,90,1,91,
  	1,91,1,91,1,92,1,92,1,92,1,93,1,93,1,93,1,93,1,94,1,94,1,94,1,94,1,95,
  	3,95,713,8,95,1,95,1,95,3,95,717,8,95,1,95,3,95,720,8,95,1,95,1,95,3,
  	95,724,8,95,1,95,1,95,1,95,3,95,729,8,95,1,95,1,95,3,95,733,8,95,1,95,
  	1,95,3,95,737,8,95,1,95,1,95,3,95,741,8,95,1,96,1,96,1,96,1,96,1,97,1,
  	97,1,97,1,97,1,98,1,98,1,99,4,99,754,8,99,11,99,12,99,755,1,99,3,99,759,
  	8,99,1,100,1,100,1,100,1,100,1,100,1,101,1,101,1,101,1,102,1,102,1,102,
  	3,102,772,8,102,1,103,1,103,1,104,1,104,1,104,1,104,1,105,1,105,1,105,
  	1,105,1,105,3,105,785,8,105,1,106,1,106,1,107,1,107,1,107,1,107,1,107,
  	1,107,1,107,1,107,1,107,3,107,798,8,107,1,108,1,108,1,108,3,108,803,8,
  	108,1,108,1,108,3,108,807,8,108,1,108,1,108,3,108,811,8,108,1,108,1,108,
  	3,108,815,8,108,1,108,1,108,3,108,819,8,108,1,108,1,108,3,108,823,8,108,
  	1,108,1,108,1,108,1,108,1,108,1,108,3,108,831,8,108,1,109,1,109,1,109,
  	1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,3,109,
  	847,8,109,1,110,1,110,1,110,1,110,1,110,3,110,854,8,110,1,111,1,111,1,
  	112,1,112,1,112,1,112,3,112,862,8,112,1,113,1,113,1,113,1,113,3,113,868,
  	8,113,1,114,1,114,1,114,3,114,873,8,114,1,115,1,115,1,115,1,115,3,115,
  	879,8,115,1,116,1,116,1,116,3,116,884,8,116,1,116,0,2,174,176,117,0,2,
  	4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,
  	52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,
  	98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,
  	134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,
  	170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,
  	206,208,210,212,214,216,218,220,222,224,226,228,230,232,0,33,2,0,34,37,
  	40,42,1,0,38,39,2,0,182,182,184,184,1,0,49,50,2,0,45,48,51,55,1,0,43,
  	44,1,0,60,62,1,0,56,57,1,0,73,74,1,0,75,80,1,0,63,72,2,0,81,81,85,85,
  	2,0,82,82,86,86,2,0,83,83,87,87,1,0,88,93,1,0,94,96,1,0,97,118,1,0,199,
  	204,1,0,205,210,1,0,212,218,1,0,219,225,1,0,226,231,1,0,232,242,1,0,243,
  	248,1,0,249,253,1,0,254,258,1,0,259,260,1,0,261,265,1,0,266,272,1,0,196,
  	198,1,0,177,181,1,0,175,176,1,0,274,275,922,0,236,1,0,0,0,2,238,1,0,0,
  	0,4,241,1,0,0,0,6,254,1,0,0,0,8,259,1,0,0,0,10,261,1,0,0,0,12,263,1,0,
  	0,0,14,268,1,0,0,0,16,277,1,0,0,0,18,279,1,0,0,0,20,281,1,0,0,0,22,284,
  	1,0,0,0,24,292,1,0,0,0,26,296,1,0,0,0,28,298,1,0,0,0,30,301,1,0,0,0,32,
  	303,1,0,0,0,34,306,1,0,0,0,36,314,1,0,0,0,38,329,1,0,0,0,40,331,1,0,0,
  	0,42,335,1,0,0,0,44,339,1,0,0,0,46,343,1,0,0,0,48,350,1,0,0,0,50,352,
  	1,0,0,0,52,354,1,0,0,0,54,356,1,0,0,0,56,360,1,0,0,0,58,364,1,0,0,0,60,
  	366,1,0,0,0,62,368,1,0,0,0,64,373,1,0,0,0,66,375,1,0,0,0,68,385,1,0,0,
  	0,70,389,1,0,0,0,72,391,1,0,0,0,74,393,1,0,0,0,76,395,1,0,0,0,78,397,
  	1,0,0,0,80,402,1,0,0,0,82,408,1,0,0,0,84,410,1,0,0,0,86,412,1,0,0,0,88,
  	414,1,0,0,0,90,416,1,0,0,0,92,418,1,0,0,0,94,420,1,0,0,0,96,422,1,0,0,
  	0,98,424,1,0,0,0,100,426,1,0,0,0,102,428,1,0,0,0,104,430,1,0,0,0,106,
  	432,1,0,0,0,108,434,1,0,0,0,110,436,1,0,0,0,112,438,1,0,0,0,114,442,1,
  	0,0,0,116,444,1,0,0,0,118,446,1,0,0,0,120,448,1,0,0,0,122,450,1,0,0,0,
  	124,458,1,0,0,0,126,466,1,0,0,0,128,474,1,0,0,0,130,495,1,0,0,0,132,500,
  	1,0,0,0,134,516,1,0,0,0,136,523,1,0,0,0,138,525,1,0,0,0,140,536,1,0,0,
  	0,142,538,1,0,0,0,144,540,1,0,0,0,146,542,1,0,0,0,148,544,1,0,0,0,150,
  	546,1,0,0,0,152,548,1,0,0,0,154,550,1,0,0,0,156,552,1,0,0,0,158,554,1,
  	0,0,0,160,556,1,0,0,0,162,558,1,0,0,0,164,560,1,0,0,0,166,562,1,0,0,0,
  	168,564,1,0,0,0,170,572,1,0,0,0,172,579,1,0,0,0,174,594,1,0,0,0,176,660,
  	1,0,0,0,178,693,1,0,0,0,180,695,1,0,0,0,182,697,1,0,0,0,184,700,1,0,0,
  	0,186,703,1,0,0,0,188,707,1,0,0,0,190,740,1,0,0,0,192,742,1,0,0,0,194,
  	746,1,0,0,0,196,750,1,0,0,0,198,753,1,0,0,0,200,760,1,0,0,0,202,765,1,
  	0,0,0,204,771,1,0,0,0,206,773,1,0,0,0,208,775,1,0,0,0,210,784,1,0,0,0,
  	212,786,1,0,0,0,214,797,1,0,0,0,216,830,1,0,0,0,218,846,1,0,0,0,220,853,
  	1,0,0,0,222,855,1,0,0,0,224,861,1,0,0,0,226,867,1,0,0,0,228,872,1,0,0,
  	0,230,878,1,0,0,0,232,883,1,0,0,0,234,237,3,2,1,0,235,237,3,4,2,0,236,
  	234,1,0,0,0,236,235,1,0,0,0,237,1,1,0,0,0,238,239,3,6,3,0,239,3,1,0,0,
  	0,240,242,5,158,0,0,241,240,1,0,0,0,241,242,1,0,0,0,242,248,1,0,0,0,243,
  	244,3,6,3,0,244,245,5,156,0,0,245,247,1,0,0,0,246,243,1,0,0,0,247,250,
  	1,0,0,0,248,246,1,0,0,0,248,249,1,0,0,0,249,5,1,0,0,0,250,248,1,0,0,0,
  	251,255,3,8,4,0,252,255,3,16,8,0,253,255,3,38,19,0,254,251,1,0,0,0,254,
  	252,1,0,0,0,254,253,1,0,0,0,255,7,1,0,0,0,256,260,3,10,5,0,257,260,3,
  	12,6,0,258,260,3,14,7,0,259,256,1,0,0,0,259,257,1,0,0,0,259,258,1,0,0,
  	0,260,9,1,0,0,0,261,262,5,150,0,0,262,11,1,0,0,0,263,264,5,149,0,0,264,
  	266,5,142,0,0,265,267,3,168,84,0,266,265,1,0,0,0,266,267,1,0,0,0,267,
  	13,1,0,0,0,268,269,5,151,0,0,269,272,3,174,87,0,270,271,5,13,0,0,271,
  	273,3,174,87,0,272,270,1,0,0,0,272,273,1,0,0,0,273,15,1,0,0,0,274,278,
  	3,18,9,0,275,278,3,26,13,0,276,278,3,30,15,0,277,274,1,0,0,0,277,275,
  	1,0,0,0,277,276,1,0,0,0,278,17,1,0,0,0,279,280,3,20,10,0,280,19,1,0,0,
  	0,281,282,5,168,0,0,282,283,3,22,11,0,283,21,1,0,0,0,284,289,3,24,12,
  	0,285,286,5,10,0,0,286,288,3,24,12,0,287,285,1,0,0,0,288,291,1,0,0,0,
  	289,287,1,0,0,0,289,290,1,0,0,0,290,23,1,0,0,0,291,289,1,0,0,0,292,293,
  	3,126,63,0,293,294,3,116,58,0,294,295,3,168,84,0,295,25,1,0,0,0,296,297,
  	3,28,14,0,297,27,1,0,0,0,298,299,5,169,0,0,299,300,3,34,17,0,300,29,1,
  	0,0,0,301,302,3,32,16,0,302,31,1,0,0,0,303,304,5,170,0,0,304,305,3,34,
  	17,0,305,33,1,0,0,0,306,311,3,36,18,0,307,308,5,10,0,0,308,310,3,36,18,
  	0,309,307,1,0,0,0,310,313,1,0,0,0,311,309,1,0,0,0,311,312,1,0,0,0,312,
  	35,1,0,0,0,313,311,1,0,0,0,314,316,3,126,63,0,315,317,3,130,65,0,316,
  	315,1,0,0,0,316,317,1,0,0,0,317,321,1,0,0,0,318,319,3,116,58,0,319,320,
  	3,168,84,0,320,322,1,0,0,0,321,318,1,0,0,0,321,322,1,0,0,0,322,37,1,0,
  	0,0,323,330,3,40,20,0,324,330,3,42,21,0,325,330,3,44,22,0,326,330,3,46,
  	23,0,327,330,3,48,24,0,328,330,3,56,28,0,329,323,1,0,0,0,329,324,1,0,
  	0,0,329,325,1,0,0,0,329,326,1,0,0,0,329,327,1,0,0,0,329,328,1,0,0,0,330,
  	39,1,0,0,0,331,333,5,143,0,0,332,334,3,38,19,0,333,332,1,0,0,0,333,334,
  	1,0,0,0,334,41,1,0,0,0,335,337,5,152,0,0,336,338,3,38,19,0,337,336,1,
  	0,0,0,337,338,1,0,0,0,338,43,1,0,0,0,339,341,5,153,0,0,340,342,3,38,19,
  	0,341,340,1,0,0,0,341,342,1,0,0,0,342,45,1,0,0,0,343,344,5,1,0,0,344,
  	345,3,38,19,0,345,346,5,2,0,0,346,47,1,0,0,0,347,351,3,50,25,0,348,351,
  	3,52,26,0,349,351,3,54,27,0,350,347,1,0,0,0,350,348,1,0,0,0,350,349,1,
  	0,0,0,351,49,1,0,0,0,352,353,5,120,0,0,353,51,1,0,0,0,354,355,3,168,84,
  	0,355,53,1,0,0,0,356,357,3,172,86,0,357,358,3,114,57,0,358,359,3,168,
  	84,0,359,55,1,0,0,0,360,361,3,58,29,0,361,57,1,0,0,0,362,365,3,60,30,
  	0,363,365,3,64,32,0,364,362,1,0,0,0,364,363,1,0,0,0,365,59,1,0,0,0,366,
  	367,3,62,31,0,367,61,1,0,0,0,368,369,5,171,0,0,369,370,3,174,87,0,370,
  	371,5,172,0,0,371,372,3,48,24,0,372,63,1,0,0,0,373,374,3,66,33,0,374,
  	65,1,0,0,0,375,376,3,48,24,0,376,377,5,173,0,0,377,378,3,174,87,0,378,
  	67,1,0,0,0,379,386,3,72,36,0,380,386,3,74,37,0,381,386,3,76,38,0,382,
  	386,3,78,39,0,383,386,3,80,40,0,384,386,3,84,42,0,385,379,1,0,0,0,385,
  	380,1,0,0,0,385,381,1,0,0,0,385,382,1,0,0,0,385,383,1,0,0,0,385,384,1,
  	0,0,0,386,69,1,0,0,0,387,390,3,80,40,0,388,390,3,82,41,0,389,387,1,0,
  	0,0,389,388,1,0,0,0,390,71,1,0,0,0,391,392,7,0,0,0,392,73,1,0,0,0,393,
  	394,7,1,0,0,394,75,1,0,0,0,395,396,5,84,0,0,396,77,1,0,0,0,397,398,5,
  	120,0,0,398,79,1,0,0,0,399,403,5,28,0,0,400,401,5,28,0,0,401,403,5,28,
  	0,0,402,399,1,0,0,0,402,400,1,0,0,0,403,81,1,0,0,0,404,409,5,31,0,0,405,
  	406,5,31,0,0,406,407,5,31,0,0,407,409,5,31,0,0,408,404,1,0,0,0,408,405,
  	1,0,0,0,409,83,1,0,0,0,410,411,7,2,0,0,411,85,1,0,0,0,412,413,7,3,0,0,
  	413,87,1,0,0,0,414,415,7,4,0,0,415,89,1,0,0,0,416,417,7,5,0,0,417,91,
  	1,0,0,0,418,419,7,6,0,0,419,93,1,0,0,0,420,421,7,7,0,0,421,95,1,0,0,0,
  	422,423,5,58,0,0,423,97,1,0,0,0,424,425,5,59,0,0,425,99,1,0,0,0,426,427,
  	7,8,0,0,427,101,1,0,0,0,428,429,7,9,0,0,429,103,1,0,0,0,430,431,7,10,
  	0,0,431,105,1,0,0,0,432,433,7,11,0,0,433,107,1,0,0,0,434,435,7,12,0,0,
  	435,109,1,0,0,0,436,437,7,13,0,0,437,111,1,0,0,0,438,439,7,14,0,0,439,
  	113,1,0,0,0,440,443,3,116,58,0,441,443,3,118,59,0,442,440,1,0,0,0,442,
  	441,1,0,0,0,443,115,1,0,0,0,444,445,7,15,0,0,445,117,1,0,0,0,446,447,
  	7,16,0,0,447,119,1,0,0,0,448,449,5,142,0,0,449,121,1,0,0,0,450,455,5,
  	142,0,0,451,452,5,9,0,0,452,454,5,142,0,0,453,451,1,0,0,0,454,457,1,0,
  	0,0,455,453,1,0,0,0,455,456,1,0,0,0,456,123,1,0,0,0,457,455,1,0,0,0,458,
  	463,5,142,0,0,459,460,5,10,0,0,460,462,5,142,0,0,461,459,1,0,0,0,462,
  	465,1,0,0,0,463,461,1,0,0,0,463,464,1,0,0,0,464,125,1,0,0,0,465,463,1,
  	0,0,0,466,471,3,120,60,0,467,468,5,10,0,0,468,470,3,120,60,0,469,467,
  	1,0,0,0,470,473,1,0,0,0,471,469,1,0,0,0,471,472,1,0,0,0,472,127,1,0,0,
  	0,473,471,1,0,0,0,474,479,3,122,61,0,475,476,5,10,0,0,476,478,3,122,61,
  	0,477,475,1,0,0,0,478,481,1,0,0,0,479,477,1,0,0,0,479,480,1,0,0,0,480,
  	129,1,0,0,0,481,479,1,0,0,0,482,496,3,132,66,0,483,484,3,132,66,0,484,
  	485,3,134,67,0,485,496,1,0,0,0,486,487,3,132,66,0,487,488,5,21,0,0,488,
  	489,3,132,66,0,489,496,1,0,0,0,490,491,3,132,66,0,491,492,5,29,0,0,492,
  	493,3,130,65,0,493,496,1,0,0,0,494,496,3,132,66,0,495,482,1,0,0,0,495,
  	483,1,0,0,0,495,486,1,0,0,0,495,490,1,0,0,0,495,494,1,0,0,0,496,131,1,
  	0,0,0,497,501,3,136,68,0,498,501,3,164,82,0,499,501,3,166,83,0,500,497,
  	1,0,0,0,500,498,1,0,0,0,500,499,1,0,0,0,501,133,1,0,0,0,502,517,5,13,
  	0,0,503,517,5,14,0,0,504,505,5,14,0,0,505,517,5,14,0,0,506,507,5,29,0,
  	0,507,517,5,8,0,0,508,509,5,13,0,0,509,517,5,14,0,0,510,511,5,13,0,0,
  	511,512,5,14,0,0,512,517,5,14,0,0,513,514,5,13,0,0,514,515,5,29,0,0,515,
  	517,5,8,0,0,516,502,1,0,0,0,516,503,1,0,0,0,516,504,1,0,0,0,516,506,1,
  	0,0,0,516,508,1,0,0,0,516,510,1,0,0,0,516,513,1,0,0,0,517,135,1,0,0,0,
  	518,524,3,138,69,0,519,524,3,140,70,0,520,524,3,158,79,0,521,524,3,160,
  	80,0,522,524,3,162,81,0,523,518,1,0,0,0,523,519,1,0,0,0,523,520,1,0,0,
  	0,523,521,1,0,0,0,523,522,1,0,0,0,524,137,1,0,0,0,525,526,7,17,0,0,526,
  	139,1,0,0,0,527,537,3,142,71,0,528,537,3,144,72,0,529,537,3,146,73,0,
  	530,537,3,148,74,0,531,537,3,150,75,0,532,537,3,152,76,0,533,537,3,154,
  	77,0,534,537,3,156,78,0,535,537,5,211,0,0,536,527,1,0,0,0,536,528,1,0,
  	0,0,536,529,1,0,0,0,536,530,1,0,0,0,536,531,1,0,0,0,536,532,1,0,0,0,536,
  	533,1,0,0,0,536,534,1,0,0,0,536,535,1,0,0,0,537,141,1,0,0,0,538,539,7,
  	18,0,0,539,143,1,0,0,0,540,541,7,19,0,0,541,145,1,0,0,0,542,543,7,20,
  	0,0,543,147,1,0,0,0,544,545,7,21,0,0,545,149,1,0,0,0,546,547,7,22,0,0,
  	547,151,1,0,0,0,548,549,7,23,0,0,549,153,1,0,0,0,550,551,7,24,0,0,551,
  	155,1,0,0,0,552,553,7,25,0,0,553,157,1,0,0,0,554,555,7,26,0,0,555,159,
  	1,0,0,0,556,557,7,27,0,0,557,161,1,0,0,0,558,559,7,28,0,0,559,163,1,0,
  	0,0,560,561,5,273,0,0,561,165,1,0,0,0,562,563,7,29,0,0,563,167,1,0,0,
  	0,564,569,3,174,87,0,565,566,5,10,0,0,566,568,3,174,87,0,567,565,1,0,
  	0,0,568,571,1,0,0,0,569,567,1,0,0,0,569,570,1,0,0,0,570,169,1,0,0,0,571,
  	569,1,0,0,0,572,576,3,174,87,0,573,575,3,174,87,0,574,573,1,0,0,0,575,
  	578,1,0,0,0,576,574,1,0,0,0,576,577,1,0,0,0,577,171,1,0,0,0,578,576,1,
  	0,0,0,579,584,3,176,88,0,580,581,5,10,0,0,581,583,3,176,88,0,582,580,
  	1,0,0,0,583,586,1,0,0,0,584,582,1,0,0,0,584,585,1,0,0,0,585,173,1,0,0,
  	0,586,584,1,0,0,0,587,588,6,87,-1,0,588,595,3,176,88,0,589,590,3,68,34,
  	0,590,591,3,174,87,18,591,595,1,0,0,0,592,595,3,194,97,0,593,595,3,196,
  	98,0,594,587,1,0,0,0,594,589,1,0,0,0,594,592,1,0,0,0,594,593,1,0,0,0,
  	595,657,1,0,0,0,596,597,10,16,0,0,597,598,3,86,43,0,598,599,3,174,87,
  	17,599,656,1,0,0,0,600,601,10,15,0,0,601,602,3,88,44,0,602,603,3,174,
  	87,16,603,656,1,0,0,0,604,605,10,14,0,0,605,606,3,90,45,0,606,607,3,174,
  	87,15,607,656,1,0,0,0,608,609,10,13,0,0,609,610,3,92,46,0,610,611,3,174,
  	87,14,611,656,1,0,0,0,612,613,10,12,0,0,613,614,3,94,47,0,614,615,3,174,
  	87,13,615,656,1,0,0,0,616,617,10,11,0,0,617,618,3,96,48,0,618,619,3,174,
  	87,12,619,656,1,0,0,0,620,621,10,10,0,0,621,622,3,98,49,0,622,623,3,174,
  	87,11,623,656,1,0,0,0,624,625,10,9,0,0,625,626,3,100,50,0,626,627,3,174,
  	87,10,627,656,1,0,0,0,628,629,10,8,0,0,629,630,3,102,51,0,630,631,3,174,
  	87,9,631,656,1,0,0,0,632,633,10,7,0,0,633,634,3,104,52,0,634,635,3,174,
  	87,8,635,656,1,0,0,0,636,637,10,6,0,0,637,638,3,106,53,0,638,639,3,174,
  	87,7,639,656,1,0,0,0,640,641,10,5,0,0,641,642,3,108,54,0,642,643,3,174,
  	87,6,643,656,1,0,0,0,644,645,10,4,0,0,645,646,3,110,55,0,646,647,3,174,
  	87,5,647,656,1,0,0,0,648,649,10,17,0,0,649,656,3,70,35,0,650,651,10,3,
  	0,0,651,653,3,112,56,0,652,654,3,174,87,0,653,652,1,0,0,0,653,654,1,0,
  	0,0,654,656,1,0,0,0,655,596,1,0,0,0,655,600,1,0,0,0,655,604,1,0,0,0,655,
  	608,1,0,0,0,655,612,1,0,0,0,655,616,1,0,0,0,655,620,1,0,0,0,655,624,1,
  	0,0,0,655,628,1,0,0,0,655,632,1,0,0,0,655,636,1,0,0,0,655,640,1,0,0,0,
  	655,644,1,0,0,0,655,648,1,0,0,0,655,650,1,0,0,0,656,659,1,0,0,0,657,655,
  	1,0,0,0,657,658,1,0,0,0,658,175,1,0,0,0,659,657,1,0,0,0,660,661,6,88,
  	-1,0,661,662,3,178,89,0,662,675,1,0,0,0,663,664,10,5,0,0,664,674,3,182,
  	91,0,665,666,10,4,0,0,666,674,3,184,92,0,667,668,10,3,0,0,668,674,3,186,
  	93,0,669,670,10,2,0,0,670,674,3,188,94,0,671,672,10,1,0,0,672,674,3,192,
  	96,0,673,663,1,0,0,0,673,665,1,0,0,0,673,667,1,0,0,0,673,669,1,0,0,0,
  	673,671,1,0,0,0,674,677,1,0,0,0,675,673,1,0,0,0,675,676,1,0,0,0,676,177,
  	1,0,0,0,677,675,1,0,0,0,678,694,3,204,102,0,679,694,3,206,103,0,680,694,
  	3,122,61,0,681,682,3,122,61,0,682,683,3,174,87,0,683,694,1,0,0,0,684,
  	685,3,180,90,0,685,686,5,17,0,0,686,687,3,122,61,0,687,688,3,168,84,0,
  	688,694,1,0,0,0,689,690,5,1,0,0,690,691,3,168,84,0,691,692,5,2,0,0,692,
  	694,1,0,0,0,693,678,1,0,0,0,693,679,1,0,0,0,693,680,1,0,0,0,693,681,1,
  	0,0,0,693,684,1,0,0,0,693,689,1,0,0,0,694,179,1,0,0,0,695,696,7,30,0,
  	0,696,181,1,0,0,0,697,698,5,11,0,0,698,699,3,122,61,0,699,183,1,0,0,0,
  	700,701,5,9,0,0,701,702,5,142,0,0,702,185,1,0,0,0,703,704,5,3,0,0,704,
  	705,3,168,84,0,705,706,5,4,0,0,706,187,1,0,0,0,707,708,5,3,0,0,708,709,
  	3,190,95,0,709,710,5,4,0,0,710,189,1,0,0,0,711,713,3,174,87,0,712,711,
  	1,0,0,0,712,713,1,0,0,0,713,714,1,0,0,0,714,716,5,119,0,0,715,717,3,174,
  	87,0,716,715,1,0,0,0,716,717,1,0,0,0,717,741,1,0,0,0,718,720,3,174,87,
  	0,719,718,1,0,0,0,719,720,1,0,0,0,720,721,1,0,0,0,721,723,5,119,0,0,722,
  	724,3,174,87,0,723,722,1,0,0,0,723,724,1,0,0,0,724,725,1,0,0,0,725,726,
  	5,12,0,0,726,741,3,174,87,0,727,729,3,174,87,0,728,727,1,0,0,0,728,729,
  	1,0,0,0,729,730,1,0,0,0,730,732,5,119,0,0,731,733,3,174,87,0,732,731,
  	1,0,0,0,732,733,1,0,0,0,733,734,1,0,0,0,734,736,5,12,0,0,735,737,3,174,
  	87,0,736,735,1,0,0,0,736,737,1,0,0,0,737,738,1,0,0,0,738,739,5,12,0,0,
  	739,741,3,174,87,0,740,712,1,0,0,0,740,719,1,0,0,0,740,728,1,0,0,0,741,
  	191,1,0,0,0,742,743,5,1,0,0,743,744,3,168,84,0,744,745,5,2,0,0,745,193,
  	1,0,0,0,746,747,3,176,88,0,747,748,3,114,57,0,748,749,3,174,87,0,749,
  	195,1,0,0,0,750,751,3,198,99,0,751,197,1,0,0,0,752,754,3,200,100,0,753,
  	752,1,0,0,0,754,755,1,0,0,0,755,753,1,0,0,0,755,756,1,0,0,0,756,758,1,
  	0,0,0,757,759,3,202,101,0,758,757,1,0,0,0,758,759,1,0,0,0,759,199,1,0,
  	0,0,760,761,5,29,0,0,761,762,3,174,87,0,762,763,5,122,0,0,763,764,3,174,
  	87,0,764,201,1,0,0,0,765,766,5,29,0,0,766,767,3,174,87,0,767,203,1,0,
  	0,0,768,772,3,210,105,0,769,772,3,222,111,0,770,772,3,224,112,0,771,768,
  	1,0,0,0,771,769,1,0,0,0,771,770,1,0,0,0,772,205,1,0,0,0,773,774,7,31,
  	0,0,774,207,1,0,0,0,775,776,5,1,0,0,776,777,3,174,87,0,777,778,5,2,0,
  	0,778,209,1,0,0,0,779,785,3,212,106,0,780,785,3,214,107,0,781,785,3,216,
  	108,0,782,785,3,218,109,0,783,785,3,220,110,0,784,779,1,0,0,0,784,780,
  	1,0,0,0,784,781,1,0,0,0,784,782,1,0,0,0,784,783,1,0,0,0,785,211,1,0,0,
  	0,786,787,7,32,0,0,787,213,1,0,0,0,788,798,5,124,0,0,789,790,5,276,0,
  	0,790,798,3,208,104,0,791,798,5,277,0,0,792,798,5,278,0,0,793,798,5,279,
  	0,0,794,798,5,280,0,0,795,798,5,281,0,0,796,798,5,282,0,0,797,788,1,0,
  	0,0,797,789,1,0,0,0,797,791,1,0,0,0,797,792,1,0,0,0,797,793,1,0,0,0,797,
  	794,1,0,0,0,797,795,1,0,0,0,797,796,1,0,0,0,798,215,1,0,0,0,799,831,5,
  	125,0,0,800,802,5,283,0,0,801,803,3,208,104,0,802,801,1,0,0,0,802,803,
  	1,0,0,0,803,831,1,0,0,0,804,806,5,284,0,0,805,807,3,208,104,0,806,805,
  	1,0,0,0,806,807,1,0,0,0,807,831,1,0,0,0,808,810,5,285,0,0,809,811,3,208,
  	104,0,810,809,1,0,0,0,810,811,1,0,0,0,811,831,1,0,0,0,812,814,5,286,0,
  	0,813,815,3,208,104,0,814,813,1,0,0,0,814,815,1,0,0,0,815,831,1,0,0,0,
  	816,818,5,287,0,0,817,819,3,208,104,0,818,817,1,0,0,0,818,819,1,0,0,0,
  	819,831,1,0,0,0,820,822,5,288,0,0,821,823,3,208,104,0,822,821,1,0,0,0,
  	822,823,1,0,0,0,823,831,1,0,0,0,824,831,5,289,0,0,825,831,5,290,0,0,826,
  	831,5,291,0,0,827,831,5,292,0,0,828,831,5,293,0,0,829,831,5,294,0,0,830,
  	799,1,0,0,0,830,800,1,0,0,0,830,804,1,0,0,0,830,808,1,0,0,0,830,812,1,
  	0,0,0,830,816,1,0,0,0,830,820,1,0,0,0,830,824,1,0,0,0,830,825,1,0,0,0,
  	830,826,1,0,0,0,830,827,1,0,0,0,830,828,1,0,0,0,830,829,1,0,0,0,831,217,
  	1,0,0,0,832,847,5,136,0,0,833,834,5,295,0,0,834,847,3,208,104,0,835,836,
  	5,297,0,0,836,847,3,208,104,0,837,838,5,298,0,0,838,847,3,208,104,0,839,
  	840,5,299,0,0,840,847,3,208,104,0,841,842,5,300,0,0,842,847,3,208,104,
  	0,843,844,5,301,0,0,844,847,3,208,104,0,845,847,5,302,0,0,846,832,1,0,
  	0,0,846,833,1,0,0,0,846,835,1,0,0,0,846,837,1,0,0,0,846,839,1,0,0,0,846,
  	841,1,0,0,0,846,843,1,0,0,0,846,845,1,0,0,0,847,219,1,0,0,0,848,854,5,
  	127,0,0,849,854,5,126,0,0,850,851,5,304,0,0,851,854,3,208,104,0,852,854,
  	5,303,0,0,853,848,1,0,0,0,853,849,1,0,0,0,853,850,1,0,0,0,853,852,1,0,
  	0,0,854,221,1,0,0,0,855,856,5,140,0,0,856,223,1,0,0,0,857,862,3,226,113,
  	0,858,862,3,228,114,0,859,862,3,230,115,0,860,862,3,232,116,0,861,857,
  	1,0,0,0,861,858,1,0,0,0,861,859,1,0,0,0,861,860,1,0,0,0,862,225,1,0,0,
  	0,863,864,5,305,0,0,864,868,3,208,104,0,865,866,5,306,0,0,866,868,3,208,
  	104,0,867,863,1,0,0,0,867,865,1,0,0,0,868,227,1,0,0,0,869,870,5,307,0,
  	0,870,873,3,208,104,0,871,873,5,308,0,0,872,869,1,0,0,0,872,871,1,0,0,
  	0,873,229,1,0,0,0,874,875,5,309,0,0,875,879,3,208,104,0,876,877,5,310,
  	0,0,877,879,3,208,104,0,878,874,1,0,0,0,878,876,1,0,0,0,879,231,1,0,0,
  	0,880,881,5,311,0,0,881,884,3,208,104,0,882,884,5,312,0,0,883,880,1,0,
  	0,0,883,882,1,0,0,0,884,233,1,0,0,0,69,236,241,248,254,259,266,272,277,
  	289,311,316,321,329,333,337,341,350,364,385,389,402,408,442,455,463,471,
  	479,495,500,516,523,536,569,576,584,594,653,655,657,673,675,693,712,716,
  	719,723,728,732,736,740,755,758,771,784,797,802,806,810,814,818,822,830,
  	846,853,861,867,872,878,883
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  neobasicparserParserStaticData = std::move(staticData);
}

}

NeoBasicParser::NeoBasicParser(TokenStream *input) : NeoBasicParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

NeoBasicParser::NeoBasicParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  NeoBasicParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *neobasicparserParserStaticData->atn, neobasicparserParserStaticData->decisionToDFA, neobasicparserParserStaticData->sharedContextCache, options);
}

NeoBasicParser::~NeoBasicParser() {
  delete _interpreter;
}

const atn::ATN& NeoBasicParser::getATN() const {
  return *neobasicparserParserStaticData->atn;
}

std::string NeoBasicParser::getGrammarFileName() const {
  return "NeoBasicParser.g4";
}

const std::vector<std::string>& NeoBasicParser::getRuleNames() const {
  return neobasicparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& NeoBasicParser::getVocabulary() const {
  return neobasicparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView NeoBasicParser::getSerializedATN() const {
  return neobasicparserParserStaticData->serializedATN;
}


//----------------- NeoProgramContext ------------------------------------------------------------------

NeoBasicParser::NeoProgramContext::NeoProgramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::OneLinerProgramContext* NeoBasicParser::NeoProgramContext::oneLinerProgram() {
  return getRuleContext<NeoBasicParser::OneLinerProgramContext>(0);
}

NeoBasicParser::ScriptFileProgramContext* NeoBasicParser::NeoProgramContext::scriptFileProgram() {
  return getRuleContext<NeoBasicParser::ScriptFileProgramContext>(0);
}


size_t NeoBasicParser::NeoProgramContext::getRuleIndex() const {
  return NeoBasicParser::RuleNeoProgram;
}

void NeoBasicParser::NeoProgramContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNeoProgram(this);
}

void NeoBasicParser::NeoProgramContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNeoProgram(this);
}

NeoBasicParser::NeoProgramContext* NeoBasicParser::neoProgram() {
  NeoProgramContext *_localctx = _tracker.createInstance<NeoProgramContext>(_ctx, getState());
  enterRule(_localctx, 0, NeoBasicParser::RuleNeoProgram);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(236);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(234);
      oneLinerProgram();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(235);
      scriptFileProgram();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OneLinerProgramContext ------------------------------------------------------------------

NeoBasicParser::OneLinerProgramContext::OneLinerProgramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::InstructionSentenceContext* NeoBasicParser::OneLinerProgramContext::instructionSentence() {
  return getRuleContext<NeoBasicParser::InstructionSentenceContext>(0);
}


size_t NeoBasicParser::OneLinerProgramContext::getRuleIndex() const {
  return NeoBasicParser::RuleOneLinerProgram;
}

void NeoBasicParser::OneLinerProgramContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOneLinerProgram(this);
}

void NeoBasicParser::OneLinerProgramContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOneLinerProgram(this);
}

NeoBasicParser::OneLinerProgramContext* NeoBasicParser::oneLinerProgram() {
  OneLinerProgramContext *_localctx = _tracker.createInstance<OneLinerProgramContext>(_ctx, getState());
  enterRule(_localctx, 2, NeoBasicParser::RuleOneLinerProgram);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(238);
    instructionSentence();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ScriptFileProgramContext ------------------------------------------------------------------

NeoBasicParser::ScriptFileProgramContext::ScriptFileProgramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::ScriptFileProgramContext::BOM() {
  return getToken(NeoBasicParser::BOM, 0);
}

std::vector<NeoBasicParser::InstructionSentenceContext *> NeoBasicParser::ScriptFileProgramContext::instructionSentence() {
  return getRuleContexts<NeoBasicParser::InstructionSentenceContext>();
}

NeoBasicParser::InstructionSentenceContext* NeoBasicParser::ScriptFileProgramContext::instructionSentence(size_t i) {
  return getRuleContext<NeoBasicParser::InstructionSentenceContext>(i);
}

std::vector<tree::TerminalNode *> NeoBasicParser::ScriptFileProgramContext::EOS() {
  return getTokens(NeoBasicParser::EOS);
}

tree::TerminalNode* NeoBasicParser::ScriptFileProgramContext::EOS(size_t i) {
  return getToken(NeoBasicParser::EOS, i);
}


size_t NeoBasicParser::ScriptFileProgramContext::getRuleIndex() const {
  return NeoBasicParser::RuleScriptFileProgram;
}

void NeoBasicParser::ScriptFileProgramContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScriptFileProgram(this);
}

void NeoBasicParser::ScriptFileProgramContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScriptFileProgram(this);
}

NeoBasicParser::ScriptFileProgramContext* NeoBasicParser::scriptFileProgram() {
  ScriptFileProgramContext *_localctx = _tracker.createInstance<ScriptFileProgramContext>(_ctx, getState());
  enterRule(_localctx, 4, NeoBasicParser::RuleScriptFileProgram);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(241);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NeoBasicParser::BOM) {
      setState(240);
      match(NeoBasicParser::BOM);
    }
    setState(248);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 8779718459394) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 84)) & 941268883514327041) != 0) || ((((_la - 149) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 149)) & 51480363039) != 0) || ((((_la - 274) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 274)) & 549751619583) != 0)) {
      setState(243);
      instructionSentence();
      setState(244);
      match(NeoBasicParser::EOS);
      setState(250);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InstructionSentenceContext ------------------------------------------------------------------

NeoBasicParser::InstructionSentenceContext::InstructionSentenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::DirectiveContext* NeoBasicParser::InstructionSentenceContext::directive() {
  return getRuleContext<NeoBasicParser::DirectiveContext>(0);
}

NeoBasicParser::DeclarationContext* NeoBasicParser::InstructionSentenceContext::declaration() {
  return getRuleContext<NeoBasicParser::DeclarationContext>(0);
}

NeoBasicParser::StatementContext* NeoBasicParser::InstructionSentenceContext::statement() {
  return getRuleContext<NeoBasicParser::StatementContext>(0);
}


size_t NeoBasicParser::InstructionSentenceContext::getRuleIndex() const {
  return NeoBasicParser::RuleInstructionSentence;
}

void NeoBasicParser::InstructionSentenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInstructionSentence(this);
}

void NeoBasicParser::InstructionSentenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInstructionSentence(this);
}

NeoBasicParser::InstructionSentenceContext* NeoBasicParser::instructionSentence() {
  InstructionSentenceContext *_localctx = _tracker.createInstance<InstructionSentenceContext>(_ctx, getState());
  enterRule(_localctx, 6, NeoBasicParser::RuleInstructionSentence);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(254);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::SHEBANG:
      case NeoBasicParser::SHEBANG_INTERPRETER:
      case NeoBasicParser::WOODSTOCK: {
        enterOuterAlt(_localctx, 1);
        setState(251);
        directive();
        break;
      }

      case NeoBasicParser::CONST:
      case NeoBasicParser::VAL:
      case NeoBasicParser::VAR: {
        enterOuterAlt(_localctx, 2);
        setState(252);
        declaration();
        break;
      }

      case NeoBasicParser::LEFT_PARENTHESIS:
      case NeoBasicParser::CARET:
      case NeoBasicParser::PIPE:
      case NeoBasicParser::POSITIVE:
      case NeoBasicParser::NEGATIVE:
      case NeoBasicParser::INCREMENT:
      case NeoBasicParser::DECREMENT:
      case NeoBasicParser::BIT_NOT:
      case NeoBasicParser::BIT_NEGATION:
      case NeoBasicParser::SQUARE_POWER:
      case NeoBasicParser::SQUARE_ROOT:
      case NeoBasicParser::FACTORIAL:
      case NeoBasicParser::LOGICAL_NOT:
      case NeoBasicParser::ELLIPSIS:
      case NeoBasicParser::NUMBER_LIT:
      case NeoBasicParser::TIME_LIT:
      case NeoBasicParser::SEQUENCE_LIT:
      case NeoBasicParser::HEREDOC_LITERAL:
      case NeoBasicParser::CHAR_LIT:
      case NeoBasicParser::RANGE_LIT:
      case NeoBasicParser::IDENTIFIER:
      case NeoBasicParser::ATOM_IDENTIFIER:
      case NeoBasicParser::RUBBERDUCK:
      case NeoBasicParser::TRACERBIRD:
      case NeoBasicParser::IF:
      case NeoBasicParser::THIS:
      case NeoBasicParser::IOTA:
      case NeoBasicParser::ALL:
      case NeoBasicParser::ANY:
      case NeoBasicParser::ONE:
      case NeoBasicParser::TWO:
      case NeoBasicParser::NIL:
      case NeoBasicParser::TYPEOF:
      case NeoBasicParser::SIZEOF:
      case NeoBasicParser::TRUE:
      case NeoBasicParser::FALSE:
      case NeoBasicParser::NONZERO:
      case NeoBasicParser::ZERO:
      case NeoBasicParser::MINVALUE:
      case NeoBasicParser::MAXVALUE:
      case NeoBasicParser::NAN:
      case NeoBasicParser::POSITIVEINFINITY:
      case NeoBasicParser::NEGATIVEINFINITY:
      case NeoBasicParser::LOCALDATE:
      case NeoBasicParser::LOCALDATETIME:
      case NeoBasicParser::OFFSETDATE:
      case NeoBasicParser::OFFSETDATETIME:
      case NeoBasicParser::ZONEDDATE:
      case NeoBasicParser::ZONEDDATETIME:
      case NeoBasicParser::TOMORROW:
      case NeoBasicParser::TODAY:
      case NeoBasicParser::NOW:
      case NeoBasicParser::YESTERDAY:
      case NeoBasicParser::EON:
      case NeoBasicParser::EPOCH:
      case NeoBasicParser::LETTER:
      case NeoBasicParser::DIGIT:
      case NeoBasicParser::PUNCTUATION:
      case NeoBasicParser::SYMBOL:
      case NeoBasicParser::SEPARATOR:
      case NeoBasicParser::NONPRINTABLE:
      case NeoBasicParser::NULL_:
      case NeoBasicParser::BLANK:
      case NeoBasicParser::NONBLANK:
      case NeoBasicParser::OKAY:
      case NeoBasicParser::FAIL:
      case NeoBasicParser::SOME:
      case NeoBasicParser::NONE:
      case NeoBasicParser::YEA:
      case NeoBasicParser::NAY:
      case NeoBasicParser::DATA:
      case NeoBasicParser::EOT: {
        enterOuterAlt(_localctx, 3);
        setState(253);
        statement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DirectiveContext ------------------------------------------------------------------

NeoBasicParser::DirectiveContext::DirectiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::InterpreterDirectiveContext* NeoBasicParser::DirectiveContext::interpreterDirective() {
  return getRuleContext<NeoBasicParser::InterpreterDirectiveContext>(0);
}

NeoBasicParser::PragmaDirectiveContext* NeoBasicParser::DirectiveContext::pragmaDirective() {
  return getRuleContext<NeoBasicParser::PragmaDirectiveContext>(0);
}

NeoBasicParser::CanaryTestDirectiveContext* NeoBasicParser::DirectiveContext::canaryTestDirective() {
  return getRuleContext<NeoBasicParser::CanaryTestDirectiveContext>(0);
}


size_t NeoBasicParser::DirectiveContext::getRuleIndex() const {
  return NeoBasicParser::RuleDirective;
}

void NeoBasicParser::DirectiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDirective(this);
}

void NeoBasicParser::DirectiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDirective(this);
}

NeoBasicParser::DirectiveContext* NeoBasicParser::directive() {
  DirectiveContext *_localctx = _tracker.createInstance<DirectiveContext>(_ctx, getState());
  enterRule(_localctx, 8, NeoBasicParser::RuleDirective);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(259);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::SHEBANG_INTERPRETER: {
        enterOuterAlt(_localctx, 1);
        setState(256);
        interpreterDirective();
        break;
      }

      case NeoBasicParser::SHEBANG: {
        enterOuterAlt(_localctx, 2);
        setState(257);
        pragmaDirective();
        break;
      }

      case NeoBasicParser::WOODSTOCK: {
        enterOuterAlt(_localctx, 3);
        setState(258);
        canaryTestDirective();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InterpreterDirectiveContext ------------------------------------------------------------------

NeoBasicParser::InterpreterDirectiveContext::InterpreterDirectiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::InterpreterDirectiveContext::SHEBANG_INTERPRETER() {
  return getToken(NeoBasicParser::SHEBANG_INTERPRETER, 0);
}


size_t NeoBasicParser::InterpreterDirectiveContext::getRuleIndex() const {
  return NeoBasicParser::RuleInterpreterDirective;
}

void NeoBasicParser::InterpreterDirectiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterpreterDirective(this);
}

void NeoBasicParser::InterpreterDirectiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterpreterDirective(this);
}

NeoBasicParser::InterpreterDirectiveContext* NeoBasicParser::interpreterDirective() {
  InterpreterDirectiveContext *_localctx = _tracker.createInstance<InterpreterDirectiveContext>(_ctx, getState());
  enterRule(_localctx, 10, NeoBasicParser::RuleInterpreterDirective);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(261);
    match(NeoBasicParser::SHEBANG_INTERPRETER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PragmaDirectiveContext ------------------------------------------------------------------

NeoBasicParser::PragmaDirectiveContext::PragmaDirectiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::PragmaDirectiveContext::SHEBANG() {
  return getToken(NeoBasicParser::SHEBANG, 0);
}

tree::TerminalNode* NeoBasicParser::PragmaDirectiveContext::IDENTIFIER() {
  return getToken(NeoBasicParser::IDENTIFIER, 0);
}

NeoBasicParser::ExpressionsContext* NeoBasicParser::PragmaDirectiveContext::expressions() {
  return getRuleContext<NeoBasicParser::ExpressionsContext>(0);
}


size_t NeoBasicParser::PragmaDirectiveContext::getRuleIndex() const {
  return NeoBasicParser::RulePragmaDirective;
}

void NeoBasicParser::PragmaDirectiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragmaDirective(this);
}

void NeoBasicParser::PragmaDirectiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragmaDirective(this);
}

NeoBasicParser::PragmaDirectiveContext* NeoBasicParser::pragmaDirective() {
  PragmaDirectiveContext *_localctx = _tracker.createInstance<PragmaDirectiveContext>(_ctx, getState());
  enterRule(_localctx, 12, NeoBasicParser::RulePragmaDirective);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(263);
    match(NeoBasicParser::SHEBANG);
    setState(264);
    match(NeoBasicParser::IDENTIFIER);
    setState(266);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 8779718459394) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 84)) & 364808131210903553) != 0) || ((((_la - 175) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 175)) & 767) != 0) || ((((_la - 274) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 274)) & 549751619583) != 0)) {
      setState(265);
      expressions();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CanaryTestDirectiveContext ------------------------------------------------------------------

NeoBasicParser::CanaryTestDirectiveContext::CanaryTestDirectiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::CanaryTestDirectiveContext::WOODSTOCK() {
  return getToken(NeoBasicParser::WOODSTOCK, 0);
}

std::vector<NeoBasicParser::ExpressionContext *> NeoBasicParser::CanaryTestDirectiveContext::expression() {
  return getRuleContexts<NeoBasicParser::ExpressionContext>();
}

NeoBasicParser::ExpressionContext* NeoBasicParser::CanaryTestDirectiveContext::expression(size_t i) {
  return getRuleContext<NeoBasicParser::ExpressionContext>(i);
}

tree::TerminalNode* NeoBasicParser::CanaryTestDirectiveContext::EXCLAMATION() {
  return getToken(NeoBasicParser::EXCLAMATION, 0);
}


size_t NeoBasicParser::CanaryTestDirectiveContext::getRuleIndex() const {
  return NeoBasicParser::RuleCanaryTestDirective;
}

void NeoBasicParser::CanaryTestDirectiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCanaryTestDirective(this);
}

void NeoBasicParser::CanaryTestDirectiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCanaryTestDirective(this);
}

NeoBasicParser::CanaryTestDirectiveContext* NeoBasicParser::canaryTestDirective() {
  CanaryTestDirectiveContext *_localctx = _tracker.createInstance<CanaryTestDirectiveContext>(_ctx, getState());
  enterRule(_localctx, 14, NeoBasicParser::RuleCanaryTestDirective);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(268);
    match(NeoBasicParser::WOODSTOCK);
    setState(269);
    expression(0);
    setState(272);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == NeoBasicParser::EXCLAMATION) {
      setState(270);
      match(NeoBasicParser::EXCLAMATION);
      setState(271);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclarationContext ------------------------------------------------------------------

NeoBasicParser::DeclarationContext::DeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::ConstDeclarationContext* NeoBasicParser::DeclarationContext::constDeclaration() {
  return getRuleContext<NeoBasicParser::ConstDeclarationContext>(0);
}

NeoBasicParser::ValDeclarationContext* NeoBasicParser::DeclarationContext::valDeclaration() {
  return getRuleContext<NeoBasicParser::ValDeclarationContext>(0);
}

NeoBasicParser::VarDeclarationContext* NeoBasicParser::DeclarationContext::varDeclaration() {
  return getRuleContext<NeoBasicParser::VarDeclarationContext>(0);
}


size_t NeoBasicParser::DeclarationContext::getRuleIndex() const {
  return NeoBasicParser::RuleDeclaration;
}

void NeoBasicParser::DeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclaration(this);
}

void NeoBasicParser::DeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclaration(this);
}

NeoBasicParser::DeclarationContext* NeoBasicParser::declaration() {
  DeclarationContext *_localctx = _tracker.createInstance<DeclarationContext>(_ctx, getState());
  enterRule(_localctx, 16, NeoBasicParser::RuleDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(277);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::CONST: {
        enterOuterAlt(_localctx, 1);
        setState(274);
        constDeclaration();
        break;
      }

      case NeoBasicParser::VAL: {
        enterOuterAlt(_localctx, 2);
        setState(275);
        valDeclaration();
        break;
      }

      case NeoBasicParser::VAR: {
        enterOuterAlt(_localctx, 3);
        setState(276);
        varDeclaration();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstDeclarationContext ------------------------------------------------------------------

NeoBasicParser::ConstDeclarationContext::ConstDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::ConstClauseContext* NeoBasicParser::ConstDeclarationContext::constClause() {
  return getRuleContext<NeoBasicParser::ConstClauseContext>(0);
}


size_t NeoBasicParser::ConstDeclarationContext::getRuleIndex() const {
  return NeoBasicParser::RuleConstDeclaration;
}

void NeoBasicParser::ConstDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstDeclaration(this);
}

void NeoBasicParser::ConstDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstDeclaration(this);
}

NeoBasicParser::ConstDeclarationContext* NeoBasicParser::constDeclaration() {
  ConstDeclarationContext *_localctx = _tracker.createInstance<ConstDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 18, NeoBasicParser::RuleConstDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(279);
    constClause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstClauseContext ------------------------------------------------------------------

NeoBasicParser::ConstClauseContext::ConstClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::ConstClauseContext::CONST() {
  return getToken(NeoBasicParser::CONST, 0);
}

NeoBasicParser::ConstantsContext* NeoBasicParser::ConstClauseContext::constants() {
  return getRuleContext<NeoBasicParser::ConstantsContext>(0);
}


size_t NeoBasicParser::ConstClauseContext::getRuleIndex() const {
  return NeoBasicParser::RuleConstClause;
}

void NeoBasicParser::ConstClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstClause(this);
}

void NeoBasicParser::ConstClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstClause(this);
}

NeoBasicParser::ConstClauseContext* NeoBasicParser::constClause() {
  ConstClauseContext *_localctx = _tracker.createInstance<ConstClauseContext>(_ctx, getState());
  enterRule(_localctx, 20, NeoBasicParser::RuleConstClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(281);
    match(NeoBasicParser::CONST);
    setState(282);
    constants();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstantsContext ------------------------------------------------------------------

NeoBasicParser::ConstantsContext::ConstantsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NeoBasicParser::ConstantContext *> NeoBasicParser::ConstantsContext::constant() {
  return getRuleContexts<NeoBasicParser::ConstantContext>();
}

NeoBasicParser::ConstantContext* NeoBasicParser::ConstantsContext::constant(size_t i) {
  return getRuleContext<NeoBasicParser::ConstantContext>(i);
}

std::vector<tree::TerminalNode *> NeoBasicParser::ConstantsContext::COMMA() {
  return getTokens(NeoBasicParser::COMMA);
}

tree::TerminalNode* NeoBasicParser::ConstantsContext::COMMA(size_t i) {
  return getToken(NeoBasicParser::COMMA, i);
}


size_t NeoBasicParser::ConstantsContext::getRuleIndex() const {
  return NeoBasicParser::RuleConstants;
}

void NeoBasicParser::ConstantsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstants(this);
}

void NeoBasicParser::ConstantsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstants(this);
}

NeoBasicParser::ConstantsContext* NeoBasicParser::constants() {
  ConstantsContext *_localctx = _tracker.createInstance<ConstantsContext>(_ctx, getState());
  enterRule(_localctx, 22, NeoBasicParser::RuleConstants);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(284);
    constant();
    setState(289);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NeoBasicParser::COMMA) {
      setState(285);
      match(NeoBasicParser::COMMA);
      setState(286);
      constant();
      setState(291);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstantContext ------------------------------------------------------------------

NeoBasicParser::ConstantContext::ConstantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::SymbolIdentifiersContext* NeoBasicParser::ConstantContext::symbolIdentifiers() {
  return getRuleContext<NeoBasicParser::SymbolIdentifiersContext>(0);
}

NeoBasicParser::SingleAssignmentOperatorContext* NeoBasicParser::ConstantContext::singleAssignmentOperator() {
  return getRuleContext<NeoBasicParser::SingleAssignmentOperatorContext>(0);
}

NeoBasicParser::ExpressionsContext* NeoBasicParser::ConstantContext::expressions() {
  return getRuleContext<NeoBasicParser::ExpressionsContext>(0);
}


size_t NeoBasicParser::ConstantContext::getRuleIndex() const {
  return NeoBasicParser::RuleConstant;
}

void NeoBasicParser::ConstantContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstant(this);
}

void NeoBasicParser::ConstantContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstant(this);
}

NeoBasicParser::ConstantContext* NeoBasicParser::constant() {
  ConstantContext *_localctx = _tracker.createInstance<ConstantContext>(_ctx, getState());
  enterRule(_localctx, 24, NeoBasicParser::RuleConstant);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(292);
    symbolIdentifiers();
    setState(293);
    singleAssignmentOperator();
    setState(294);
    expressions();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValDeclarationContext ------------------------------------------------------------------

NeoBasicParser::ValDeclarationContext::ValDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::ValClauseContext* NeoBasicParser::ValDeclarationContext::valClause() {
  return getRuleContext<NeoBasicParser::ValClauseContext>(0);
}


size_t NeoBasicParser::ValDeclarationContext::getRuleIndex() const {
  return NeoBasicParser::RuleValDeclaration;
}

void NeoBasicParser::ValDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValDeclaration(this);
}

void NeoBasicParser::ValDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValDeclaration(this);
}

NeoBasicParser::ValDeclarationContext* NeoBasicParser::valDeclaration() {
  ValDeclarationContext *_localctx = _tracker.createInstance<ValDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 26, NeoBasicParser::RuleValDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(296);
    valClause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValClauseContext ------------------------------------------------------------------

NeoBasicParser::ValClauseContext::ValClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::ValClauseContext::VAL() {
  return getToken(NeoBasicParser::VAL, 0);
}

NeoBasicParser::VariablesContext* NeoBasicParser::ValClauseContext::variables() {
  return getRuleContext<NeoBasicParser::VariablesContext>(0);
}


size_t NeoBasicParser::ValClauseContext::getRuleIndex() const {
  return NeoBasicParser::RuleValClause;
}

void NeoBasicParser::ValClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValClause(this);
}

void NeoBasicParser::ValClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValClause(this);
}

NeoBasicParser::ValClauseContext* NeoBasicParser::valClause() {
  ValClauseContext *_localctx = _tracker.createInstance<ValClauseContext>(_ctx, getState());
  enterRule(_localctx, 28, NeoBasicParser::RuleValClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(298);
    match(NeoBasicParser::VAL);
    setState(299);
    variables();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarDeclarationContext ------------------------------------------------------------------

NeoBasicParser::VarDeclarationContext::VarDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::VarClauseContext* NeoBasicParser::VarDeclarationContext::varClause() {
  return getRuleContext<NeoBasicParser::VarClauseContext>(0);
}


size_t NeoBasicParser::VarDeclarationContext::getRuleIndex() const {
  return NeoBasicParser::RuleVarDeclaration;
}

void NeoBasicParser::VarDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarDeclaration(this);
}

void NeoBasicParser::VarDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarDeclaration(this);
}

NeoBasicParser::VarDeclarationContext* NeoBasicParser::varDeclaration() {
  VarDeclarationContext *_localctx = _tracker.createInstance<VarDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 30, NeoBasicParser::RuleVarDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(301);
    varClause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarClauseContext ------------------------------------------------------------------

NeoBasicParser::VarClauseContext::VarClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::VarClauseContext::VAR() {
  return getToken(NeoBasicParser::VAR, 0);
}

NeoBasicParser::VariablesContext* NeoBasicParser::VarClauseContext::variables() {
  return getRuleContext<NeoBasicParser::VariablesContext>(0);
}


size_t NeoBasicParser::VarClauseContext::getRuleIndex() const {
  return NeoBasicParser::RuleVarClause;
}

void NeoBasicParser::VarClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarClause(this);
}

void NeoBasicParser::VarClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarClause(this);
}

NeoBasicParser::VarClauseContext* NeoBasicParser::varClause() {
  VarClauseContext *_localctx = _tracker.createInstance<VarClauseContext>(_ctx, getState());
  enterRule(_localctx, 32, NeoBasicParser::RuleVarClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(303);
    match(NeoBasicParser::VAR);
    setState(304);
    variables();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariablesContext ------------------------------------------------------------------

NeoBasicParser::VariablesContext::VariablesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NeoBasicParser::VariableContext *> NeoBasicParser::VariablesContext::variable() {
  return getRuleContexts<NeoBasicParser::VariableContext>();
}

NeoBasicParser::VariableContext* NeoBasicParser::VariablesContext::variable(size_t i) {
  return getRuleContext<NeoBasicParser::VariableContext>(i);
}

std::vector<tree::TerminalNode *> NeoBasicParser::VariablesContext::COMMA() {
  return getTokens(NeoBasicParser::COMMA);
}

tree::TerminalNode* NeoBasicParser::VariablesContext::COMMA(size_t i) {
  return getToken(NeoBasicParser::COMMA, i);
}


size_t NeoBasicParser::VariablesContext::getRuleIndex() const {
  return NeoBasicParser::RuleVariables;
}

void NeoBasicParser::VariablesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariables(this);
}

void NeoBasicParser::VariablesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariables(this);
}

NeoBasicParser::VariablesContext* NeoBasicParser::variables() {
  VariablesContext *_localctx = _tracker.createInstance<VariablesContext>(_ctx, getState());
  enterRule(_localctx, 34, NeoBasicParser::RuleVariables);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(306);
    variable();
    setState(311);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NeoBasicParser::COMMA) {
      setState(307);
      match(NeoBasicParser::COMMA);
      setState(308);
      variable();
      setState(313);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableContext ------------------------------------------------------------------

NeoBasicParser::VariableContext::VariableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::SymbolIdentifiersContext* NeoBasicParser::VariableContext::symbolIdentifiers() {
  return getRuleContext<NeoBasicParser::SymbolIdentifiersContext>(0);
}

NeoBasicParser::TypeContext* NeoBasicParser::VariableContext::type() {
  return getRuleContext<NeoBasicParser::TypeContext>(0);
}

NeoBasicParser::SingleAssignmentOperatorContext* NeoBasicParser::VariableContext::singleAssignmentOperator() {
  return getRuleContext<NeoBasicParser::SingleAssignmentOperatorContext>(0);
}

NeoBasicParser::ExpressionsContext* NeoBasicParser::VariableContext::expressions() {
  return getRuleContext<NeoBasicParser::ExpressionsContext>(0);
}


size_t NeoBasicParser::VariableContext::getRuleIndex() const {
  return NeoBasicParser::RuleVariable;
}

void NeoBasicParser::VariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable(this);
}

void NeoBasicParser::VariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable(this);
}

NeoBasicParser::VariableContext* NeoBasicParser::variable() {
  VariableContext *_localctx = _tracker.createInstance<VariableContext>(_ctx, getState());
  enterRule(_localctx, 36, NeoBasicParser::RuleVariable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(314);
    symbolIdentifiers();
    setState(316);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 196) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 196)) & -1) != 0) || ((((_la - 260) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 260)) & 16383) != 0)) {
      setState(315);
      type();
    }
    setState(321);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 94) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 94)) & 7) != 0)) {
      setState(318);
      singleAssignmentOperator();
      setState(319);
      expressions();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

NeoBasicParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::LabeledStatementContext* NeoBasicParser::StatementContext::labeledStatement() {
  return getRuleContext<NeoBasicParser::LabeledStatementContext>(0);
}

NeoBasicParser::DebugingStatementContext* NeoBasicParser::StatementContext::debugingStatement() {
  return getRuleContext<NeoBasicParser::DebugingStatementContext>(0);
}

NeoBasicParser::LoggingStatementContext* NeoBasicParser::StatementContext::loggingStatement() {
  return getRuleContext<NeoBasicParser::LoggingStatementContext>(0);
}

NeoBasicParser::SExpressionStatementContext* NeoBasicParser::StatementContext::sExpressionStatement() {
  return getRuleContext<NeoBasicParser::SExpressionStatementContext>(0);
}

NeoBasicParser::SimpleStatementContext* NeoBasicParser::StatementContext::simpleStatement() {
  return getRuleContext<NeoBasicParser::SimpleStatementContext>(0);
}

NeoBasicParser::CompoundStatementContext* NeoBasicParser::StatementContext::compoundStatement() {
  return getRuleContext<NeoBasicParser::CompoundStatementContext>(0);
}


size_t NeoBasicParser::StatementContext::getRuleIndex() const {
  return NeoBasicParser::RuleStatement;
}

void NeoBasicParser::StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement(this);
}

void NeoBasicParser::StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement(this);
}

NeoBasicParser::StatementContext* NeoBasicParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 38, NeoBasicParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(329);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(323);
      labeledStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(324);
      debugingStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(325);
      loggingStatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(326);
      sExpressionStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(327);
      simpleStatement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(328);
      compoundStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabeledStatementContext ------------------------------------------------------------------

NeoBasicParser::LabeledStatementContext::LabeledStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::LabeledStatementContext::ATOM_IDENTIFIER() {
  return getToken(NeoBasicParser::ATOM_IDENTIFIER, 0);
}

NeoBasicParser::StatementContext* NeoBasicParser::LabeledStatementContext::statement() {
  return getRuleContext<NeoBasicParser::StatementContext>(0);
}


size_t NeoBasicParser::LabeledStatementContext::getRuleIndex() const {
  return NeoBasicParser::RuleLabeledStatement;
}

void NeoBasicParser::LabeledStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabeledStatement(this);
}

void NeoBasicParser::LabeledStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabeledStatement(this);
}

NeoBasicParser::LabeledStatementContext* NeoBasicParser::labeledStatement() {
  LabeledStatementContext *_localctx = _tracker.createInstance<LabeledStatementContext>(_ctx, getState());
  enterRule(_localctx, 40, NeoBasicParser::RuleLabeledStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(331);
    match(NeoBasicParser::ATOM_IDENTIFIER);
    setState(333);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 8779718459394) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 84)) & 941268883514327041) != 0) || ((((_la - 152) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 152)) & 6434586627) != 0) || ((((_la - 274) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 274)) & 549751619583) != 0)) {
      setState(332);
      statement();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DebugingStatementContext ------------------------------------------------------------------

NeoBasicParser::DebugingStatementContext::DebugingStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::DebugingStatementContext::RUBBERDUCK() {
  return getToken(NeoBasicParser::RUBBERDUCK, 0);
}

NeoBasicParser::StatementContext* NeoBasicParser::DebugingStatementContext::statement() {
  return getRuleContext<NeoBasicParser::StatementContext>(0);
}


size_t NeoBasicParser::DebugingStatementContext::getRuleIndex() const {
  return NeoBasicParser::RuleDebugingStatement;
}

void NeoBasicParser::DebugingStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDebugingStatement(this);
}

void NeoBasicParser::DebugingStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDebugingStatement(this);
}

NeoBasicParser::DebugingStatementContext* NeoBasicParser::debugingStatement() {
  DebugingStatementContext *_localctx = _tracker.createInstance<DebugingStatementContext>(_ctx, getState());
  enterRule(_localctx, 42, NeoBasicParser::RuleDebugingStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(335);
    match(NeoBasicParser::RUBBERDUCK);
    setState(337);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 8779718459394) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 84)) & 941268883514327041) != 0) || ((((_la - 152) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 152)) & 6434586627) != 0) || ((((_la - 274) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 274)) & 549751619583) != 0)) {
      setState(336);
      statement();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoggingStatementContext ------------------------------------------------------------------

NeoBasicParser::LoggingStatementContext::LoggingStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::LoggingStatementContext::TRACERBIRD() {
  return getToken(NeoBasicParser::TRACERBIRD, 0);
}

NeoBasicParser::StatementContext* NeoBasicParser::LoggingStatementContext::statement() {
  return getRuleContext<NeoBasicParser::StatementContext>(0);
}


size_t NeoBasicParser::LoggingStatementContext::getRuleIndex() const {
  return NeoBasicParser::RuleLoggingStatement;
}

void NeoBasicParser::LoggingStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoggingStatement(this);
}

void NeoBasicParser::LoggingStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoggingStatement(this);
}

NeoBasicParser::LoggingStatementContext* NeoBasicParser::loggingStatement() {
  LoggingStatementContext *_localctx = _tracker.createInstance<LoggingStatementContext>(_ctx, getState());
  enterRule(_localctx, 44, NeoBasicParser::RuleLoggingStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(339);
    match(NeoBasicParser::TRACERBIRD);
    setState(341);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 8779718459394) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 84)) & 941268883514327041) != 0) || ((((_la - 152) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 152)) & 6434586627) != 0) || ((((_la - 274) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 274)) & 549751619583) != 0)) {
      setState(340);
      statement();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SExpressionStatementContext ------------------------------------------------------------------

NeoBasicParser::SExpressionStatementContext::SExpressionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::SExpressionStatementContext::LEFT_PARENTHESIS() {
  return getToken(NeoBasicParser::LEFT_PARENTHESIS, 0);
}

NeoBasicParser::StatementContext* NeoBasicParser::SExpressionStatementContext::statement() {
  return getRuleContext<NeoBasicParser::StatementContext>(0);
}

tree::TerminalNode* NeoBasicParser::SExpressionStatementContext::RIGHT_PARENTHESIS() {
  return getToken(NeoBasicParser::RIGHT_PARENTHESIS, 0);
}


size_t NeoBasicParser::SExpressionStatementContext::getRuleIndex() const {
  return NeoBasicParser::RuleSExpressionStatement;
}

void NeoBasicParser::SExpressionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSExpressionStatement(this);
}

void NeoBasicParser::SExpressionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSExpressionStatement(this);
}

NeoBasicParser::SExpressionStatementContext* NeoBasicParser::sExpressionStatement() {
  SExpressionStatementContext *_localctx = _tracker.createInstance<SExpressionStatementContext>(_ctx, getState());
  enterRule(_localctx, 46, NeoBasicParser::RuleSExpressionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(343);
    match(NeoBasicParser::LEFT_PARENTHESIS);
    setState(344);
    statement();
    setState(345);
    match(NeoBasicParser::RIGHT_PARENTHESIS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleStatementContext ------------------------------------------------------------------

NeoBasicParser::SimpleStatementContext::SimpleStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::EmptyStatementContext* NeoBasicParser::SimpleStatementContext::emptyStatement() {
  return getRuleContext<NeoBasicParser::EmptyStatementContext>(0);
}

NeoBasicParser::ExpressionStatementContext* NeoBasicParser::SimpleStatementContext::expressionStatement() {
  return getRuleContext<NeoBasicParser::ExpressionStatementContext>(0);
}

NeoBasicParser::AssignmentStatementContext* NeoBasicParser::SimpleStatementContext::assignmentStatement() {
  return getRuleContext<NeoBasicParser::AssignmentStatementContext>(0);
}


size_t NeoBasicParser::SimpleStatementContext::getRuleIndex() const {
  return NeoBasicParser::RuleSimpleStatement;
}

void NeoBasicParser::SimpleStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleStatement(this);
}

void NeoBasicParser::SimpleStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleStatement(this);
}

NeoBasicParser::SimpleStatementContext* NeoBasicParser::simpleStatement() {
  SimpleStatementContext *_localctx = _tracker.createInstance<SimpleStatementContext>(_ctx, getState());
  enterRule(_localctx, 48, NeoBasicParser::RuleSimpleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(350);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(347);
      emptyStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(348);
      expressionStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(349);
      assignmentStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EmptyStatementContext ------------------------------------------------------------------

NeoBasicParser::EmptyStatementContext::EmptyStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::EmptyStatementContext::ELLIPSIS() {
  return getToken(NeoBasicParser::ELLIPSIS, 0);
}


size_t NeoBasicParser::EmptyStatementContext::getRuleIndex() const {
  return NeoBasicParser::RuleEmptyStatement;
}

void NeoBasicParser::EmptyStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEmptyStatement(this);
}

void NeoBasicParser::EmptyStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEmptyStatement(this);
}

NeoBasicParser::EmptyStatementContext* NeoBasicParser::emptyStatement() {
  EmptyStatementContext *_localctx = _tracker.createInstance<EmptyStatementContext>(_ctx, getState());
  enterRule(_localctx, 50, NeoBasicParser::RuleEmptyStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(352);
    match(NeoBasicParser::ELLIPSIS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionStatementContext ------------------------------------------------------------------

NeoBasicParser::ExpressionStatementContext::ExpressionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::ExpressionsContext* NeoBasicParser::ExpressionStatementContext::expressions() {
  return getRuleContext<NeoBasicParser::ExpressionsContext>(0);
}


size_t NeoBasicParser::ExpressionStatementContext::getRuleIndex() const {
  return NeoBasicParser::RuleExpressionStatement;
}

void NeoBasicParser::ExpressionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionStatement(this);
}

void NeoBasicParser::ExpressionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionStatement(this);
}

NeoBasicParser::ExpressionStatementContext* NeoBasicParser::expressionStatement() {
  ExpressionStatementContext *_localctx = _tracker.createInstance<ExpressionStatementContext>(_ctx, getState());
  enterRule(_localctx, 52, NeoBasicParser::RuleExpressionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(354);
    expressions();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentStatementContext ------------------------------------------------------------------

NeoBasicParser::AssignmentStatementContext::AssignmentStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::PrimaryExpressionsContext* NeoBasicParser::AssignmentStatementContext::primaryExpressions() {
  return getRuleContext<NeoBasicParser::PrimaryExpressionsContext>(0);
}

NeoBasicParser::AssignmentOperatorContext* NeoBasicParser::AssignmentStatementContext::assignmentOperator() {
  return getRuleContext<NeoBasicParser::AssignmentOperatorContext>(0);
}

NeoBasicParser::ExpressionsContext* NeoBasicParser::AssignmentStatementContext::expressions() {
  return getRuleContext<NeoBasicParser::ExpressionsContext>(0);
}


size_t NeoBasicParser::AssignmentStatementContext::getRuleIndex() const {
  return NeoBasicParser::RuleAssignmentStatement;
}

void NeoBasicParser::AssignmentStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentStatement(this);
}

void NeoBasicParser::AssignmentStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentStatement(this);
}

NeoBasicParser::AssignmentStatementContext* NeoBasicParser::assignmentStatement() {
  AssignmentStatementContext *_localctx = _tracker.createInstance<AssignmentStatementContext>(_ctx, getState());
  enterRule(_localctx, 54, NeoBasicParser::RuleAssignmentStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(356);
    primaryExpressions();
    setState(357);
    assignmentOperator();
    setState(358);
    expressions();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompoundStatementContext ------------------------------------------------------------------

NeoBasicParser::CompoundStatementContext::CompoundStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::ConditionalStatementContext* NeoBasicParser::CompoundStatementContext::conditionalStatement() {
  return getRuleContext<NeoBasicParser::ConditionalStatementContext>(0);
}


size_t NeoBasicParser::CompoundStatementContext::getRuleIndex() const {
  return NeoBasicParser::RuleCompoundStatement;
}

void NeoBasicParser::CompoundStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompoundStatement(this);
}

void NeoBasicParser::CompoundStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompoundStatement(this);
}

NeoBasicParser::CompoundStatementContext* NeoBasicParser::compoundStatement() {
  CompoundStatementContext *_localctx = _tracker.createInstance<CompoundStatementContext>(_ctx, getState());
  enterRule(_localctx, 56, NeoBasicParser::RuleCompoundStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(360);
    conditionalStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConditionalStatementContext ------------------------------------------------------------------

NeoBasicParser::ConditionalStatementContext::ConditionalStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::IfStatementContext* NeoBasicParser::ConditionalStatementContext::ifStatement() {
  return getRuleContext<NeoBasicParser::IfStatementContext>(0);
}

NeoBasicParser::UnlessStatementContext* NeoBasicParser::ConditionalStatementContext::unlessStatement() {
  return getRuleContext<NeoBasicParser::UnlessStatementContext>(0);
}


size_t NeoBasicParser::ConditionalStatementContext::getRuleIndex() const {
  return NeoBasicParser::RuleConditionalStatement;
}

void NeoBasicParser::ConditionalStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditionalStatement(this);
}

void NeoBasicParser::ConditionalStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditionalStatement(this);
}

NeoBasicParser::ConditionalStatementContext* NeoBasicParser::conditionalStatement() {
  ConditionalStatementContext *_localctx = _tracker.createInstance<ConditionalStatementContext>(_ctx, getState());
  enterRule(_localctx, 58, NeoBasicParser::RuleConditionalStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(364);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::IF: {
        enterOuterAlt(_localctx, 1);
        setState(362);
        ifStatement();
        break;
      }

      case NeoBasicParser::LEFT_PARENTHESIS:
      case NeoBasicParser::CARET:
      case NeoBasicParser::PIPE:
      case NeoBasicParser::POSITIVE:
      case NeoBasicParser::NEGATIVE:
      case NeoBasicParser::INCREMENT:
      case NeoBasicParser::DECREMENT:
      case NeoBasicParser::BIT_NOT:
      case NeoBasicParser::BIT_NEGATION:
      case NeoBasicParser::SQUARE_POWER:
      case NeoBasicParser::SQUARE_ROOT:
      case NeoBasicParser::FACTORIAL:
      case NeoBasicParser::LOGICAL_NOT:
      case NeoBasicParser::ELLIPSIS:
      case NeoBasicParser::NUMBER_LIT:
      case NeoBasicParser::TIME_LIT:
      case NeoBasicParser::SEQUENCE_LIT:
      case NeoBasicParser::HEREDOC_LITERAL:
      case NeoBasicParser::CHAR_LIT:
      case NeoBasicParser::RANGE_LIT:
      case NeoBasicParser::IDENTIFIER:
      case NeoBasicParser::THIS:
      case NeoBasicParser::IOTA:
      case NeoBasicParser::ALL:
      case NeoBasicParser::ANY:
      case NeoBasicParser::ONE:
      case NeoBasicParser::TWO:
      case NeoBasicParser::NIL:
      case NeoBasicParser::TYPEOF:
      case NeoBasicParser::SIZEOF:
      case NeoBasicParser::TRUE:
      case NeoBasicParser::FALSE:
      case NeoBasicParser::NONZERO:
      case NeoBasicParser::ZERO:
      case NeoBasicParser::MINVALUE:
      case NeoBasicParser::MAXVALUE:
      case NeoBasicParser::NAN:
      case NeoBasicParser::POSITIVEINFINITY:
      case NeoBasicParser::NEGATIVEINFINITY:
      case NeoBasicParser::LOCALDATE:
      case NeoBasicParser::LOCALDATETIME:
      case NeoBasicParser::OFFSETDATE:
      case NeoBasicParser::OFFSETDATETIME:
      case NeoBasicParser::ZONEDDATE:
      case NeoBasicParser::ZONEDDATETIME:
      case NeoBasicParser::TOMORROW:
      case NeoBasicParser::TODAY:
      case NeoBasicParser::NOW:
      case NeoBasicParser::YESTERDAY:
      case NeoBasicParser::EON:
      case NeoBasicParser::EPOCH:
      case NeoBasicParser::LETTER:
      case NeoBasicParser::DIGIT:
      case NeoBasicParser::PUNCTUATION:
      case NeoBasicParser::SYMBOL:
      case NeoBasicParser::SEPARATOR:
      case NeoBasicParser::NONPRINTABLE:
      case NeoBasicParser::NULL_:
      case NeoBasicParser::BLANK:
      case NeoBasicParser::NONBLANK:
      case NeoBasicParser::OKAY:
      case NeoBasicParser::FAIL:
      case NeoBasicParser::SOME:
      case NeoBasicParser::NONE:
      case NeoBasicParser::YEA:
      case NeoBasicParser::NAY:
      case NeoBasicParser::DATA:
      case NeoBasicParser::EOT: {
        enterOuterAlt(_localctx, 2);
        setState(363);
        unlessStatement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfStatementContext ------------------------------------------------------------------

NeoBasicParser::IfStatementContext::IfStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::IfThenClauseContext* NeoBasicParser::IfStatementContext::ifThenClause() {
  return getRuleContext<NeoBasicParser::IfThenClauseContext>(0);
}


size_t NeoBasicParser::IfStatementContext::getRuleIndex() const {
  return NeoBasicParser::RuleIfStatement;
}

void NeoBasicParser::IfStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfStatement(this);
}

void NeoBasicParser::IfStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfStatement(this);
}

NeoBasicParser::IfStatementContext* NeoBasicParser::ifStatement() {
  IfStatementContext *_localctx = _tracker.createInstance<IfStatementContext>(_ctx, getState());
  enterRule(_localctx, 60, NeoBasicParser::RuleIfStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(366);
    ifThenClause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfThenClauseContext ------------------------------------------------------------------

NeoBasicParser::IfThenClauseContext::IfThenClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::IfThenClauseContext::IF() {
  return getToken(NeoBasicParser::IF, 0);
}

NeoBasicParser::ExpressionContext* NeoBasicParser::IfThenClauseContext::expression() {
  return getRuleContext<NeoBasicParser::ExpressionContext>(0);
}

tree::TerminalNode* NeoBasicParser::IfThenClauseContext::THEN() {
  return getToken(NeoBasicParser::THEN, 0);
}

NeoBasicParser::SimpleStatementContext* NeoBasicParser::IfThenClauseContext::simpleStatement() {
  return getRuleContext<NeoBasicParser::SimpleStatementContext>(0);
}


size_t NeoBasicParser::IfThenClauseContext::getRuleIndex() const {
  return NeoBasicParser::RuleIfThenClause;
}

void NeoBasicParser::IfThenClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfThenClause(this);
}

void NeoBasicParser::IfThenClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfThenClause(this);
}

NeoBasicParser::IfThenClauseContext* NeoBasicParser::ifThenClause() {
  IfThenClauseContext *_localctx = _tracker.createInstance<IfThenClauseContext>(_ctx, getState());
  enterRule(_localctx, 62, NeoBasicParser::RuleIfThenClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(368);
    match(NeoBasicParser::IF);
    setState(369);
    expression(0);
    setState(370);
    match(NeoBasicParser::THEN);
    setState(371);
    simpleStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnlessStatementContext ------------------------------------------------------------------

NeoBasicParser::UnlessStatementContext::UnlessStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::UnlessClauseContext* NeoBasicParser::UnlessStatementContext::unlessClause() {
  return getRuleContext<NeoBasicParser::UnlessClauseContext>(0);
}


size_t NeoBasicParser::UnlessStatementContext::getRuleIndex() const {
  return NeoBasicParser::RuleUnlessStatement;
}

void NeoBasicParser::UnlessStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnlessStatement(this);
}

void NeoBasicParser::UnlessStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnlessStatement(this);
}

NeoBasicParser::UnlessStatementContext* NeoBasicParser::unlessStatement() {
  UnlessStatementContext *_localctx = _tracker.createInstance<UnlessStatementContext>(_ctx, getState());
  enterRule(_localctx, 64, NeoBasicParser::RuleUnlessStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(373);
    unlessClause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnlessClauseContext ------------------------------------------------------------------

NeoBasicParser::UnlessClauseContext::UnlessClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::SimpleStatementContext* NeoBasicParser::UnlessClauseContext::simpleStatement() {
  return getRuleContext<NeoBasicParser::SimpleStatementContext>(0);
}

tree::TerminalNode* NeoBasicParser::UnlessClauseContext::UNLESS() {
  return getToken(NeoBasicParser::UNLESS, 0);
}

NeoBasicParser::ExpressionContext* NeoBasicParser::UnlessClauseContext::expression() {
  return getRuleContext<NeoBasicParser::ExpressionContext>(0);
}


size_t NeoBasicParser::UnlessClauseContext::getRuleIndex() const {
  return NeoBasicParser::RuleUnlessClause;
}

void NeoBasicParser::UnlessClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnlessClause(this);
}

void NeoBasicParser::UnlessClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnlessClause(this);
}

NeoBasicParser::UnlessClauseContext* NeoBasicParser::unlessClause() {
  UnlessClauseContext *_localctx = _tracker.createInstance<UnlessClauseContext>(_ctx, getState());
  enterRule(_localctx, 66, NeoBasicParser::RuleUnlessClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(375);
    simpleStatement();
    setState(376);
    match(NeoBasicParser::UNLESS);
    setState(377);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrefixUnaryOperatorContext ------------------------------------------------------------------

NeoBasicParser::PrefixUnaryOperatorContext::PrefixUnaryOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::UnaryArithmeticOperatorContext* NeoBasicParser::PrefixUnaryOperatorContext::unaryArithmeticOperator() {
  return getRuleContext<NeoBasicParser::UnaryArithmeticOperatorContext>(0);
}

NeoBasicParser::UnaryBitwiseOperatorContext* NeoBasicParser::PrefixUnaryOperatorContext::unaryBitwiseOperator() {
  return getRuleContext<NeoBasicParser::UnaryBitwiseOperatorContext>(0);
}

NeoBasicParser::UnaryLogicalOperatorContext* NeoBasicParser::PrefixUnaryOperatorContext::unaryLogicalOperator() {
  return getRuleContext<NeoBasicParser::UnaryLogicalOperatorContext>(0);
}

NeoBasicParser::UnarySpreadOperatorContext* NeoBasicParser::PrefixUnaryOperatorContext::unarySpreadOperator() {
  return getRuleContext<NeoBasicParser::UnarySpreadOperatorContext>(0);
}

NeoBasicParser::UnarySortOperatorContext* NeoBasicParser::PrefixUnaryOperatorContext::unarySortOperator() {
  return getRuleContext<NeoBasicParser::UnarySortOperatorContext>(0);
}

NeoBasicParser::UnaryMetaOperatorContext* NeoBasicParser::PrefixUnaryOperatorContext::unaryMetaOperator() {
  return getRuleContext<NeoBasicParser::UnaryMetaOperatorContext>(0);
}


size_t NeoBasicParser::PrefixUnaryOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RulePrefixUnaryOperator;
}

void NeoBasicParser::PrefixUnaryOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrefixUnaryOperator(this);
}

void NeoBasicParser::PrefixUnaryOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrefixUnaryOperator(this);
}

NeoBasicParser::PrefixUnaryOperatorContext* NeoBasicParser::prefixUnaryOperator() {
  PrefixUnaryOperatorContext *_localctx = _tracker.createInstance<PrefixUnaryOperatorContext>(_ctx, getState());
  enterRule(_localctx, 68, NeoBasicParser::RulePrefixUnaryOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(385);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::POSITIVE:
      case NeoBasicParser::NEGATIVE:
      case NeoBasicParser::INCREMENT:
      case NeoBasicParser::DECREMENT:
      case NeoBasicParser::SQUARE_POWER:
      case NeoBasicParser::SQUARE_ROOT:
      case NeoBasicParser::FACTORIAL: {
        enterOuterAlt(_localctx, 1);
        setState(379);
        unaryArithmeticOperator();
        break;
      }

      case NeoBasicParser::BIT_NOT:
      case NeoBasicParser::BIT_NEGATION: {
        enterOuterAlt(_localctx, 2);
        setState(380);
        unaryBitwiseOperator();
        break;
      }

      case NeoBasicParser::LOGICAL_NOT: {
        enterOuterAlt(_localctx, 3);
        setState(381);
        unaryLogicalOperator();
        break;
      }

      case NeoBasicParser::ELLIPSIS: {
        enterOuterAlt(_localctx, 4);
        setState(382);
        unarySpreadOperator();
        break;
      }

      case NeoBasicParser::CARET: {
        enterOuterAlt(_localctx, 5);
        setState(383);
        unarySortOperator();
        break;
      }

      case NeoBasicParser::TYPEOF:
      case NeoBasicParser::SIZEOF: {
        enterOuterAlt(_localctx, 6);
        setState(384);
        unaryMetaOperator();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PosfixUnaryOperatorContext ------------------------------------------------------------------

NeoBasicParser::PosfixUnaryOperatorContext::PosfixUnaryOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::UnarySortOperatorContext* NeoBasicParser::PosfixUnaryOperatorContext::unarySortOperator() {
  return getRuleContext<NeoBasicParser::UnarySortOperatorContext>(0);
}

NeoBasicParser::UnaryCloneOperatorContext* NeoBasicParser::PosfixUnaryOperatorContext::unaryCloneOperator() {
  return getRuleContext<NeoBasicParser::UnaryCloneOperatorContext>(0);
}


size_t NeoBasicParser::PosfixUnaryOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RulePosfixUnaryOperator;
}

void NeoBasicParser::PosfixUnaryOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPosfixUnaryOperator(this);
}

void NeoBasicParser::PosfixUnaryOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPosfixUnaryOperator(this);
}

NeoBasicParser::PosfixUnaryOperatorContext* NeoBasicParser::posfixUnaryOperator() {
  PosfixUnaryOperatorContext *_localctx = _tracker.createInstance<PosfixUnaryOperatorContext>(_ctx, getState());
  enterRule(_localctx, 70, NeoBasicParser::RulePosfixUnaryOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(389);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::CARET: {
        enterOuterAlt(_localctx, 1);
        setState(387);
        unarySortOperator();
        break;
      }

      case NeoBasicParser::EQUAL: {
        enterOuterAlt(_localctx, 2);
        setState(388);
        unaryCloneOperator();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnaryArithmeticOperatorContext ------------------------------------------------------------------

NeoBasicParser::UnaryArithmeticOperatorContext::UnaryArithmeticOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::UnaryArithmeticOperatorContext::POSITIVE() {
  return getToken(NeoBasicParser::POSITIVE, 0);
}

tree::TerminalNode* NeoBasicParser::UnaryArithmeticOperatorContext::NEGATIVE() {
  return getToken(NeoBasicParser::NEGATIVE, 0);
}

tree::TerminalNode* NeoBasicParser::UnaryArithmeticOperatorContext::INCREMENT() {
  return getToken(NeoBasicParser::INCREMENT, 0);
}

tree::TerminalNode* NeoBasicParser::UnaryArithmeticOperatorContext::DECREMENT() {
  return getToken(NeoBasicParser::DECREMENT, 0);
}

tree::TerminalNode* NeoBasicParser::UnaryArithmeticOperatorContext::SQUARE_POWER() {
  return getToken(NeoBasicParser::SQUARE_POWER, 0);
}

tree::TerminalNode* NeoBasicParser::UnaryArithmeticOperatorContext::SQUARE_ROOT() {
  return getToken(NeoBasicParser::SQUARE_ROOT, 0);
}

tree::TerminalNode* NeoBasicParser::UnaryArithmeticOperatorContext::FACTORIAL() {
  return getToken(NeoBasicParser::FACTORIAL, 0);
}


size_t NeoBasicParser::UnaryArithmeticOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleUnaryArithmeticOperator;
}

void NeoBasicParser::UnaryArithmeticOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryArithmeticOperator(this);
}

void NeoBasicParser::UnaryArithmeticOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryArithmeticOperator(this);
}

NeoBasicParser::UnaryArithmeticOperatorContext* NeoBasicParser::unaryArithmeticOperator() {
  UnaryArithmeticOperatorContext *_localctx = _tracker.createInstance<UnaryArithmeticOperatorContext>(_ctx, getState());
  enterRule(_localctx, 72, NeoBasicParser::RuleUnaryArithmeticOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(391);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 7954279432192) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnaryBitwiseOperatorContext ------------------------------------------------------------------

NeoBasicParser::UnaryBitwiseOperatorContext::UnaryBitwiseOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::UnaryBitwiseOperatorContext::BIT_NOT() {
  return getToken(NeoBasicParser::BIT_NOT, 0);
}

tree::TerminalNode* NeoBasicParser::UnaryBitwiseOperatorContext::BIT_NEGATION() {
  return getToken(NeoBasicParser::BIT_NEGATION, 0);
}


size_t NeoBasicParser::UnaryBitwiseOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleUnaryBitwiseOperator;
}

void NeoBasicParser::UnaryBitwiseOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryBitwiseOperator(this);
}

void NeoBasicParser::UnaryBitwiseOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryBitwiseOperator(this);
}

NeoBasicParser::UnaryBitwiseOperatorContext* NeoBasicParser::unaryBitwiseOperator() {
  UnaryBitwiseOperatorContext *_localctx = _tracker.createInstance<UnaryBitwiseOperatorContext>(_ctx, getState());
  enterRule(_localctx, 74, NeoBasicParser::RuleUnaryBitwiseOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(393);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::BIT_NOT

    || _la == NeoBasicParser::BIT_NEGATION)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnaryLogicalOperatorContext ------------------------------------------------------------------

NeoBasicParser::UnaryLogicalOperatorContext::UnaryLogicalOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::UnaryLogicalOperatorContext::LOGICAL_NOT() {
  return getToken(NeoBasicParser::LOGICAL_NOT, 0);
}


size_t NeoBasicParser::UnaryLogicalOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleUnaryLogicalOperator;
}

void NeoBasicParser::UnaryLogicalOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryLogicalOperator(this);
}

void NeoBasicParser::UnaryLogicalOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryLogicalOperator(this);
}

NeoBasicParser::UnaryLogicalOperatorContext* NeoBasicParser::unaryLogicalOperator() {
  UnaryLogicalOperatorContext *_localctx = _tracker.createInstance<UnaryLogicalOperatorContext>(_ctx, getState());
  enterRule(_localctx, 76, NeoBasicParser::RuleUnaryLogicalOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(395);
    match(NeoBasicParser::LOGICAL_NOT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnarySpreadOperatorContext ------------------------------------------------------------------

NeoBasicParser::UnarySpreadOperatorContext::UnarySpreadOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::UnarySpreadOperatorContext::ELLIPSIS() {
  return getToken(NeoBasicParser::ELLIPSIS, 0);
}


size_t NeoBasicParser::UnarySpreadOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleUnarySpreadOperator;
}

void NeoBasicParser::UnarySpreadOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnarySpreadOperator(this);
}

void NeoBasicParser::UnarySpreadOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnarySpreadOperator(this);
}

NeoBasicParser::UnarySpreadOperatorContext* NeoBasicParser::unarySpreadOperator() {
  UnarySpreadOperatorContext *_localctx = _tracker.createInstance<UnarySpreadOperatorContext>(_ctx, getState());
  enterRule(_localctx, 78, NeoBasicParser::RuleUnarySpreadOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(397);
    match(NeoBasicParser::ELLIPSIS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnarySortOperatorContext ------------------------------------------------------------------

NeoBasicParser::UnarySortOperatorContext::UnarySortOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> NeoBasicParser::UnarySortOperatorContext::CARET() {
  return getTokens(NeoBasicParser::CARET);
}

tree::TerminalNode* NeoBasicParser::UnarySortOperatorContext::CARET(size_t i) {
  return getToken(NeoBasicParser::CARET, i);
}


size_t NeoBasicParser::UnarySortOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleUnarySortOperator;
}

void NeoBasicParser::UnarySortOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnarySortOperator(this);
}

void NeoBasicParser::UnarySortOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnarySortOperator(this);
}

NeoBasicParser::UnarySortOperatorContext* NeoBasicParser::unarySortOperator() {
  UnarySortOperatorContext *_localctx = _tracker.createInstance<UnarySortOperatorContext>(_ctx, getState());
  enterRule(_localctx, 80, NeoBasicParser::RuleUnarySortOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(402);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(399);
      match(NeoBasicParser::CARET);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(400);
      match(NeoBasicParser::CARET);
      setState(401);
      match(NeoBasicParser::CARET);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnaryCloneOperatorContext ------------------------------------------------------------------

NeoBasicParser::UnaryCloneOperatorContext::UnaryCloneOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> NeoBasicParser::UnaryCloneOperatorContext::EQUAL() {
  return getTokens(NeoBasicParser::EQUAL);
}

tree::TerminalNode* NeoBasicParser::UnaryCloneOperatorContext::EQUAL(size_t i) {
  return getToken(NeoBasicParser::EQUAL, i);
}


size_t NeoBasicParser::UnaryCloneOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleUnaryCloneOperator;
}

void NeoBasicParser::UnaryCloneOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryCloneOperator(this);
}

void NeoBasicParser::UnaryCloneOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryCloneOperator(this);
}

NeoBasicParser::UnaryCloneOperatorContext* NeoBasicParser::unaryCloneOperator() {
  UnaryCloneOperatorContext *_localctx = _tracker.createInstance<UnaryCloneOperatorContext>(_ctx, getState());
  enterRule(_localctx, 82, NeoBasicParser::RuleUnaryCloneOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(408);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(404);
      match(NeoBasicParser::EQUAL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(405);
      match(NeoBasicParser::EQUAL);
      setState(406);
      match(NeoBasicParser::EQUAL);
      setState(407);
      match(NeoBasicParser::EQUAL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnaryMetaOperatorContext ------------------------------------------------------------------

NeoBasicParser::UnaryMetaOperatorContext::UnaryMetaOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::UnaryMetaOperatorContext::TYPEOF() {
  return getToken(NeoBasicParser::TYPEOF, 0);
}

tree::TerminalNode* NeoBasicParser::UnaryMetaOperatorContext::SIZEOF() {
  return getToken(NeoBasicParser::SIZEOF, 0);
}


size_t NeoBasicParser::UnaryMetaOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleUnaryMetaOperator;
}

void NeoBasicParser::UnaryMetaOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryMetaOperator(this);
}

void NeoBasicParser::UnaryMetaOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryMetaOperator(this);
}

NeoBasicParser::UnaryMetaOperatorContext* NeoBasicParser::unaryMetaOperator() {
  UnaryMetaOperatorContext *_localctx = _tracker.createInstance<UnaryMetaOperatorContext>(_ctx, getState());
  enterRule(_localctx, 84, NeoBasicParser::RuleUnaryMetaOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(410);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::TYPEOF

    || _la == NeoBasicParser::SIZEOF)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryExponentialOperatorContext ------------------------------------------------------------------

NeoBasicParser::BinaryExponentialOperatorContext::BinaryExponentialOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BinaryExponentialOperatorContext::NTH_POWER() {
  return getToken(NeoBasicParser::NTH_POWER, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryExponentialOperatorContext::NTH_ROOT() {
  return getToken(NeoBasicParser::NTH_ROOT, 0);
}


size_t NeoBasicParser::BinaryExponentialOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBinaryExponentialOperator;
}

void NeoBasicParser::BinaryExponentialOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryExponentialOperator(this);
}

void NeoBasicParser::BinaryExponentialOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryExponentialOperator(this);
}

NeoBasicParser::BinaryExponentialOperatorContext* NeoBasicParser::binaryExponentialOperator() {
  BinaryExponentialOperatorContext *_localctx = _tracker.createInstance<BinaryExponentialOperatorContext>(_ctx, getState());
  enterRule(_localctx, 86, NeoBasicParser::RuleBinaryExponentialOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(412);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::NTH_POWER

    || _la == NeoBasicParser::NTH_ROOT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryMultiplicativeOperatorContext ------------------------------------------------------------------

NeoBasicParser::BinaryMultiplicativeOperatorContext::BinaryMultiplicativeOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BinaryMultiplicativeOperatorContext::MULTIPLICATION() {
  return getToken(NeoBasicParser::MULTIPLICATION, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryMultiplicativeOperatorContext::REAL_DIVISION() {
  return getToken(NeoBasicParser::REAL_DIVISION, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryMultiplicativeOperatorContext::INTEGER_DIVISION() {
  return getToken(NeoBasicParser::INTEGER_DIVISION, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryMultiplicativeOperatorContext::MODULO() {
  return getToken(NeoBasicParser::MODULO, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryMultiplicativeOperatorContext::PERCENTAGE_RATE() {
  return getToken(NeoBasicParser::PERCENTAGE_RATE, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryMultiplicativeOperatorContext::PERCENTAGE_AMOUNT() {
  return getToken(NeoBasicParser::PERCENTAGE_AMOUNT, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryMultiplicativeOperatorContext::PERCENTAGE_INCREASE() {
  return getToken(NeoBasicParser::PERCENTAGE_INCREASE, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryMultiplicativeOperatorContext::PERCENTAGE_DECREASE() {
  return getToken(NeoBasicParser::PERCENTAGE_DECREASE, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryMultiplicativeOperatorContext::PERCENTAGE_VARIATION() {
  return getToken(NeoBasicParser::PERCENTAGE_VARIATION, 0);
}


size_t NeoBasicParser::BinaryMultiplicativeOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBinaryMultiplicativeOperator;
}

void NeoBasicParser::BinaryMultiplicativeOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryMultiplicativeOperator(this);
}

void NeoBasicParser::BinaryMultiplicativeOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryMultiplicativeOperator(this);
}

NeoBasicParser::BinaryMultiplicativeOperatorContext* NeoBasicParser::binaryMultiplicativeOperator() {
  BinaryMultiplicativeOperatorContext *_localctx = _tracker.createInstance<BinaryMultiplicativeOperatorContext>(_ctx, getState());
  enterRule(_localctx, 88, NeoBasicParser::RuleBinaryMultiplicativeOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(414);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 70333559805575168) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryAdditiveOperatorContext ------------------------------------------------------------------

NeoBasicParser::BinaryAdditiveOperatorContext::BinaryAdditiveOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BinaryAdditiveOperatorContext::ADDITION() {
  return getToken(NeoBasicParser::ADDITION, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryAdditiveOperatorContext::SUBTRACTION() {
  return getToken(NeoBasicParser::SUBTRACTION, 0);
}


size_t NeoBasicParser::BinaryAdditiveOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBinaryAdditiveOperator;
}

void NeoBasicParser::BinaryAdditiveOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryAdditiveOperator(this);
}

void NeoBasicParser::BinaryAdditiveOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryAdditiveOperator(this);
}

NeoBasicParser::BinaryAdditiveOperatorContext* NeoBasicParser::binaryAdditiveOperator() {
  BinaryAdditiveOperatorContext *_localctx = _tracker.createInstance<BinaryAdditiveOperatorContext>(_ctx, getState());
  enterRule(_localctx, 90, NeoBasicParser::RuleBinaryAdditiveOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(416);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::ADDITION

    || _la == NeoBasicParser::SUBTRACTION)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitShiftOperatorContext ------------------------------------------------------------------

NeoBasicParser::BitShiftOperatorContext::BitShiftOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BitShiftOperatorContext::LEFT_SHIFT() {
  return getToken(NeoBasicParser::LEFT_SHIFT, 0);
}

tree::TerminalNode* NeoBasicParser::BitShiftOperatorContext::SIGNED_RIGHT_SHIFT() {
  return getToken(NeoBasicParser::SIGNED_RIGHT_SHIFT, 0);
}

tree::TerminalNode* NeoBasicParser::BitShiftOperatorContext::UNSIGNED_RIGHT_SHIFT() {
  return getToken(NeoBasicParser::UNSIGNED_RIGHT_SHIFT, 0);
}


size_t NeoBasicParser::BitShiftOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBitShiftOperator;
}

void NeoBasicParser::BitShiftOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitShiftOperator(this);
}

void NeoBasicParser::BitShiftOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitShiftOperator(this);
}

NeoBasicParser::BitShiftOperatorContext* NeoBasicParser::bitShiftOperator() {
  BitShiftOperatorContext *_localctx = _tracker.createInstance<BitShiftOperatorContext>(_ctx, getState());
  enterRule(_localctx, 92, NeoBasicParser::RuleBitShiftOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(418);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 8070450532247928832) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitConjunctionOperatorContext ------------------------------------------------------------------

NeoBasicParser::BitConjunctionOperatorContext::BitConjunctionOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BitConjunctionOperatorContext::BIT_AND() {
  return getToken(NeoBasicParser::BIT_AND, 0);
}

tree::TerminalNode* NeoBasicParser::BitConjunctionOperatorContext::BIT_CLEAR() {
  return getToken(NeoBasicParser::BIT_CLEAR, 0);
}


size_t NeoBasicParser::BitConjunctionOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBitConjunctionOperator;
}

void NeoBasicParser::BitConjunctionOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitConjunctionOperator(this);
}

void NeoBasicParser::BitConjunctionOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitConjunctionOperator(this);
}

NeoBasicParser::BitConjunctionOperatorContext* NeoBasicParser::bitConjunctionOperator() {
  BitConjunctionOperatorContext *_localctx = _tracker.createInstance<BitConjunctionOperatorContext>(_ctx, getState());
  enterRule(_localctx, 94, NeoBasicParser::RuleBitConjunctionOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(420);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::BIT_AND

    || _la == NeoBasicParser::BIT_CLEAR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitExclusiveDisjunctionOperatorContext ------------------------------------------------------------------

NeoBasicParser::BitExclusiveDisjunctionOperatorContext::BitExclusiveDisjunctionOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BitExclusiveDisjunctionOperatorContext::BIT_XOR() {
  return getToken(NeoBasicParser::BIT_XOR, 0);
}


size_t NeoBasicParser::BitExclusiveDisjunctionOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBitExclusiveDisjunctionOperator;
}

void NeoBasicParser::BitExclusiveDisjunctionOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitExclusiveDisjunctionOperator(this);
}

void NeoBasicParser::BitExclusiveDisjunctionOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitExclusiveDisjunctionOperator(this);
}

NeoBasicParser::BitExclusiveDisjunctionOperatorContext* NeoBasicParser::bitExclusiveDisjunctionOperator() {
  BitExclusiveDisjunctionOperatorContext *_localctx = _tracker.createInstance<BitExclusiveDisjunctionOperatorContext>(_ctx, getState());
  enterRule(_localctx, 96, NeoBasicParser::RuleBitExclusiveDisjunctionOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(422);
    match(NeoBasicParser::BIT_XOR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitDisjunctionOperatorContext ------------------------------------------------------------------

NeoBasicParser::BitDisjunctionOperatorContext::BitDisjunctionOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BitDisjunctionOperatorContext::BIT_OR() {
  return getToken(NeoBasicParser::BIT_OR, 0);
}


size_t NeoBasicParser::BitDisjunctionOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBitDisjunctionOperator;
}

void NeoBasicParser::BitDisjunctionOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitDisjunctionOperator(this);
}

void NeoBasicParser::BitDisjunctionOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitDisjunctionOperator(this);
}

NeoBasicParser::BitDisjunctionOperatorContext* NeoBasicParser::bitDisjunctionOperator() {
  BitDisjunctionOperatorContext *_localctx = _tracker.createInstance<BitDisjunctionOperatorContext>(_ctx, getState());
  enterRule(_localctx, 98, NeoBasicParser::RuleBitDisjunctionOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(424);
    match(NeoBasicParser::BIT_OR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryComparisonOperatorContext ------------------------------------------------------------------

NeoBasicParser::BinaryComparisonOperatorContext::BinaryComparisonOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BinaryComparisonOperatorContext::ELVIS_TEST() {
  return getToken(NeoBasicParser::ELVIS_TEST, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryComparisonOperatorContext::THREE_WAY_TEST() {
  return getToken(NeoBasicParser::THREE_WAY_TEST, 0);
}


size_t NeoBasicParser::BinaryComparisonOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBinaryComparisonOperator;
}

void NeoBasicParser::BinaryComparisonOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryComparisonOperator(this);
}

void NeoBasicParser::BinaryComparisonOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryComparisonOperator(this);
}

NeoBasicParser::BinaryComparisonOperatorContext* NeoBasicParser::binaryComparisonOperator() {
  BinaryComparisonOperatorContext *_localctx = _tracker.createInstance<BinaryComparisonOperatorContext>(_ctx, getState());
  enterRule(_localctx, 100, NeoBasicParser::RuleBinaryComparisonOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(426);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::ELVIS_TEST

    || _la == NeoBasicParser::THREE_WAY_TEST)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryRelationalOperatorContext ------------------------------------------------------------------

NeoBasicParser::BinaryRelationalOperatorContext::BinaryRelationalOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BinaryRelationalOperatorContext::EQUALS() {
  return getToken(NeoBasicParser::EQUALS, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryRelationalOperatorContext::NOT_EQUALS() {
  return getToken(NeoBasicParser::NOT_EQUALS, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryRelationalOperatorContext::LESS() {
  return getToken(NeoBasicParser::LESS, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryRelationalOperatorContext::LESS_OR_EQUALS() {
  return getToken(NeoBasicParser::LESS_OR_EQUALS, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryRelationalOperatorContext::GREATER() {
  return getToken(NeoBasicParser::GREATER, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryRelationalOperatorContext::GREATER_OR_EQUALS() {
  return getToken(NeoBasicParser::GREATER_OR_EQUALS, 0);
}


size_t NeoBasicParser::BinaryRelationalOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBinaryRelationalOperator;
}

void NeoBasicParser::BinaryRelationalOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryRelationalOperator(this);
}

void NeoBasicParser::BinaryRelationalOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryRelationalOperator(this);
}

NeoBasicParser::BinaryRelationalOperatorContext* NeoBasicParser::binaryRelationalOperator() {
  BinaryRelationalOperatorContext *_localctx = _tracker.createInstance<BinaryRelationalOperatorContext>(_ctx, getState());
  enterRule(_localctx, 102, NeoBasicParser::RuleBinaryRelationalOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(428);
    _la = _input->LA(1);
    if (!(((((_la - 75) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 75)) & 63) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryConditionalOperatorContext ------------------------------------------------------------------

NeoBasicParser::BinaryConditionalOperatorContext::BinaryConditionalOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BinaryConditionalOperatorContext::IDENTITY() {
  return getToken(NeoBasicParser::IDENTITY, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryConditionalOperatorContext::NOT_IDENTITY() {
  return getToken(NeoBasicParser::NOT_IDENTITY, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryConditionalOperatorContext::MEMBERSHIP() {
  return getToken(NeoBasicParser::MEMBERSHIP, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryConditionalOperatorContext::NOT_MEMBERSHIP() {
  return getToken(NeoBasicParser::NOT_MEMBERSHIP, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryConditionalOperatorContext::BETWEEN_RANGE() {
  return getToken(NeoBasicParser::BETWEEN_RANGE, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryConditionalOperatorContext::NOT_BETWEEN_RANGE() {
  return getToken(NeoBasicParser::NOT_BETWEEN_RANGE, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryConditionalOperatorContext::MATCHING() {
  return getToken(NeoBasicParser::MATCHING, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryConditionalOperatorContext::NOT_MATCHING() {
  return getToken(NeoBasicParser::NOT_MATCHING, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryConditionalOperatorContext::DIVISIBLE_BY() {
  return getToken(NeoBasicParser::DIVISIBLE_BY, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryConditionalOperatorContext::NOT_DIVISIBLE_BY() {
  return getToken(NeoBasicParser::NOT_DIVISIBLE_BY, 0);
}


size_t NeoBasicParser::BinaryConditionalOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBinaryConditionalOperator;
}

void NeoBasicParser::BinaryConditionalOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryConditionalOperator(this);
}

void NeoBasicParser::BinaryConditionalOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryConditionalOperator(this);
}

NeoBasicParser::BinaryConditionalOperatorContext* NeoBasicParser::binaryConditionalOperator() {
  BinaryConditionalOperatorContext *_localctx = _tracker.createInstance<BinaryConditionalOperatorContext>(_ctx, getState());
  enterRule(_localctx, 104, NeoBasicParser::RuleBinaryConditionalOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(430);
    _la = _input->LA(1);
    if (!(((((_la - 63) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 63)) & 1023) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryConjunctionOperatorContext ------------------------------------------------------------------

NeoBasicParser::BinaryConjunctionOperatorContext::BinaryConjunctionOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BinaryConjunctionOperatorContext::LOGICAL_AND() {
  return getToken(NeoBasicParser::LOGICAL_AND, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryConjunctionOperatorContext::LOGICAL_NAND() {
  return getToken(NeoBasicParser::LOGICAL_NAND, 0);
}


size_t NeoBasicParser::BinaryConjunctionOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBinaryConjunctionOperator;
}

void NeoBasicParser::BinaryConjunctionOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryConjunctionOperator(this);
}

void NeoBasicParser::BinaryConjunctionOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryConjunctionOperator(this);
}

NeoBasicParser::BinaryConjunctionOperatorContext* NeoBasicParser::binaryConjunctionOperator() {
  BinaryConjunctionOperatorContext *_localctx = _tracker.createInstance<BinaryConjunctionOperatorContext>(_ctx, getState());
  enterRule(_localctx, 106, NeoBasicParser::RuleBinaryConjunctionOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(432);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::LOGICAL_AND

    || _la == NeoBasicParser::LOGICAL_NAND)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryExclusiveDisjunctionOperatorContext ------------------------------------------------------------------

NeoBasicParser::BinaryExclusiveDisjunctionOperatorContext::BinaryExclusiveDisjunctionOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BinaryExclusiveDisjunctionOperatorContext::LOGICAL_XOR() {
  return getToken(NeoBasicParser::LOGICAL_XOR, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryExclusiveDisjunctionOperatorContext::LOGICAL_NXOR() {
  return getToken(NeoBasicParser::LOGICAL_NXOR, 0);
}


size_t NeoBasicParser::BinaryExclusiveDisjunctionOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBinaryExclusiveDisjunctionOperator;
}

void NeoBasicParser::BinaryExclusiveDisjunctionOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryExclusiveDisjunctionOperator(this);
}

void NeoBasicParser::BinaryExclusiveDisjunctionOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryExclusiveDisjunctionOperator(this);
}

NeoBasicParser::BinaryExclusiveDisjunctionOperatorContext* NeoBasicParser::binaryExclusiveDisjunctionOperator() {
  BinaryExclusiveDisjunctionOperatorContext *_localctx = _tracker.createInstance<BinaryExclusiveDisjunctionOperatorContext>(_ctx, getState());
  enterRule(_localctx, 108, NeoBasicParser::RuleBinaryExclusiveDisjunctionOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(434);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::LOGICAL_XOR

    || _la == NeoBasicParser::LOGICAL_NXOR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryDisjunctionOperatorContext ------------------------------------------------------------------

NeoBasicParser::BinaryDisjunctionOperatorContext::BinaryDisjunctionOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BinaryDisjunctionOperatorContext::LOGICAL_OR() {
  return getToken(NeoBasicParser::LOGICAL_OR, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryDisjunctionOperatorContext::LOGICAL_NOR() {
  return getToken(NeoBasicParser::LOGICAL_NOR, 0);
}


size_t NeoBasicParser::BinaryDisjunctionOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBinaryDisjunctionOperator;
}

void NeoBasicParser::BinaryDisjunctionOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryDisjunctionOperator(this);
}

void NeoBasicParser::BinaryDisjunctionOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryDisjunctionOperator(this);
}

NeoBasicParser::BinaryDisjunctionOperatorContext* NeoBasicParser::binaryDisjunctionOperator() {
  BinaryDisjunctionOperatorContext *_localctx = _tracker.createInstance<BinaryDisjunctionOperatorContext>(_ctx, getState());
  enterRule(_localctx, 110, NeoBasicParser::RuleBinaryDisjunctionOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(436);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::LOGICAL_OR

    || _la == NeoBasicParser::LOGICAL_NOR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryCoalescingOperatorContext ------------------------------------------------------------------

NeoBasicParser::BinaryCoalescingOperatorContext::BinaryCoalescingOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BinaryCoalescingOperatorContext::ERROR_PROPAGATION() {
  return getToken(NeoBasicParser::ERROR_PROPAGATION, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryCoalescingOperatorContext::ERROR_COALESCING() {
  return getToken(NeoBasicParser::ERROR_COALESCING, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryCoalescingOperatorContext::ERROR_PROPAGATION_NONE_COALESCING() {
  return getToken(NeoBasicParser::ERROR_PROPAGATION_NONE_COALESCING, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryCoalescingOperatorContext::ERROR_TO_NONE_CONVERTION() {
  return getToken(NeoBasicParser::ERROR_TO_NONE_CONVERTION, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryCoalescingOperatorContext::EXCEPTION_COALESCING() {
  return getToken(NeoBasicParser::EXCEPTION_COALESCING, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryCoalescingOperatorContext::EXCEPTION_STATEMENT() {
  return getToken(NeoBasicParser::EXCEPTION_STATEMENT, 0);
}


size_t NeoBasicParser::BinaryCoalescingOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBinaryCoalescingOperator;
}

void NeoBasicParser::BinaryCoalescingOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryCoalescingOperator(this);
}

void NeoBasicParser::BinaryCoalescingOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryCoalescingOperator(this);
}

NeoBasicParser::BinaryCoalescingOperatorContext* NeoBasicParser::binaryCoalescingOperator() {
  BinaryCoalescingOperatorContext *_localctx = _tracker.createInstance<BinaryCoalescingOperatorContext>(_ctx, getState());
  enterRule(_localctx, 112, NeoBasicParser::RuleBinaryCoalescingOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(438);
    _la = _input->LA(1);
    if (!(((((_la - 88) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 88)) & 63) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentOperatorContext ------------------------------------------------------------------

NeoBasicParser::AssignmentOperatorContext::AssignmentOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::SingleAssignmentOperatorContext* NeoBasicParser::AssignmentOperatorContext::singleAssignmentOperator() {
  return getRuleContext<NeoBasicParser::SingleAssignmentOperatorContext>(0);
}

NeoBasicParser::CompoundAssignmentOperatorContext* NeoBasicParser::AssignmentOperatorContext::compoundAssignmentOperator() {
  return getRuleContext<NeoBasicParser::CompoundAssignmentOperatorContext>(0);
}


size_t NeoBasicParser::AssignmentOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleAssignmentOperator;
}

void NeoBasicParser::AssignmentOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentOperator(this);
}

void NeoBasicParser::AssignmentOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentOperator(this);
}

NeoBasicParser::AssignmentOperatorContext* NeoBasicParser::assignmentOperator() {
  AssignmentOperatorContext *_localctx = _tracker.createInstance<AssignmentOperatorContext>(_ctx, getState());
  enterRule(_localctx, 114, NeoBasicParser::RuleAssignmentOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(442);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::BASIC_ASSIGNMENT:
      case NeoBasicParser::DESTRUCTURING_ASSIGNMENT:
      case NeoBasicParser::MACRO_ASSIGNMENT: {
        enterOuterAlt(_localctx, 1);
        setState(440);
        singleAssignmentOperator();
        break;
      }

      case NeoBasicParser::ADDITION_ASSIGNMENT:
      case NeoBasicParser::SUBTRACTION_ASSIGNMENT:
      case NeoBasicParser::MULTIPLICATION_ASSIGNMENT:
      case NeoBasicParser::REAL_DIVISION_ASSIGNMENT:
      case NeoBasicParser::INTEGER_DIVISION_ASSIGNMENT:
      case NeoBasicParser::MODULO_ASSIGNMENT:
      case NeoBasicParser::NTH_POWER_ASSIGNMENT:
      case NeoBasicParser::NTH_ROOT_ASSIGNMENT:
      case NeoBasicParser::PERCENTAGE_RATE_ASSIGNMENT:
      case NeoBasicParser::PERCENTAGE_AMOUNT_ASSIGNMENT:
      case NeoBasicParser::PERCENTAGE_INCREASE_ASSIGNMENT:
      case NeoBasicParser::PERCENTAGE_DECREASE_ASSIGNMENT:
      case NeoBasicParser::PERCENTAGE_VARIATION_ASSIGNMENT:
      case NeoBasicParser::BIT_AND_ASSIGNMENT:
      case NeoBasicParser::BIT_OR_ASSIGNMENT:
      case NeoBasicParser::BIT_XOR_ASSIGNMENT:
      case NeoBasicParser::BIT_CLEAR_ASSIGNMENT:
      case NeoBasicParser::BIT_NOT_ASSIGNMENT:
      case NeoBasicParser::LEFT_SHIFT_ASSIGNMENT:
      case NeoBasicParser::SIGNED_RIGHT_SHIFT_ASSIGNMENT:
      case NeoBasicParser::UNSIGNED_RIGHT_SHIFT_ASSIGNMENT:
      case NeoBasicParser::NONE_COALESCING_ASSIGNMENT: {
        enterOuterAlt(_localctx, 2);
        setState(441);
        compoundAssignmentOperator();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SingleAssignmentOperatorContext ------------------------------------------------------------------

NeoBasicParser::SingleAssignmentOperatorContext::SingleAssignmentOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::SingleAssignmentOperatorContext::BASIC_ASSIGNMENT() {
  return getToken(NeoBasicParser::BASIC_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::SingleAssignmentOperatorContext::DESTRUCTURING_ASSIGNMENT() {
  return getToken(NeoBasicParser::DESTRUCTURING_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::SingleAssignmentOperatorContext::MACRO_ASSIGNMENT() {
  return getToken(NeoBasicParser::MACRO_ASSIGNMENT, 0);
}


size_t NeoBasicParser::SingleAssignmentOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleSingleAssignmentOperator;
}

void NeoBasicParser::SingleAssignmentOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingleAssignmentOperator(this);
}

void NeoBasicParser::SingleAssignmentOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingleAssignmentOperator(this);
}

NeoBasicParser::SingleAssignmentOperatorContext* NeoBasicParser::singleAssignmentOperator() {
  SingleAssignmentOperatorContext *_localctx = _tracker.createInstance<SingleAssignmentOperatorContext>(_ctx, getState());
  enterRule(_localctx, 116, NeoBasicParser::RuleSingleAssignmentOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(444);
    _la = _input->LA(1);
    if (!(((((_la - 94) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 94)) & 7) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompoundAssignmentOperatorContext ------------------------------------------------------------------

NeoBasicParser::CompoundAssignmentOperatorContext::CompoundAssignmentOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::ADDITION_ASSIGNMENT() {
  return getToken(NeoBasicParser::ADDITION_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::SUBTRACTION_ASSIGNMENT() {
  return getToken(NeoBasicParser::SUBTRACTION_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::MULTIPLICATION_ASSIGNMENT() {
  return getToken(NeoBasicParser::MULTIPLICATION_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::REAL_DIVISION_ASSIGNMENT() {
  return getToken(NeoBasicParser::REAL_DIVISION_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::INTEGER_DIVISION_ASSIGNMENT() {
  return getToken(NeoBasicParser::INTEGER_DIVISION_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::MODULO_ASSIGNMENT() {
  return getToken(NeoBasicParser::MODULO_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::NTH_POWER_ASSIGNMENT() {
  return getToken(NeoBasicParser::NTH_POWER_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::NTH_ROOT_ASSIGNMENT() {
  return getToken(NeoBasicParser::NTH_ROOT_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::PERCENTAGE_RATE_ASSIGNMENT() {
  return getToken(NeoBasicParser::PERCENTAGE_RATE_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::PERCENTAGE_AMOUNT_ASSIGNMENT() {
  return getToken(NeoBasicParser::PERCENTAGE_AMOUNT_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::PERCENTAGE_INCREASE_ASSIGNMENT() {
  return getToken(NeoBasicParser::PERCENTAGE_INCREASE_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::PERCENTAGE_DECREASE_ASSIGNMENT() {
  return getToken(NeoBasicParser::PERCENTAGE_DECREASE_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::PERCENTAGE_VARIATION_ASSIGNMENT() {
  return getToken(NeoBasicParser::PERCENTAGE_VARIATION_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::BIT_AND_ASSIGNMENT() {
  return getToken(NeoBasicParser::BIT_AND_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::BIT_CLEAR_ASSIGNMENT() {
  return getToken(NeoBasicParser::BIT_CLEAR_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::BIT_XOR_ASSIGNMENT() {
  return getToken(NeoBasicParser::BIT_XOR_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::BIT_OR_ASSIGNMENT() {
  return getToken(NeoBasicParser::BIT_OR_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::BIT_NOT_ASSIGNMENT() {
  return getToken(NeoBasicParser::BIT_NOT_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::LEFT_SHIFT_ASSIGNMENT() {
  return getToken(NeoBasicParser::LEFT_SHIFT_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::SIGNED_RIGHT_SHIFT_ASSIGNMENT() {
  return getToken(NeoBasicParser::SIGNED_RIGHT_SHIFT_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::UNSIGNED_RIGHT_SHIFT_ASSIGNMENT() {
  return getToken(NeoBasicParser::UNSIGNED_RIGHT_SHIFT_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::NONE_COALESCING_ASSIGNMENT() {
  return getToken(NeoBasicParser::NONE_COALESCING_ASSIGNMENT, 0);
}


size_t NeoBasicParser::CompoundAssignmentOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleCompoundAssignmentOperator;
}

void NeoBasicParser::CompoundAssignmentOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompoundAssignmentOperator(this);
}

void NeoBasicParser::CompoundAssignmentOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompoundAssignmentOperator(this);
}

NeoBasicParser::CompoundAssignmentOperatorContext* NeoBasicParser::compoundAssignmentOperator() {
  CompoundAssignmentOperatorContext *_localctx = _tracker.createInstance<CompoundAssignmentOperatorContext>(_ctx, getState());
  enterRule(_localctx, 118, NeoBasicParser::RuleCompoundAssignmentOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(446);
    _la = _input->LA(1);
    if (!(((((_la - 97) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 97)) & 4194303) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SymbolIdentifierContext ------------------------------------------------------------------

NeoBasicParser::SymbolIdentifierContext::SymbolIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::SymbolIdentifierContext::IDENTIFIER() {
  return getToken(NeoBasicParser::IDENTIFIER, 0);
}


size_t NeoBasicParser::SymbolIdentifierContext::getRuleIndex() const {
  return NeoBasicParser::RuleSymbolIdentifier;
}

void NeoBasicParser::SymbolIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSymbolIdentifier(this);
}

void NeoBasicParser::SymbolIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSymbolIdentifier(this);
}

NeoBasicParser::SymbolIdentifierContext* NeoBasicParser::symbolIdentifier() {
  SymbolIdentifierContext *_localctx = _tracker.createInstance<SymbolIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 120, NeoBasicParser::RuleSymbolIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(448);
    match(NeoBasicParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiedIdentifierContext ------------------------------------------------------------------

NeoBasicParser::QualifiedIdentifierContext::QualifiedIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> NeoBasicParser::QualifiedIdentifierContext::IDENTIFIER() {
  return getTokens(NeoBasicParser::IDENTIFIER);
}

tree::TerminalNode* NeoBasicParser::QualifiedIdentifierContext::IDENTIFIER(size_t i) {
  return getToken(NeoBasicParser::IDENTIFIER, i);
}

std::vector<tree::TerminalNode *> NeoBasicParser::QualifiedIdentifierContext::DOT() {
  return getTokens(NeoBasicParser::DOT);
}

tree::TerminalNode* NeoBasicParser::QualifiedIdentifierContext::DOT(size_t i) {
  return getToken(NeoBasicParser::DOT, i);
}


size_t NeoBasicParser::QualifiedIdentifierContext::getRuleIndex() const {
  return NeoBasicParser::RuleQualifiedIdentifier;
}

void NeoBasicParser::QualifiedIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifiedIdentifier(this);
}

void NeoBasicParser::QualifiedIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifiedIdentifier(this);
}

NeoBasicParser::QualifiedIdentifierContext* NeoBasicParser::qualifiedIdentifier() {
  QualifiedIdentifierContext *_localctx = _tracker.createInstance<QualifiedIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 122, NeoBasicParser::RuleQualifiedIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(450);
    match(NeoBasicParser::IDENTIFIER);
    setState(455);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(451);
        match(NeoBasicParser::DOT);
        setState(452);
        match(NeoBasicParser::IDENTIFIER); 
      }
      setState(457);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifiersContext ------------------------------------------------------------------

NeoBasicParser::IdentifiersContext::IdentifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> NeoBasicParser::IdentifiersContext::IDENTIFIER() {
  return getTokens(NeoBasicParser::IDENTIFIER);
}

tree::TerminalNode* NeoBasicParser::IdentifiersContext::IDENTIFIER(size_t i) {
  return getToken(NeoBasicParser::IDENTIFIER, i);
}

std::vector<tree::TerminalNode *> NeoBasicParser::IdentifiersContext::COMMA() {
  return getTokens(NeoBasicParser::COMMA);
}

tree::TerminalNode* NeoBasicParser::IdentifiersContext::COMMA(size_t i) {
  return getToken(NeoBasicParser::COMMA, i);
}


size_t NeoBasicParser::IdentifiersContext::getRuleIndex() const {
  return NeoBasicParser::RuleIdentifiers;
}

void NeoBasicParser::IdentifiersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifiers(this);
}

void NeoBasicParser::IdentifiersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifiers(this);
}

NeoBasicParser::IdentifiersContext* NeoBasicParser::identifiers() {
  IdentifiersContext *_localctx = _tracker.createInstance<IdentifiersContext>(_ctx, getState());
  enterRule(_localctx, 124, NeoBasicParser::RuleIdentifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(458);
    match(NeoBasicParser::IDENTIFIER);
    setState(463);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NeoBasicParser::COMMA) {
      setState(459);
      match(NeoBasicParser::COMMA);
      setState(460);
      match(NeoBasicParser::IDENTIFIER);
      setState(465);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SymbolIdentifiersContext ------------------------------------------------------------------

NeoBasicParser::SymbolIdentifiersContext::SymbolIdentifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NeoBasicParser::SymbolIdentifierContext *> NeoBasicParser::SymbolIdentifiersContext::symbolIdentifier() {
  return getRuleContexts<NeoBasicParser::SymbolIdentifierContext>();
}

NeoBasicParser::SymbolIdentifierContext* NeoBasicParser::SymbolIdentifiersContext::symbolIdentifier(size_t i) {
  return getRuleContext<NeoBasicParser::SymbolIdentifierContext>(i);
}

std::vector<tree::TerminalNode *> NeoBasicParser::SymbolIdentifiersContext::COMMA() {
  return getTokens(NeoBasicParser::COMMA);
}

tree::TerminalNode* NeoBasicParser::SymbolIdentifiersContext::COMMA(size_t i) {
  return getToken(NeoBasicParser::COMMA, i);
}


size_t NeoBasicParser::SymbolIdentifiersContext::getRuleIndex() const {
  return NeoBasicParser::RuleSymbolIdentifiers;
}

void NeoBasicParser::SymbolIdentifiersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSymbolIdentifiers(this);
}

void NeoBasicParser::SymbolIdentifiersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSymbolIdentifiers(this);
}

NeoBasicParser::SymbolIdentifiersContext* NeoBasicParser::symbolIdentifiers() {
  SymbolIdentifiersContext *_localctx = _tracker.createInstance<SymbolIdentifiersContext>(_ctx, getState());
  enterRule(_localctx, 126, NeoBasicParser::RuleSymbolIdentifiers);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(466);
    symbolIdentifier();
    setState(471);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(467);
        match(NeoBasicParser::COMMA);
        setState(468);
        symbolIdentifier(); 
      }
      setState(473);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiedIdentifiersContext ------------------------------------------------------------------

NeoBasicParser::QualifiedIdentifiersContext::QualifiedIdentifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NeoBasicParser::QualifiedIdentifierContext *> NeoBasicParser::QualifiedIdentifiersContext::qualifiedIdentifier() {
  return getRuleContexts<NeoBasicParser::QualifiedIdentifierContext>();
}

NeoBasicParser::QualifiedIdentifierContext* NeoBasicParser::QualifiedIdentifiersContext::qualifiedIdentifier(size_t i) {
  return getRuleContext<NeoBasicParser::QualifiedIdentifierContext>(i);
}

std::vector<tree::TerminalNode *> NeoBasicParser::QualifiedIdentifiersContext::COMMA() {
  return getTokens(NeoBasicParser::COMMA);
}

tree::TerminalNode* NeoBasicParser::QualifiedIdentifiersContext::COMMA(size_t i) {
  return getToken(NeoBasicParser::COMMA, i);
}


size_t NeoBasicParser::QualifiedIdentifiersContext::getRuleIndex() const {
  return NeoBasicParser::RuleQualifiedIdentifiers;
}

void NeoBasicParser::QualifiedIdentifiersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifiedIdentifiers(this);
}

void NeoBasicParser::QualifiedIdentifiersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifiedIdentifiers(this);
}

NeoBasicParser::QualifiedIdentifiersContext* NeoBasicParser::qualifiedIdentifiers() {
  QualifiedIdentifiersContext *_localctx = _tracker.createInstance<QualifiedIdentifiersContext>(_ctx, getState());
  enterRule(_localctx, 128, NeoBasicParser::RuleQualifiedIdentifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(474);
    qualifiedIdentifier();
    setState(479);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NeoBasicParser::COMMA) {
      setState(475);
      match(NeoBasicParser::COMMA);
      setState(476);
      qualifiedIdentifier();
      setState(481);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeContext ------------------------------------------------------------------

NeoBasicParser::TypeContext::TypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NeoBasicParser::NativeTypeContext *> NeoBasicParser::TypeContext::nativeType() {
  return getRuleContexts<NeoBasicParser::NativeTypeContext>();
}

NeoBasicParser::NativeTypeContext* NeoBasicParser::TypeContext::nativeType(size_t i) {
  return getRuleContext<NeoBasicParser::NativeTypeContext>(i);
}

NeoBasicParser::PosfixTypeWrapperContext* NeoBasicParser::TypeContext::posfixTypeWrapper() {
  return getRuleContext<NeoBasicParser::PosfixTypeWrapperContext>(0);
}

tree::TerminalNode* NeoBasicParser::TypeContext::AMPERSAND() {
  return getToken(NeoBasicParser::AMPERSAND, 0);
}

tree::TerminalNode* NeoBasicParser::TypeContext::PIPE() {
  return getToken(NeoBasicParser::PIPE, 0);
}

NeoBasicParser::TypeContext* NeoBasicParser::TypeContext::type() {
  return getRuleContext<NeoBasicParser::TypeContext>(0);
}


size_t NeoBasicParser::TypeContext::getRuleIndex() const {
  return NeoBasicParser::RuleType;
}

void NeoBasicParser::TypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType(this);
}

void NeoBasicParser::TypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType(this);
}

NeoBasicParser::TypeContext* NeoBasicParser::type() {
  TypeContext *_localctx = _tracker.createInstance<TypeContext>(_ctx, getState());
  enterRule(_localctx, 130, NeoBasicParser::RuleType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(495);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(482);
      nativeType();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(483);
      nativeType();
      setState(484);
      posfixTypeWrapper();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(486);
      nativeType();
      setState(487);
      match(NeoBasicParser::AMPERSAND);
      setState(488);
      nativeType();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(490);
      nativeType();
      setState(491);
      match(NeoBasicParser::PIPE);
      setState(492);
      type();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(494);
      nativeType();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NativeTypeContext ------------------------------------------------------------------

NeoBasicParser::NativeTypeContext::NativeTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::EscalarTypeContext* NeoBasicParser::NativeTypeContext::escalarType() {
  return getRuleContext<NeoBasicParser::EscalarTypeContext>(0);
}

NeoBasicParser::CompositeTypeContext* NeoBasicParser::NativeTypeContext::compositeType() {
  return getRuleContext<NeoBasicParser::CompositeTypeContext>(0);
}

NeoBasicParser::MetaTypeContext* NeoBasicParser::NativeTypeContext::metaType() {
  return getRuleContext<NeoBasicParser::MetaTypeContext>(0);
}


size_t NeoBasicParser::NativeTypeContext::getRuleIndex() const {
  return NeoBasicParser::RuleNativeType;
}

void NeoBasicParser::NativeTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNativeType(this);
}

void NeoBasicParser::NativeTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNativeType(this);
}

NeoBasicParser::NativeTypeContext* NeoBasicParser::nativeType() {
  NativeTypeContext *_localctx = _tracker.createInstance<NativeTypeContext>(_ctx, getState());
  enterRule(_localctx, 132, NeoBasicParser::RuleNativeType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(500);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::BOOL8:
      case NeoBasicParser::BOOL16:
      case NeoBasicParser::BOOL32:
      case NeoBasicParser::BOOL64:
      case NeoBasicParser::BOOL128:
      case NeoBasicParser::BOOL:
      case NeoBasicParser::DIG:
      case NeoBasicParser::BIT:
      case NeoBasicParser::OCT:
      case NeoBasicParser::HEX:
      case NeoBasicParser::NIBBLE:
      case NeoBasicParser::BYTE:
      case NeoBasicParser::NUMBER:
      case NeoBasicParser::NAT8:
      case NeoBasicParser::NAT16:
      case NeoBasicParser::NAT32:
      case NeoBasicParser::NAT64:
      case NeoBasicParser::NAT128:
      case NeoBasicParser::NAT:
      case NeoBasicParser::BIGNAT:
      case NeoBasicParser::INT8:
      case NeoBasicParser::INT16:
      case NeoBasicParser::INT32:
      case NeoBasicParser::INT64:
      case NeoBasicParser::INT128:
      case NeoBasicParser::INT:
      case NeoBasicParser::BIGINT:
      case NeoBasicParser::REAL16:
      case NeoBasicParser::REAL32:
      case NeoBasicParser::REAL64:
      case NeoBasicParser::REAL128:
      case NeoBasicParser::REAL:
      case NeoBasicParser::BIGREAL:
      case NeoBasicParser::DEC1:
      case NeoBasicParser::DEC2:
      case NeoBasicParser::DEC3:
      case NeoBasicParser::DEC4:
      case NeoBasicParser::DEC5:
      case NeoBasicParser::DEC6:
      case NeoBasicParser::DEC7:
      case NeoBasicParser::DEC8:
      case NeoBasicParser::DECIMAL:
      case NeoBasicParser::MONEY:
      case NeoBasicParser::BIGDECIMAL:
      case NeoBasicParser::RATIO8:
      case NeoBasicParser::RATIO16:
      case NeoBasicParser::RATIO32:
      case NeoBasicParser::RATIO64:
      case NeoBasicParser::RATIO128:
      case NeoBasicParser::RATIO:
      case NeoBasicParser::COMPLEX16:
      case NeoBasicParser::COMPLEX32:
      case NeoBasicParser::COMPLEX64:
      case NeoBasicParser::COMPLEX128:
      case NeoBasicParser::COMPLEX:
      case NeoBasicParser::QUATERN16:
      case NeoBasicParser::QUATERN32:
      case NeoBasicParser::QUATERN64:
      case NeoBasicParser::QUATERN128:
      case NeoBasicParser::QUATERN:
      case NeoBasicParser::DATE:
      case NeoBasicParser::ELAPSE:
      case NeoBasicParser::ASCII:
      case NeoBasicParser::CHAR8:
      case NeoBasicParser::CHAR16:
      case NeoBasicParser::CHAR32:
      case NeoBasicParser::CHAR:
      case NeoBasicParser::STR:
      case NeoBasicParser::STRING8:
      case NeoBasicParser::STRING16:
      case NeoBasicParser::STRING32:
      case NeoBasicParser::STRING:
      case NeoBasicParser::REGEX:
      case NeoBasicParser::BINARY: {
        enterOuterAlt(_localctx, 1);
        setState(497);
        escalarType();
        break;
      }

      case NeoBasicParser::RANGE: {
        enterOuterAlt(_localctx, 2);
        setState(498);
        compositeType();
        break;
      }

      case NeoBasicParser::ATOM:
      case NeoBasicParser::AUTO:
      case NeoBasicParser::VOID: {
        enterOuterAlt(_localctx, 3);
        setState(499);
        metaType();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PosfixTypeWrapperContext ------------------------------------------------------------------

NeoBasicParser::PosfixTypeWrapperContext::PosfixTypeWrapperContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::PosfixTypeWrapperContext::EXCLAMATION() {
  return getToken(NeoBasicParser::EXCLAMATION, 0);
}

std::vector<tree::TerminalNode *> NeoBasicParser::PosfixTypeWrapperContext::QUESTION() {
  return getTokens(NeoBasicParser::QUESTION);
}

tree::TerminalNode* NeoBasicParser::PosfixTypeWrapperContext::QUESTION(size_t i) {
  return getToken(NeoBasicParser::QUESTION, i);
}

tree::TerminalNode* NeoBasicParser::PosfixTypeWrapperContext::PIPE() {
  return getToken(NeoBasicParser::PIPE, 0);
}

tree::TerminalNode* NeoBasicParser::PosfixTypeWrapperContext::RIGHT_ANGLE() {
  return getToken(NeoBasicParser::RIGHT_ANGLE, 0);
}


size_t NeoBasicParser::PosfixTypeWrapperContext::getRuleIndex() const {
  return NeoBasicParser::RulePosfixTypeWrapper;
}

void NeoBasicParser::PosfixTypeWrapperContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPosfixTypeWrapper(this);
}

void NeoBasicParser::PosfixTypeWrapperContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPosfixTypeWrapper(this);
}

NeoBasicParser::PosfixTypeWrapperContext* NeoBasicParser::posfixTypeWrapper() {
  PosfixTypeWrapperContext *_localctx = _tracker.createInstance<PosfixTypeWrapperContext>(_ctx, getState());
  enterRule(_localctx, 134, NeoBasicParser::RulePosfixTypeWrapper);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(516);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(502);
      match(NeoBasicParser::EXCLAMATION);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(503);
      match(NeoBasicParser::QUESTION);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(504);
      match(NeoBasicParser::QUESTION);
      setState(505);
      match(NeoBasicParser::QUESTION);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(506);
      match(NeoBasicParser::PIPE);
      setState(507);
      match(NeoBasicParser::RIGHT_ANGLE);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(508);
      match(NeoBasicParser::EXCLAMATION);
      setState(509);
      match(NeoBasicParser::QUESTION);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(510);
      match(NeoBasicParser::EXCLAMATION);
      setState(511);
      match(NeoBasicParser::QUESTION);
      setState(512);
      match(NeoBasicParser::QUESTION);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(513);
      match(NeoBasicParser::EXCLAMATION);
      setState(514);
      match(NeoBasicParser::PIPE);
      setState(515);
      match(NeoBasicParser::RIGHT_ANGLE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EscalarTypeContext ------------------------------------------------------------------

NeoBasicParser::EscalarTypeContext::EscalarTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::BooleanTypeContext* NeoBasicParser::EscalarTypeContext::booleanType() {
  return getRuleContext<NeoBasicParser::BooleanTypeContext>(0);
}

NeoBasicParser::NumericTypeContext* NeoBasicParser::EscalarTypeContext::numericType() {
  return getRuleContext<NeoBasicParser::NumericTypeContext>(0);
}

NeoBasicParser::TemporalTypeContext* NeoBasicParser::EscalarTypeContext::temporalType() {
  return getRuleContext<NeoBasicParser::TemporalTypeContext>(0);
}

NeoBasicParser::CharacterTypeContext* NeoBasicParser::EscalarTypeContext::characterType() {
  return getRuleContext<NeoBasicParser::CharacterTypeContext>(0);
}

NeoBasicParser::SequenceTypeContext* NeoBasicParser::EscalarTypeContext::sequenceType() {
  return getRuleContext<NeoBasicParser::SequenceTypeContext>(0);
}


size_t NeoBasicParser::EscalarTypeContext::getRuleIndex() const {
  return NeoBasicParser::RuleEscalarType;
}

void NeoBasicParser::EscalarTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEscalarType(this);
}

void NeoBasicParser::EscalarTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEscalarType(this);
}

NeoBasicParser::EscalarTypeContext* NeoBasicParser::escalarType() {
  EscalarTypeContext *_localctx = _tracker.createInstance<EscalarTypeContext>(_ctx, getState());
  enterRule(_localctx, 136, NeoBasicParser::RuleEscalarType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(523);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::BOOL8:
      case NeoBasicParser::BOOL16:
      case NeoBasicParser::BOOL32:
      case NeoBasicParser::BOOL64:
      case NeoBasicParser::BOOL128:
      case NeoBasicParser::BOOL: {
        enterOuterAlt(_localctx, 1);
        setState(518);
        booleanType();
        break;
      }

      case NeoBasicParser::DIG:
      case NeoBasicParser::BIT:
      case NeoBasicParser::OCT:
      case NeoBasicParser::HEX:
      case NeoBasicParser::NIBBLE:
      case NeoBasicParser::BYTE:
      case NeoBasicParser::NUMBER:
      case NeoBasicParser::NAT8:
      case NeoBasicParser::NAT16:
      case NeoBasicParser::NAT32:
      case NeoBasicParser::NAT64:
      case NeoBasicParser::NAT128:
      case NeoBasicParser::NAT:
      case NeoBasicParser::BIGNAT:
      case NeoBasicParser::INT8:
      case NeoBasicParser::INT16:
      case NeoBasicParser::INT32:
      case NeoBasicParser::INT64:
      case NeoBasicParser::INT128:
      case NeoBasicParser::INT:
      case NeoBasicParser::BIGINT:
      case NeoBasicParser::REAL16:
      case NeoBasicParser::REAL32:
      case NeoBasicParser::REAL64:
      case NeoBasicParser::REAL128:
      case NeoBasicParser::REAL:
      case NeoBasicParser::BIGREAL:
      case NeoBasicParser::DEC1:
      case NeoBasicParser::DEC2:
      case NeoBasicParser::DEC3:
      case NeoBasicParser::DEC4:
      case NeoBasicParser::DEC5:
      case NeoBasicParser::DEC6:
      case NeoBasicParser::DEC7:
      case NeoBasicParser::DEC8:
      case NeoBasicParser::DECIMAL:
      case NeoBasicParser::MONEY:
      case NeoBasicParser::BIGDECIMAL:
      case NeoBasicParser::RATIO8:
      case NeoBasicParser::RATIO16:
      case NeoBasicParser::RATIO32:
      case NeoBasicParser::RATIO64:
      case NeoBasicParser::RATIO128:
      case NeoBasicParser::RATIO:
      case NeoBasicParser::COMPLEX16:
      case NeoBasicParser::COMPLEX32:
      case NeoBasicParser::COMPLEX64:
      case NeoBasicParser::COMPLEX128:
      case NeoBasicParser::COMPLEX:
      case NeoBasicParser::QUATERN16:
      case NeoBasicParser::QUATERN32:
      case NeoBasicParser::QUATERN64:
      case NeoBasicParser::QUATERN128:
      case NeoBasicParser::QUATERN: {
        enterOuterAlt(_localctx, 2);
        setState(519);
        numericType();
        break;
      }

      case NeoBasicParser::DATE:
      case NeoBasicParser::ELAPSE: {
        enterOuterAlt(_localctx, 3);
        setState(520);
        temporalType();
        break;
      }

      case NeoBasicParser::ASCII:
      case NeoBasicParser::CHAR8:
      case NeoBasicParser::CHAR16:
      case NeoBasicParser::CHAR32:
      case NeoBasicParser::CHAR: {
        enterOuterAlt(_localctx, 4);
        setState(521);
        characterType();
        break;
      }

      case NeoBasicParser::STR:
      case NeoBasicParser::STRING8:
      case NeoBasicParser::STRING16:
      case NeoBasicParser::STRING32:
      case NeoBasicParser::STRING:
      case NeoBasicParser::REGEX:
      case NeoBasicParser::BINARY: {
        enterOuterAlt(_localctx, 5);
        setState(522);
        sequenceType();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BooleanTypeContext ------------------------------------------------------------------

NeoBasicParser::BooleanTypeContext::BooleanTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BooleanTypeContext::BOOL8() {
  return getToken(NeoBasicParser::BOOL8, 0);
}

tree::TerminalNode* NeoBasicParser::BooleanTypeContext::BOOL16() {
  return getToken(NeoBasicParser::BOOL16, 0);
}

tree::TerminalNode* NeoBasicParser::BooleanTypeContext::BOOL32() {
  return getToken(NeoBasicParser::BOOL32, 0);
}

tree::TerminalNode* NeoBasicParser::BooleanTypeContext::BOOL64() {
  return getToken(NeoBasicParser::BOOL64, 0);
}

tree::TerminalNode* NeoBasicParser::BooleanTypeContext::BOOL128() {
  return getToken(NeoBasicParser::BOOL128, 0);
}

tree::TerminalNode* NeoBasicParser::BooleanTypeContext::BOOL() {
  return getToken(NeoBasicParser::BOOL, 0);
}


size_t NeoBasicParser::BooleanTypeContext::getRuleIndex() const {
  return NeoBasicParser::RuleBooleanType;
}

void NeoBasicParser::BooleanTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBooleanType(this);
}

void NeoBasicParser::BooleanTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBooleanType(this);
}

NeoBasicParser::BooleanTypeContext* NeoBasicParser::booleanType() {
  BooleanTypeContext *_localctx = _tracker.createInstance<BooleanTypeContext>(_ctx, getState());
  enterRule(_localctx, 138, NeoBasicParser::RuleBooleanType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(525);
    _la = _input->LA(1);
    if (!(((((_la - 199) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 199)) & 63) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericTypeContext ------------------------------------------------------------------

NeoBasicParser::NumericTypeContext::NumericTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::NumericDigitContext* NeoBasicParser::NumericTypeContext::numericDigit() {
  return getRuleContext<NeoBasicParser::NumericDigitContext>(0);
}

NeoBasicParser::NumericNaturalContext* NeoBasicParser::NumericTypeContext::numericNatural() {
  return getRuleContext<NeoBasicParser::NumericNaturalContext>(0);
}

NeoBasicParser::NumericIntegerContext* NeoBasicParser::NumericTypeContext::numericInteger() {
  return getRuleContext<NeoBasicParser::NumericIntegerContext>(0);
}

NeoBasicParser::NumericRealContext* NeoBasicParser::NumericTypeContext::numericReal() {
  return getRuleContext<NeoBasicParser::NumericRealContext>(0);
}

NeoBasicParser::NumericDecimalContext* NeoBasicParser::NumericTypeContext::numericDecimal() {
  return getRuleContext<NeoBasicParser::NumericDecimalContext>(0);
}

NeoBasicParser::NumericRatioContext* NeoBasicParser::NumericTypeContext::numericRatio() {
  return getRuleContext<NeoBasicParser::NumericRatioContext>(0);
}

NeoBasicParser::NumericComplexContext* NeoBasicParser::NumericTypeContext::numericComplex() {
  return getRuleContext<NeoBasicParser::NumericComplexContext>(0);
}

NeoBasicParser::NumericQuaternionContext* NeoBasicParser::NumericTypeContext::numericQuaternion() {
  return getRuleContext<NeoBasicParser::NumericQuaternionContext>(0);
}

tree::TerminalNode* NeoBasicParser::NumericTypeContext::NUMBER() {
  return getToken(NeoBasicParser::NUMBER, 0);
}


size_t NeoBasicParser::NumericTypeContext::getRuleIndex() const {
  return NeoBasicParser::RuleNumericType;
}

void NeoBasicParser::NumericTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericType(this);
}

void NeoBasicParser::NumericTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericType(this);
}

NeoBasicParser::NumericTypeContext* NeoBasicParser::numericType() {
  NumericTypeContext *_localctx = _tracker.createInstance<NumericTypeContext>(_ctx, getState());
  enterRule(_localctx, 140, NeoBasicParser::RuleNumericType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(536);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::DIG:
      case NeoBasicParser::BIT:
      case NeoBasicParser::OCT:
      case NeoBasicParser::HEX:
      case NeoBasicParser::NIBBLE:
      case NeoBasicParser::BYTE: {
        enterOuterAlt(_localctx, 1);
        setState(527);
        numericDigit();
        break;
      }

      case NeoBasicParser::NAT8:
      case NeoBasicParser::NAT16:
      case NeoBasicParser::NAT32:
      case NeoBasicParser::NAT64:
      case NeoBasicParser::NAT128:
      case NeoBasicParser::NAT:
      case NeoBasicParser::BIGNAT: {
        enterOuterAlt(_localctx, 2);
        setState(528);
        numericNatural();
        break;
      }

      case NeoBasicParser::INT8:
      case NeoBasicParser::INT16:
      case NeoBasicParser::INT32:
      case NeoBasicParser::INT64:
      case NeoBasicParser::INT128:
      case NeoBasicParser::INT:
      case NeoBasicParser::BIGINT: {
        enterOuterAlt(_localctx, 3);
        setState(529);
        numericInteger();
        break;
      }

      case NeoBasicParser::REAL16:
      case NeoBasicParser::REAL32:
      case NeoBasicParser::REAL64:
      case NeoBasicParser::REAL128:
      case NeoBasicParser::REAL:
      case NeoBasicParser::BIGREAL: {
        enterOuterAlt(_localctx, 4);
        setState(530);
        numericReal();
        break;
      }

      case NeoBasicParser::DEC1:
      case NeoBasicParser::DEC2:
      case NeoBasicParser::DEC3:
      case NeoBasicParser::DEC4:
      case NeoBasicParser::DEC5:
      case NeoBasicParser::DEC6:
      case NeoBasicParser::DEC7:
      case NeoBasicParser::DEC8:
      case NeoBasicParser::DECIMAL:
      case NeoBasicParser::MONEY:
      case NeoBasicParser::BIGDECIMAL: {
        enterOuterAlt(_localctx, 5);
        setState(531);
        numericDecimal();
        break;
      }

      case NeoBasicParser::RATIO8:
      case NeoBasicParser::RATIO16:
      case NeoBasicParser::RATIO32:
      case NeoBasicParser::RATIO64:
      case NeoBasicParser::RATIO128:
      case NeoBasicParser::RATIO: {
        enterOuterAlt(_localctx, 6);
        setState(532);
        numericRatio();
        break;
      }

      case NeoBasicParser::COMPLEX16:
      case NeoBasicParser::COMPLEX32:
      case NeoBasicParser::COMPLEX64:
      case NeoBasicParser::COMPLEX128:
      case NeoBasicParser::COMPLEX: {
        enterOuterAlt(_localctx, 7);
        setState(533);
        numericComplex();
        break;
      }

      case NeoBasicParser::QUATERN16:
      case NeoBasicParser::QUATERN32:
      case NeoBasicParser::QUATERN64:
      case NeoBasicParser::QUATERN128:
      case NeoBasicParser::QUATERN: {
        enterOuterAlt(_localctx, 8);
        setState(534);
        numericQuaternion();
        break;
      }

      case NeoBasicParser::NUMBER: {
        enterOuterAlt(_localctx, 9);
        setState(535);
        match(NeoBasicParser::NUMBER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericDigitContext ------------------------------------------------------------------

NeoBasicParser::NumericDigitContext::NumericDigitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::NumericDigitContext::DIG() {
  return getToken(NeoBasicParser::DIG, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDigitContext::BIT() {
  return getToken(NeoBasicParser::BIT, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDigitContext::OCT() {
  return getToken(NeoBasicParser::OCT, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDigitContext::HEX() {
  return getToken(NeoBasicParser::HEX, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDigitContext::NIBBLE() {
  return getToken(NeoBasicParser::NIBBLE, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDigitContext::BYTE() {
  return getToken(NeoBasicParser::BYTE, 0);
}


size_t NeoBasicParser::NumericDigitContext::getRuleIndex() const {
  return NeoBasicParser::RuleNumericDigit;
}

void NeoBasicParser::NumericDigitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericDigit(this);
}

void NeoBasicParser::NumericDigitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericDigit(this);
}

NeoBasicParser::NumericDigitContext* NeoBasicParser::numericDigit() {
  NumericDigitContext *_localctx = _tracker.createInstance<NumericDigitContext>(_ctx, getState());
  enterRule(_localctx, 142, NeoBasicParser::RuleNumericDigit);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(538);
    _la = _input->LA(1);
    if (!(((((_la - 205) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 205)) & 63) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericNaturalContext ------------------------------------------------------------------

NeoBasicParser::NumericNaturalContext::NumericNaturalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::NumericNaturalContext::NAT8() {
  return getToken(NeoBasicParser::NAT8, 0);
}

tree::TerminalNode* NeoBasicParser::NumericNaturalContext::NAT16() {
  return getToken(NeoBasicParser::NAT16, 0);
}

tree::TerminalNode* NeoBasicParser::NumericNaturalContext::NAT32() {
  return getToken(NeoBasicParser::NAT32, 0);
}

tree::TerminalNode* NeoBasicParser::NumericNaturalContext::NAT64() {
  return getToken(NeoBasicParser::NAT64, 0);
}

tree::TerminalNode* NeoBasicParser::NumericNaturalContext::NAT128() {
  return getToken(NeoBasicParser::NAT128, 0);
}

tree::TerminalNode* NeoBasicParser::NumericNaturalContext::NAT() {
  return getToken(NeoBasicParser::NAT, 0);
}

tree::TerminalNode* NeoBasicParser::NumericNaturalContext::BIGNAT() {
  return getToken(NeoBasicParser::BIGNAT, 0);
}


size_t NeoBasicParser::NumericNaturalContext::getRuleIndex() const {
  return NeoBasicParser::RuleNumericNatural;
}

void NeoBasicParser::NumericNaturalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericNatural(this);
}

void NeoBasicParser::NumericNaturalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericNatural(this);
}

NeoBasicParser::NumericNaturalContext* NeoBasicParser::numericNatural() {
  NumericNaturalContext *_localctx = _tracker.createInstance<NumericNaturalContext>(_ctx, getState());
  enterRule(_localctx, 144, NeoBasicParser::RuleNumericNatural);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(540);
    _la = _input->LA(1);
    if (!(((((_la - 212) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 212)) & 127) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericIntegerContext ------------------------------------------------------------------

NeoBasicParser::NumericIntegerContext::NumericIntegerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::NumericIntegerContext::INT8() {
  return getToken(NeoBasicParser::INT8, 0);
}

tree::TerminalNode* NeoBasicParser::NumericIntegerContext::INT16() {
  return getToken(NeoBasicParser::INT16, 0);
}

tree::TerminalNode* NeoBasicParser::NumericIntegerContext::INT32() {
  return getToken(NeoBasicParser::INT32, 0);
}

tree::TerminalNode* NeoBasicParser::NumericIntegerContext::INT64() {
  return getToken(NeoBasicParser::INT64, 0);
}

tree::TerminalNode* NeoBasicParser::NumericIntegerContext::INT128() {
  return getToken(NeoBasicParser::INT128, 0);
}

tree::TerminalNode* NeoBasicParser::NumericIntegerContext::INT() {
  return getToken(NeoBasicParser::INT, 0);
}

tree::TerminalNode* NeoBasicParser::NumericIntegerContext::BIGINT() {
  return getToken(NeoBasicParser::BIGINT, 0);
}


size_t NeoBasicParser::NumericIntegerContext::getRuleIndex() const {
  return NeoBasicParser::RuleNumericInteger;
}

void NeoBasicParser::NumericIntegerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericInteger(this);
}

void NeoBasicParser::NumericIntegerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericInteger(this);
}

NeoBasicParser::NumericIntegerContext* NeoBasicParser::numericInteger() {
  NumericIntegerContext *_localctx = _tracker.createInstance<NumericIntegerContext>(_ctx, getState());
  enterRule(_localctx, 146, NeoBasicParser::RuleNumericInteger);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(542);
    _la = _input->LA(1);
    if (!(((((_la - 219) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 219)) & 127) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericRealContext ------------------------------------------------------------------

NeoBasicParser::NumericRealContext::NumericRealContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::NumericRealContext::REAL16() {
  return getToken(NeoBasicParser::REAL16, 0);
}

tree::TerminalNode* NeoBasicParser::NumericRealContext::REAL32() {
  return getToken(NeoBasicParser::REAL32, 0);
}

tree::TerminalNode* NeoBasicParser::NumericRealContext::REAL64() {
  return getToken(NeoBasicParser::REAL64, 0);
}

tree::TerminalNode* NeoBasicParser::NumericRealContext::REAL128() {
  return getToken(NeoBasicParser::REAL128, 0);
}

tree::TerminalNode* NeoBasicParser::NumericRealContext::REAL() {
  return getToken(NeoBasicParser::REAL, 0);
}

tree::TerminalNode* NeoBasicParser::NumericRealContext::BIGREAL() {
  return getToken(NeoBasicParser::BIGREAL, 0);
}


size_t NeoBasicParser::NumericRealContext::getRuleIndex() const {
  return NeoBasicParser::RuleNumericReal;
}

void NeoBasicParser::NumericRealContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericReal(this);
}

void NeoBasicParser::NumericRealContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericReal(this);
}

NeoBasicParser::NumericRealContext* NeoBasicParser::numericReal() {
  NumericRealContext *_localctx = _tracker.createInstance<NumericRealContext>(_ctx, getState());
  enterRule(_localctx, 148, NeoBasicParser::RuleNumericReal);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(544);
    _la = _input->LA(1);
    if (!(((((_la - 226) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 226)) & 63) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericDecimalContext ------------------------------------------------------------------

NeoBasicParser::NumericDecimalContext::NumericDecimalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::NumericDecimalContext::DEC1() {
  return getToken(NeoBasicParser::DEC1, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDecimalContext::DEC2() {
  return getToken(NeoBasicParser::DEC2, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDecimalContext::DEC3() {
  return getToken(NeoBasicParser::DEC3, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDecimalContext::DEC4() {
  return getToken(NeoBasicParser::DEC4, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDecimalContext::DEC5() {
  return getToken(NeoBasicParser::DEC5, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDecimalContext::DEC6() {
  return getToken(NeoBasicParser::DEC6, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDecimalContext::DEC7() {
  return getToken(NeoBasicParser::DEC7, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDecimalContext::DEC8() {
  return getToken(NeoBasicParser::DEC8, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDecimalContext::DECIMAL() {
  return getToken(NeoBasicParser::DECIMAL, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDecimalContext::MONEY() {
  return getToken(NeoBasicParser::MONEY, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDecimalContext::BIGDECIMAL() {
  return getToken(NeoBasicParser::BIGDECIMAL, 0);
}


size_t NeoBasicParser::NumericDecimalContext::getRuleIndex() const {
  return NeoBasicParser::RuleNumericDecimal;
}

void NeoBasicParser::NumericDecimalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericDecimal(this);
}

void NeoBasicParser::NumericDecimalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericDecimal(this);
}

NeoBasicParser::NumericDecimalContext* NeoBasicParser::numericDecimal() {
  NumericDecimalContext *_localctx = _tracker.createInstance<NumericDecimalContext>(_ctx, getState());
  enterRule(_localctx, 150, NeoBasicParser::RuleNumericDecimal);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(546);
    _la = _input->LA(1);
    if (!(((((_la - 232) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 232)) & 2047) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericRatioContext ------------------------------------------------------------------

NeoBasicParser::NumericRatioContext::NumericRatioContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::NumericRatioContext::RATIO8() {
  return getToken(NeoBasicParser::RATIO8, 0);
}

tree::TerminalNode* NeoBasicParser::NumericRatioContext::RATIO16() {
  return getToken(NeoBasicParser::RATIO16, 0);
}

tree::TerminalNode* NeoBasicParser::NumericRatioContext::RATIO32() {
  return getToken(NeoBasicParser::RATIO32, 0);
}

tree::TerminalNode* NeoBasicParser::NumericRatioContext::RATIO64() {
  return getToken(NeoBasicParser::RATIO64, 0);
}

tree::TerminalNode* NeoBasicParser::NumericRatioContext::RATIO128() {
  return getToken(NeoBasicParser::RATIO128, 0);
}

tree::TerminalNode* NeoBasicParser::NumericRatioContext::RATIO() {
  return getToken(NeoBasicParser::RATIO, 0);
}


size_t NeoBasicParser::NumericRatioContext::getRuleIndex() const {
  return NeoBasicParser::RuleNumericRatio;
}

void NeoBasicParser::NumericRatioContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericRatio(this);
}

void NeoBasicParser::NumericRatioContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericRatio(this);
}

NeoBasicParser::NumericRatioContext* NeoBasicParser::numericRatio() {
  NumericRatioContext *_localctx = _tracker.createInstance<NumericRatioContext>(_ctx, getState());
  enterRule(_localctx, 152, NeoBasicParser::RuleNumericRatio);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(548);
    _la = _input->LA(1);
    if (!(((((_la - 243) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 243)) & 63) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericComplexContext ------------------------------------------------------------------

NeoBasicParser::NumericComplexContext::NumericComplexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::NumericComplexContext::COMPLEX16() {
  return getToken(NeoBasicParser::COMPLEX16, 0);
}

tree::TerminalNode* NeoBasicParser::NumericComplexContext::COMPLEX32() {
  return getToken(NeoBasicParser::COMPLEX32, 0);
}

tree::TerminalNode* NeoBasicParser::NumericComplexContext::COMPLEX64() {
  return getToken(NeoBasicParser::COMPLEX64, 0);
}

tree::TerminalNode* NeoBasicParser::NumericComplexContext::COMPLEX128() {
  return getToken(NeoBasicParser::COMPLEX128, 0);
}

tree::TerminalNode* NeoBasicParser::NumericComplexContext::COMPLEX() {
  return getToken(NeoBasicParser::COMPLEX, 0);
}


size_t NeoBasicParser::NumericComplexContext::getRuleIndex() const {
  return NeoBasicParser::RuleNumericComplex;
}

void NeoBasicParser::NumericComplexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericComplex(this);
}

void NeoBasicParser::NumericComplexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericComplex(this);
}

NeoBasicParser::NumericComplexContext* NeoBasicParser::numericComplex() {
  NumericComplexContext *_localctx = _tracker.createInstance<NumericComplexContext>(_ctx, getState());
  enterRule(_localctx, 154, NeoBasicParser::RuleNumericComplex);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(550);
    _la = _input->LA(1);
    if (!(((((_la - 249) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 249)) & 31) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericQuaternionContext ------------------------------------------------------------------

NeoBasicParser::NumericQuaternionContext::NumericQuaternionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::NumericQuaternionContext::QUATERN16() {
  return getToken(NeoBasicParser::QUATERN16, 0);
}

tree::TerminalNode* NeoBasicParser::NumericQuaternionContext::QUATERN32() {
  return getToken(NeoBasicParser::QUATERN32, 0);
}

tree::TerminalNode* NeoBasicParser::NumericQuaternionContext::QUATERN64() {
  return getToken(NeoBasicParser::QUATERN64, 0);
}

tree::TerminalNode* NeoBasicParser::NumericQuaternionContext::QUATERN128() {
  return getToken(NeoBasicParser::QUATERN128, 0);
}

tree::TerminalNode* NeoBasicParser::NumericQuaternionContext::QUATERN() {
  return getToken(NeoBasicParser::QUATERN, 0);
}


size_t NeoBasicParser::NumericQuaternionContext::getRuleIndex() const {
  return NeoBasicParser::RuleNumericQuaternion;
}

void NeoBasicParser::NumericQuaternionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericQuaternion(this);
}

void NeoBasicParser::NumericQuaternionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericQuaternion(this);
}

NeoBasicParser::NumericQuaternionContext* NeoBasicParser::numericQuaternion() {
  NumericQuaternionContext *_localctx = _tracker.createInstance<NumericQuaternionContext>(_ctx, getState());
  enterRule(_localctx, 156, NeoBasicParser::RuleNumericQuaternion);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(552);
    _la = _input->LA(1);
    if (!(((((_la - 254) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 254)) & 31) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TemporalTypeContext ------------------------------------------------------------------

NeoBasicParser::TemporalTypeContext::TemporalTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::TemporalTypeContext::DATE() {
  return getToken(NeoBasicParser::DATE, 0);
}

tree::TerminalNode* NeoBasicParser::TemporalTypeContext::ELAPSE() {
  return getToken(NeoBasicParser::ELAPSE, 0);
}


size_t NeoBasicParser::TemporalTypeContext::getRuleIndex() const {
  return NeoBasicParser::RuleTemporalType;
}

void NeoBasicParser::TemporalTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemporalType(this);
}

void NeoBasicParser::TemporalTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemporalType(this);
}

NeoBasicParser::TemporalTypeContext* NeoBasicParser::temporalType() {
  TemporalTypeContext *_localctx = _tracker.createInstance<TemporalTypeContext>(_ctx, getState());
  enterRule(_localctx, 158, NeoBasicParser::RuleTemporalType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(554);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::DATE

    || _la == NeoBasicParser::ELAPSE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharacterTypeContext ------------------------------------------------------------------

NeoBasicParser::CharacterTypeContext::CharacterTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::CharacterTypeContext::ASCII() {
  return getToken(NeoBasicParser::ASCII, 0);
}

tree::TerminalNode* NeoBasicParser::CharacterTypeContext::CHAR8() {
  return getToken(NeoBasicParser::CHAR8, 0);
}

tree::TerminalNode* NeoBasicParser::CharacterTypeContext::CHAR16() {
  return getToken(NeoBasicParser::CHAR16, 0);
}

tree::TerminalNode* NeoBasicParser::CharacterTypeContext::CHAR32() {
  return getToken(NeoBasicParser::CHAR32, 0);
}

tree::TerminalNode* NeoBasicParser::CharacterTypeContext::CHAR() {
  return getToken(NeoBasicParser::CHAR, 0);
}


size_t NeoBasicParser::CharacterTypeContext::getRuleIndex() const {
  return NeoBasicParser::RuleCharacterType;
}

void NeoBasicParser::CharacterTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharacterType(this);
}

void NeoBasicParser::CharacterTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharacterType(this);
}

NeoBasicParser::CharacterTypeContext* NeoBasicParser::characterType() {
  CharacterTypeContext *_localctx = _tracker.createInstance<CharacterTypeContext>(_ctx, getState());
  enterRule(_localctx, 160, NeoBasicParser::RuleCharacterType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(556);
    _la = _input->LA(1);
    if (!(((((_la - 261) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 261)) & 31) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SequenceTypeContext ------------------------------------------------------------------

NeoBasicParser::SequenceTypeContext::SequenceTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::SequenceTypeContext::STR() {
  return getToken(NeoBasicParser::STR, 0);
}

tree::TerminalNode* NeoBasicParser::SequenceTypeContext::STRING8() {
  return getToken(NeoBasicParser::STRING8, 0);
}

tree::TerminalNode* NeoBasicParser::SequenceTypeContext::STRING16() {
  return getToken(NeoBasicParser::STRING16, 0);
}

tree::TerminalNode* NeoBasicParser::SequenceTypeContext::STRING32() {
  return getToken(NeoBasicParser::STRING32, 0);
}

tree::TerminalNode* NeoBasicParser::SequenceTypeContext::STRING() {
  return getToken(NeoBasicParser::STRING, 0);
}

tree::TerminalNode* NeoBasicParser::SequenceTypeContext::REGEX() {
  return getToken(NeoBasicParser::REGEX, 0);
}

tree::TerminalNode* NeoBasicParser::SequenceTypeContext::BINARY() {
  return getToken(NeoBasicParser::BINARY, 0);
}


size_t NeoBasicParser::SequenceTypeContext::getRuleIndex() const {
  return NeoBasicParser::RuleSequenceType;
}

void NeoBasicParser::SequenceTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSequenceType(this);
}

void NeoBasicParser::SequenceTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSequenceType(this);
}

NeoBasicParser::SequenceTypeContext* NeoBasicParser::sequenceType() {
  SequenceTypeContext *_localctx = _tracker.createInstance<SequenceTypeContext>(_ctx, getState());
  enterRule(_localctx, 162, NeoBasicParser::RuleSequenceType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(558);
    _la = _input->LA(1);
    if (!(((((_la - 266) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 266)) & 127) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompositeTypeContext ------------------------------------------------------------------

NeoBasicParser::CompositeTypeContext::CompositeTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::CompositeTypeContext::RANGE() {
  return getToken(NeoBasicParser::RANGE, 0);
}


size_t NeoBasicParser::CompositeTypeContext::getRuleIndex() const {
  return NeoBasicParser::RuleCompositeType;
}

void NeoBasicParser::CompositeTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompositeType(this);
}

void NeoBasicParser::CompositeTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompositeType(this);
}

NeoBasicParser::CompositeTypeContext* NeoBasicParser::compositeType() {
  CompositeTypeContext *_localctx = _tracker.createInstance<CompositeTypeContext>(_ctx, getState());
  enterRule(_localctx, 164, NeoBasicParser::RuleCompositeType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(560);
    match(NeoBasicParser::RANGE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MetaTypeContext ------------------------------------------------------------------

NeoBasicParser::MetaTypeContext::MetaTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::MetaTypeContext::ATOM() {
  return getToken(NeoBasicParser::ATOM, 0);
}

tree::TerminalNode* NeoBasicParser::MetaTypeContext::AUTO() {
  return getToken(NeoBasicParser::AUTO, 0);
}

tree::TerminalNode* NeoBasicParser::MetaTypeContext::VOID() {
  return getToken(NeoBasicParser::VOID, 0);
}


size_t NeoBasicParser::MetaTypeContext::getRuleIndex() const {
  return NeoBasicParser::RuleMetaType;
}

void NeoBasicParser::MetaTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMetaType(this);
}

void NeoBasicParser::MetaTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMetaType(this);
}

NeoBasicParser::MetaTypeContext* NeoBasicParser::metaType() {
  MetaTypeContext *_localctx = _tracker.createInstance<MetaTypeContext>(_ctx, getState());
  enterRule(_localctx, 166, NeoBasicParser::RuleMetaType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(562);
    _la = _input->LA(1);
    if (!(((((_la - 196) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 196)) & 7) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionsContext ------------------------------------------------------------------

NeoBasicParser::ExpressionsContext::ExpressionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NeoBasicParser::ExpressionContext *> NeoBasicParser::ExpressionsContext::expression() {
  return getRuleContexts<NeoBasicParser::ExpressionContext>();
}

NeoBasicParser::ExpressionContext* NeoBasicParser::ExpressionsContext::expression(size_t i) {
  return getRuleContext<NeoBasicParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> NeoBasicParser::ExpressionsContext::COMMA() {
  return getTokens(NeoBasicParser::COMMA);
}

tree::TerminalNode* NeoBasicParser::ExpressionsContext::COMMA(size_t i) {
  return getToken(NeoBasicParser::COMMA, i);
}


size_t NeoBasicParser::ExpressionsContext::getRuleIndex() const {
  return NeoBasicParser::RuleExpressions;
}

void NeoBasicParser::ExpressionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressions(this);
}

void NeoBasicParser::ExpressionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressions(this);
}

NeoBasicParser::ExpressionsContext* NeoBasicParser::expressions() {
  ExpressionsContext *_localctx = _tracker.createInstance<ExpressionsContext>(_ctx, getState());
  enterRule(_localctx, 168, NeoBasicParser::RuleExpressions);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(564);
    expression(0);
    setState(569);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(565);
        match(NeoBasicParser::COMMA);
        setState(566);
        expression(0); 
      }
      setState(571);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JuxtapositionExpressionContext ------------------------------------------------------------------

NeoBasicParser::JuxtapositionExpressionContext::JuxtapositionExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NeoBasicParser::ExpressionContext *> NeoBasicParser::JuxtapositionExpressionContext::expression() {
  return getRuleContexts<NeoBasicParser::ExpressionContext>();
}

NeoBasicParser::ExpressionContext* NeoBasicParser::JuxtapositionExpressionContext::expression(size_t i) {
  return getRuleContext<NeoBasicParser::ExpressionContext>(i);
}


size_t NeoBasicParser::JuxtapositionExpressionContext::getRuleIndex() const {
  return NeoBasicParser::RuleJuxtapositionExpression;
}

void NeoBasicParser::JuxtapositionExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJuxtapositionExpression(this);
}

void NeoBasicParser::JuxtapositionExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJuxtapositionExpression(this);
}

NeoBasicParser::JuxtapositionExpressionContext* NeoBasicParser::juxtapositionExpression() {
  JuxtapositionExpressionContext *_localctx = _tracker.createInstance<JuxtapositionExpressionContext>(_ctx, getState());
  enterRule(_localctx, 170, NeoBasicParser::RuleJuxtapositionExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(572);
    expression(0);
    setState(576);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 8779718459394) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 84)) & 364808131210903553) != 0) || ((((_la - 175) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 175)) & 767) != 0) || ((((_la - 274) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 274)) & 549751619583) != 0)) {
      setState(573);
      expression(0);
      setState(578);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrimaryExpressionsContext ------------------------------------------------------------------

NeoBasicParser::PrimaryExpressionsContext::PrimaryExpressionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NeoBasicParser::PrimaryExpressionContext *> NeoBasicParser::PrimaryExpressionsContext::primaryExpression() {
  return getRuleContexts<NeoBasicParser::PrimaryExpressionContext>();
}

NeoBasicParser::PrimaryExpressionContext* NeoBasicParser::PrimaryExpressionsContext::primaryExpression(size_t i) {
  return getRuleContext<NeoBasicParser::PrimaryExpressionContext>(i);
}

std::vector<tree::TerminalNode *> NeoBasicParser::PrimaryExpressionsContext::COMMA() {
  return getTokens(NeoBasicParser::COMMA);
}

tree::TerminalNode* NeoBasicParser::PrimaryExpressionsContext::COMMA(size_t i) {
  return getToken(NeoBasicParser::COMMA, i);
}


size_t NeoBasicParser::PrimaryExpressionsContext::getRuleIndex() const {
  return NeoBasicParser::RulePrimaryExpressions;
}

void NeoBasicParser::PrimaryExpressionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryExpressions(this);
}

void NeoBasicParser::PrimaryExpressionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryExpressions(this);
}

NeoBasicParser::PrimaryExpressionsContext* NeoBasicParser::primaryExpressions() {
  PrimaryExpressionsContext *_localctx = _tracker.createInstance<PrimaryExpressionsContext>(_ctx, getState());
  enterRule(_localctx, 172, NeoBasicParser::RulePrimaryExpressions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(579);
    primaryExpression(0);
    setState(584);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NeoBasicParser::COMMA) {
      setState(580);
      match(NeoBasicParser::COMMA);
      setState(581);
      primaryExpression(0);
      setState(586);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

NeoBasicParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::PrimaryExpressionContext* NeoBasicParser::ExpressionContext::primaryExpression() {
  return getRuleContext<NeoBasicParser::PrimaryExpressionContext>(0);
}

NeoBasicParser::PrefixUnaryOperatorContext* NeoBasicParser::ExpressionContext::prefixUnaryOperator() {
  return getRuleContext<NeoBasicParser::PrefixUnaryOperatorContext>(0);
}

std::vector<NeoBasicParser::ExpressionContext *> NeoBasicParser::ExpressionContext::expression() {
  return getRuleContexts<NeoBasicParser::ExpressionContext>();
}

NeoBasicParser::ExpressionContext* NeoBasicParser::ExpressionContext::expression(size_t i) {
  return getRuleContext<NeoBasicParser::ExpressionContext>(i);
}

NeoBasicParser::AssignmentExpressionContext* NeoBasicParser::ExpressionContext::assignmentExpression() {
  return getRuleContext<NeoBasicParser::AssignmentExpressionContext>(0);
}

NeoBasicParser::CondicionalExpressionContext* NeoBasicParser::ExpressionContext::condicionalExpression() {
  return getRuleContext<NeoBasicParser::CondicionalExpressionContext>(0);
}

NeoBasicParser::BinaryExponentialOperatorContext* NeoBasicParser::ExpressionContext::binaryExponentialOperator() {
  return getRuleContext<NeoBasicParser::BinaryExponentialOperatorContext>(0);
}

NeoBasicParser::BinaryMultiplicativeOperatorContext* NeoBasicParser::ExpressionContext::binaryMultiplicativeOperator() {
  return getRuleContext<NeoBasicParser::BinaryMultiplicativeOperatorContext>(0);
}

NeoBasicParser::BinaryAdditiveOperatorContext* NeoBasicParser::ExpressionContext::binaryAdditiveOperator() {
  return getRuleContext<NeoBasicParser::BinaryAdditiveOperatorContext>(0);
}

NeoBasicParser::BitShiftOperatorContext* NeoBasicParser::ExpressionContext::bitShiftOperator() {
  return getRuleContext<NeoBasicParser::BitShiftOperatorContext>(0);
}

NeoBasicParser::BitConjunctionOperatorContext* NeoBasicParser::ExpressionContext::bitConjunctionOperator() {
  return getRuleContext<NeoBasicParser::BitConjunctionOperatorContext>(0);
}

NeoBasicParser::BitExclusiveDisjunctionOperatorContext* NeoBasicParser::ExpressionContext::bitExclusiveDisjunctionOperator() {
  return getRuleContext<NeoBasicParser::BitExclusiveDisjunctionOperatorContext>(0);
}

NeoBasicParser::BitDisjunctionOperatorContext* NeoBasicParser::ExpressionContext::bitDisjunctionOperator() {
  return getRuleContext<NeoBasicParser::BitDisjunctionOperatorContext>(0);
}

NeoBasicParser::BinaryComparisonOperatorContext* NeoBasicParser::ExpressionContext::binaryComparisonOperator() {
  return getRuleContext<NeoBasicParser::BinaryComparisonOperatorContext>(0);
}

NeoBasicParser::BinaryRelationalOperatorContext* NeoBasicParser::ExpressionContext::binaryRelationalOperator() {
  return getRuleContext<NeoBasicParser::BinaryRelationalOperatorContext>(0);
}

NeoBasicParser::BinaryConditionalOperatorContext* NeoBasicParser::ExpressionContext::binaryConditionalOperator() {
  return getRuleContext<NeoBasicParser::BinaryConditionalOperatorContext>(0);
}

NeoBasicParser::BinaryConjunctionOperatorContext* NeoBasicParser::ExpressionContext::binaryConjunctionOperator() {
  return getRuleContext<NeoBasicParser::BinaryConjunctionOperatorContext>(0);
}

NeoBasicParser::BinaryExclusiveDisjunctionOperatorContext* NeoBasicParser::ExpressionContext::binaryExclusiveDisjunctionOperator() {
  return getRuleContext<NeoBasicParser::BinaryExclusiveDisjunctionOperatorContext>(0);
}

NeoBasicParser::BinaryDisjunctionOperatorContext* NeoBasicParser::ExpressionContext::binaryDisjunctionOperator() {
  return getRuleContext<NeoBasicParser::BinaryDisjunctionOperatorContext>(0);
}

NeoBasicParser::PosfixUnaryOperatorContext* NeoBasicParser::ExpressionContext::posfixUnaryOperator() {
  return getRuleContext<NeoBasicParser::PosfixUnaryOperatorContext>(0);
}

NeoBasicParser::BinaryCoalescingOperatorContext* NeoBasicParser::ExpressionContext::binaryCoalescingOperator() {
  return getRuleContext<NeoBasicParser::BinaryCoalescingOperatorContext>(0);
}


size_t NeoBasicParser::ExpressionContext::getRuleIndex() const {
  return NeoBasicParser::RuleExpression;
}

void NeoBasicParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void NeoBasicParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}


NeoBasicParser::ExpressionContext* NeoBasicParser::expression() {
   return expression(0);
}

NeoBasicParser::ExpressionContext* NeoBasicParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  NeoBasicParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  NeoBasicParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 174;
  enterRecursionRule(_localctx, 174, NeoBasicParser::RuleExpression, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(594);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
    case 1: {
      setState(588);
      primaryExpression(0);
      break;
    }

    case 2: {
      setState(589);
      prefixUnaryOperator();
      setState(590);
      expression(18);
      break;
    }

    case 3: {
      setState(592);
      assignmentExpression();
      break;
    }

    case 4: {
      setState(593);
      condicionalExpression();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(657);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(655);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(596);

          if (!(precpred(_ctx, 16))) throw FailedPredicateException(this, "precpred(_ctx, 16)");
          setState(597);
          binaryExponentialOperator();
          setState(598);
          expression(17);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(600);

          if (!(precpred(_ctx, 15))) throw FailedPredicateException(this, "precpred(_ctx, 15)");
          setState(601);
          binaryMultiplicativeOperator();
          setState(602);
          expression(16);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(604);

          if (!(precpred(_ctx, 14))) throw FailedPredicateException(this, "precpred(_ctx, 14)");
          setState(605);
          binaryAdditiveOperator();
          setState(606);
          expression(15);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(608);

          if (!(precpred(_ctx, 13))) throw FailedPredicateException(this, "precpred(_ctx, 13)");
          setState(609);
          bitShiftOperator();
          setState(610);
          expression(14);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(612);

          if (!(precpred(_ctx, 12))) throw FailedPredicateException(this, "precpred(_ctx, 12)");
          setState(613);
          bitConjunctionOperator();
          setState(614);
          expression(13);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(616);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(617);
          bitExclusiveDisjunctionOperator();
          setState(618);
          expression(12);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(620);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(621);
          bitDisjunctionOperator();
          setState(622);
          expression(11);
          break;
        }

        case 8: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(624);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(625);
          binaryComparisonOperator();
          setState(626);
          expression(10);
          break;
        }

        case 9: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(628);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(629);
          binaryRelationalOperator();
          setState(630);
          expression(9);
          break;
        }

        case 10: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(632);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(633);
          binaryConditionalOperator();
          setState(634);
          expression(8);
          break;
        }

        case 11: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(636);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(637);
          binaryConjunctionOperator();
          setState(638);
          expression(7);
          break;
        }

        case 12: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(640);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(641);
          binaryExclusiveDisjunctionOperator();
          setState(642);
          expression(6);
          break;
        }

        case 13: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(644);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(645);
          binaryDisjunctionOperator();
          setState(646);
          expression(5);
          break;
        }

        case 14: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(648);

          if (!(precpred(_ctx, 17))) throw FailedPredicateException(this, "precpred(_ctx, 17)");
          setState(649);
          posfixUnaryOperator();
          break;
        }

        case 15: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(650);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(651);
          binaryCoalescingOperator();
          setState(653);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx)) {
          case 1: {
            setState(652);
            expression(0);
            break;
          }

          default:
            break;
          }
          break;
        }

        default:
          break;
        } 
      }
      setState(659);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- PrimaryExpressionContext ------------------------------------------------------------------

NeoBasicParser::PrimaryExpressionContext::PrimaryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::OperandContext* NeoBasicParser::PrimaryExpressionContext::operand() {
  return getRuleContext<NeoBasicParser::OperandContext>(0);
}

NeoBasicParser::PrimaryExpressionContext* NeoBasicParser::PrimaryExpressionContext::primaryExpression() {
  return getRuleContext<NeoBasicParser::PrimaryExpressionContext>(0);
}

NeoBasicParser::ConverterContext* NeoBasicParser::PrimaryExpressionContext::converter() {
  return getRuleContext<NeoBasicParser::ConverterContext>(0);
}

NeoBasicParser::SelectorContext* NeoBasicParser::PrimaryExpressionContext::selector() {
  return getRuleContext<NeoBasicParser::SelectorContext>(0);
}

NeoBasicParser::IndexingContext* NeoBasicParser::PrimaryExpressionContext::indexing() {
  return getRuleContext<NeoBasicParser::IndexingContext>(0);
}

NeoBasicParser::SlicingContext* NeoBasicParser::PrimaryExpressionContext::slicing() {
  return getRuleContext<NeoBasicParser::SlicingContext>(0);
}

NeoBasicParser::ArgumentsContext* NeoBasicParser::PrimaryExpressionContext::arguments() {
  return getRuleContext<NeoBasicParser::ArgumentsContext>(0);
}


size_t NeoBasicParser::PrimaryExpressionContext::getRuleIndex() const {
  return NeoBasicParser::RulePrimaryExpression;
}

void NeoBasicParser::PrimaryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryExpression(this);
}

void NeoBasicParser::PrimaryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryExpression(this);
}


NeoBasicParser::PrimaryExpressionContext* NeoBasicParser::primaryExpression() {
   return primaryExpression(0);
}

NeoBasicParser::PrimaryExpressionContext* NeoBasicParser::primaryExpression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  NeoBasicParser::PrimaryExpressionContext *_localctx = _tracker.createInstance<PrimaryExpressionContext>(_ctx, parentState);
  NeoBasicParser::PrimaryExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 176;
  enterRecursionRule(_localctx, 176, NeoBasicParser::RulePrimaryExpression, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(661);
    operand();
    _ctx->stop = _input->LT(-1);
    setState(675);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(673);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<PrimaryExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RulePrimaryExpression);
          setState(663);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(664);
          converter();
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<PrimaryExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RulePrimaryExpression);
          setState(665);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(666);
          selector();
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<PrimaryExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RulePrimaryExpression);
          setState(667);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(668);
          indexing();
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<PrimaryExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RulePrimaryExpression);
          setState(669);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(670);
          slicing();
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<PrimaryExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RulePrimaryExpression);
          setState(671);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(672);
          arguments();
          break;
        }

        default:
          break;
        } 
      }
      setState(677);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- OperandContext ------------------------------------------------------------------

NeoBasicParser::OperandContext::OperandContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::LiteralContext* NeoBasicParser::OperandContext::literal() {
  return getRuleContext<NeoBasicParser::LiteralContext>(0);
}

NeoBasicParser::PredeclaredValueContext* NeoBasicParser::OperandContext::predeclaredValue() {
  return getRuleContext<NeoBasicParser::PredeclaredValueContext>(0);
}

NeoBasicParser::QualifiedIdentifierContext* NeoBasicParser::OperandContext::qualifiedIdentifier() {
  return getRuleContext<NeoBasicParser::QualifiedIdentifierContext>(0);
}

NeoBasicParser::ExpressionContext* NeoBasicParser::OperandContext::expression() {
  return getRuleContext<NeoBasicParser::ExpressionContext>(0);
}

NeoBasicParser::FactScopeContext* NeoBasicParser::OperandContext::factScope() {
  return getRuleContext<NeoBasicParser::FactScopeContext>(0);
}

tree::TerminalNode* NeoBasicParser::OperandContext::BACKTICK() {
  return getToken(NeoBasicParser::BACKTICK, 0);
}

NeoBasicParser::ExpressionsContext* NeoBasicParser::OperandContext::expressions() {
  return getRuleContext<NeoBasicParser::ExpressionsContext>(0);
}

tree::TerminalNode* NeoBasicParser::OperandContext::LEFT_PARENTHESIS() {
  return getToken(NeoBasicParser::LEFT_PARENTHESIS, 0);
}

tree::TerminalNode* NeoBasicParser::OperandContext::RIGHT_PARENTHESIS() {
  return getToken(NeoBasicParser::RIGHT_PARENTHESIS, 0);
}


size_t NeoBasicParser::OperandContext::getRuleIndex() const {
  return NeoBasicParser::RuleOperand;
}

void NeoBasicParser::OperandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOperand(this);
}

void NeoBasicParser::OperandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOperand(this);
}

NeoBasicParser::OperandContext* NeoBasicParser::operand() {
  OperandContext *_localctx = _tracker.createInstance<OperandContext>(_ctx, getState());
  enterRule(_localctx, 178, NeoBasicParser::RuleOperand);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(693);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 41, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(678);
      literal();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(679);
      predeclaredValue();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(680);
      qualifiedIdentifier();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(681);
      qualifiedIdentifier();
      setState(682);
      expression(0);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(684);
      factScope();
      setState(685);
      match(NeoBasicParser::BACKTICK);
      setState(686);
      qualifiedIdentifier();
      setState(687);
      expressions();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(689);
      match(NeoBasicParser::LEFT_PARENTHESIS);
      setState(690);
      expressions();
      setState(691);
      match(NeoBasicParser::RIGHT_PARENTHESIS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FactScopeContext ------------------------------------------------------------------

NeoBasicParser::FactScopeContext::FactScopeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::FactScopeContext::ALL() {
  return getToken(NeoBasicParser::ALL, 0);
}

tree::TerminalNode* NeoBasicParser::FactScopeContext::ANY() {
  return getToken(NeoBasicParser::ANY, 0);
}

tree::TerminalNode* NeoBasicParser::FactScopeContext::ONE() {
  return getToken(NeoBasicParser::ONE, 0);
}

tree::TerminalNode* NeoBasicParser::FactScopeContext::TWO() {
  return getToken(NeoBasicParser::TWO, 0);
}

tree::TerminalNode* NeoBasicParser::FactScopeContext::NIL() {
  return getToken(NeoBasicParser::NIL, 0);
}


size_t NeoBasicParser::FactScopeContext::getRuleIndex() const {
  return NeoBasicParser::RuleFactScope;
}

void NeoBasicParser::FactScopeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFactScope(this);
}

void NeoBasicParser::FactScopeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFactScope(this);
}

NeoBasicParser::FactScopeContext* NeoBasicParser::factScope() {
  FactScopeContext *_localctx = _tracker.createInstance<FactScopeContext>(_ctx, getState());
  enterRule(_localctx, 180, NeoBasicParser::RuleFactScope);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(695);
    _la = _input->LA(1);
    if (!(((((_la - 177) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 177)) & 31) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConverterContext ------------------------------------------------------------------

NeoBasicParser::ConverterContext::ConverterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::ConverterContext::SEMICOLON() {
  return getToken(NeoBasicParser::SEMICOLON, 0);
}

NeoBasicParser::QualifiedIdentifierContext* NeoBasicParser::ConverterContext::qualifiedIdentifier() {
  return getRuleContext<NeoBasicParser::QualifiedIdentifierContext>(0);
}


size_t NeoBasicParser::ConverterContext::getRuleIndex() const {
  return NeoBasicParser::RuleConverter;
}

void NeoBasicParser::ConverterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConverter(this);
}

void NeoBasicParser::ConverterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConverter(this);
}

NeoBasicParser::ConverterContext* NeoBasicParser::converter() {
  ConverterContext *_localctx = _tracker.createInstance<ConverterContext>(_ctx, getState());
  enterRule(_localctx, 182, NeoBasicParser::RuleConverter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(697);
    match(NeoBasicParser::SEMICOLON);
    setState(698);
    qualifiedIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectorContext ------------------------------------------------------------------

NeoBasicParser::SelectorContext::SelectorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::SelectorContext::DOT() {
  return getToken(NeoBasicParser::DOT, 0);
}

tree::TerminalNode* NeoBasicParser::SelectorContext::IDENTIFIER() {
  return getToken(NeoBasicParser::IDENTIFIER, 0);
}


size_t NeoBasicParser::SelectorContext::getRuleIndex() const {
  return NeoBasicParser::RuleSelector;
}

void NeoBasicParser::SelectorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelector(this);
}

void NeoBasicParser::SelectorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelector(this);
}

NeoBasicParser::SelectorContext* NeoBasicParser::selector() {
  SelectorContext *_localctx = _tracker.createInstance<SelectorContext>(_ctx, getState());
  enterRule(_localctx, 184, NeoBasicParser::RuleSelector);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(700);
    match(NeoBasicParser::DOT);
    setState(701);
    match(NeoBasicParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexingContext ------------------------------------------------------------------

NeoBasicParser::IndexingContext::IndexingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::IndexingContext::LEFT_BRACKET() {
  return getToken(NeoBasicParser::LEFT_BRACKET, 0);
}

NeoBasicParser::ExpressionsContext* NeoBasicParser::IndexingContext::expressions() {
  return getRuleContext<NeoBasicParser::ExpressionsContext>(0);
}

tree::TerminalNode* NeoBasicParser::IndexingContext::RIGHT_BRACKET() {
  return getToken(NeoBasicParser::RIGHT_BRACKET, 0);
}


size_t NeoBasicParser::IndexingContext::getRuleIndex() const {
  return NeoBasicParser::RuleIndexing;
}

void NeoBasicParser::IndexingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexing(this);
}

void NeoBasicParser::IndexingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexing(this);
}

NeoBasicParser::IndexingContext* NeoBasicParser::indexing() {
  IndexingContext *_localctx = _tracker.createInstance<IndexingContext>(_ctx, getState());
  enterRule(_localctx, 186, NeoBasicParser::RuleIndexing);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(703);
    match(NeoBasicParser::LEFT_BRACKET);
    setState(704);
    expressions();
    setState(705);
    match(NeoBasicParser::RIGHT_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SlicingContext ------------------------------------------------------------------

NeoBasicParser::SlicingContext::SlicingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::SlicingContext::LEFT_BRACKET() {
  return getToken(NeoBasicParser::LEFT_BRACKET, 0);
}

NeoBasicParser::SlicingRangeContext* NeoBasicParser::SlicingContext::slicingRange() {
  return getRuleContext<NeoBasicParser::SlicingRangeContext>(0);
}

tree::TerminalNode* NeoBasicParser::SlicingContext::RIGHT_BRACKET() {
  return getToken(NeoBasicParser::RIGHT_BRACKET, 0);
}


size_t NeoBasicParser::SlicingContext::getRuleIndex() const {
  return NeoBasicParser::RuleSlicing;
}

void NeoBasicParser::SlicingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSlicing(this);
}

void NeoBasicParser::SlicingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSlicing(this);
}

NeoBasicParser::SlicingContext* NeoBasicParser::slicing() {
  SlicingContext *_localctx = _tracker.createInstance<SlicingContext>(_ctx, getState());
  enterRule(_localctx, 188, NeoBasicParser::RuleSlicing);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(707);
    match(NeoBasicParser::LEFT_BRACKET);
    setState(708);
    slicingRange();
    setState(709);
    match(NeoBasicParser::RIGHT_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SlicingRangeContext ------------------------------------------------------------------

NeoBasicParser::SlicingRangeContext::SlicingRangeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::SlicingRangeContext::INTERVAL() {
  return getToken(NeoBasicParser::INTERVAL, 0);
}

std::vector<NeoBasicParser::ExpressionContext *> NeoBasicParser::SlicingRangeContext::expression() {
  return getRuleContexts<NeoBasicParser::ExpressionContext>();
}

NeoBasicParser::ExpressionContext* NeoBasicParser::SlicingRangeContext::expression(size_t i) {
  return getRuleContext<NeoBasicParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> NeoBasicParser::SlicingRangeContext::COLON() {
  return getTokens(NeoBasicParser::COLON);
}

tree::TerminalNode* NeoBasicParser::SlicingRangeContext::COLON(size_t i) {
  return getToken(NeoBasicParser::COLON, i);
}


size_t NeoBasicParser::SlicingRangeContext::getRuleIndex() const {
  return NeoBasicParser::RuleSlicingRange;
}

void NeoBasicParser::SlicingRangeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSlicingRange(this);
}

void NeoBasicParser::SlicingRangeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSlicingRange(this);
}

NeoBasicParser::SlicingRangeContext* NeoBasicParser::slicingRange() {
  SlicingRangeContext *_localctx = _tracker.createInstance<SlicingRangeContext>(_ctx, getState());
  enterRule(_localctx, 190, NeoBasicParser::RuleSlicingRange);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(740);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(712);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8779718459394) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 84)) & 364808131210903553) != 0) || ((((_la - 175) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 175)) & 767) != 0) || ((((_la - 274) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 274)) & 549751619583) != 0)) {
        setState(711);
        expression(0);
      }
      setState(714);
      match(NeoBasicParser::INTERVAL);
      setState(716);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8779718459394) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 84)) & 364808131210903553) != 0) || ((((_la - 175) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 175)) & 767) != 0) || ((((_la - 274) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 274)) & 549751619583) != 0)) {
        setState(715);
        expression(0);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(719);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8779718459394) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 84)) & 364808131210903553) != 0) || ((((_la - 175) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 175)) & 767) != 0) || ((((_la - 274) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 274)) & 549751619583) != 0)) {
        setState(718);
        expression(0);
      }
      setState(721);
      match(NeoBasicParser::INTERVAL);
      setState(723);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8779718459394) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 84)) & 364808131210903553) != 0) || ((((_la - 175) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 175)) & 767) != 0) || ((((_la - 274) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 274)) & 549751619583) != 0)) {
        setState(722);
        expression(0);
      }
      setState(725);
      match(NeoBasicParser::COLON);
      setState(726);
      expression(0);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(728);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8779718459394) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 84)) & 364808131210903553) != 0) || ((((_la - 175) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 175)) & 767) != 0) || ((((_la - 274) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 274)) & 549751619583) != 0)) {
        setState(727);
        expression(0);
      }
      setState(730);
      match(NeoBasicParser::INTERVAL);
      setState(732);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8779718459394) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 84)) & 364808131210903553) != 0) || ((((_la - 175) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 175)) & 767) != 0) || ((((_la - 274) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 274)) & 549751619583) != 0)) {
        setState(731);
        expression(0);
      }
      setState(734);
      match(NeoBasicParser::COLON);
      setState(736);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if ((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & 8779718459394) != 0) || ((((_la - 84) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 84)) & 364808131210903553) != 0) || ((((_la - 175) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 175)) & 767) != 0) || ((((_la - 274) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 274)) & 549751619583) != 0)) {
        setState(735);
        expression(0);
      }
      setState(738);
      match(NeoBasicParser::COLON);
      setState(739);
      expression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgumentsContext ------------------------------------------------------------------

NeoBasicParser::ArgumentsContext::ArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::ArgumentsContext::LEFT_PARENTHESIS() {
  return getToken(NeoBasicParser::LEFT_PARENTHESIS, 0);
}

NeoBasicParser::ExpressionsContext* NeoBasicParser::ArgumentsContext::expressions() {
  return getRuleContext<NeoBasicParser::ExpressionsContext>(0);
}

tree::TerminalNode* NeoBasicParser::ArgumentsContext::RIGHT_PARENTHESIS() {
  return getToken(NeoBasicParser::RIGHT_PARENTHESIS, 0);
}


size_t NeoBasicParser::ArgumentsContext::getRuleIndex() const {
  return NeoBasicParser::RuleArguments;
}

void NeoBasicParser::ArgumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArguments(this);
}

void NeoBasicParser::ArgumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArguments(this);
}

NeoBasicParser::ArgumentsContext* NeoBasicParser::arguments() {
  ArgumentsContext *_localctx = _tracker.createInstance<ArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 192, NeoBasicParser::RuleArguments);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(742);
    match(NeoBasicParser::LEFT_PARENTHESIS);
    setState(743);
    expressions();
    setState(744);
    match(NeoBasicParser::RIGHT_PARENTHESIS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentExpressionContext ------------------------------------------------------------------

NeoBasicParser::AssignmentExpressionContext::AssignmentExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::PrimaryExpressionContext* NeoBasicParser::AssignmentExpressionContext::primaryExpression() {
  return getRuleContext<NeoBasicParser::PrimaryExpressionContext>(0);
}

NeoBasicParser::AssignmentOperatorContext* NeoBasicParser::AssignmentExpressionContext::assignmentOperator() {
  return getRuleContext<NeoBasicParser::AssignmentOperatorContext>(0);
}

NeoBasicParser::ExpressionContext* NeoBasicParser::AssignmentExpressionContext::expression() {
  return getRuleContext<NeoBasicParser::ExpressionContext>(0);
}


size_t NeoBasicParser::AssignmentExpressionContext::getRuleIndex() const {
  return NeoBasicParser::RuleAssignmentExpression;
}

void NeoBasicParser::AssignmentExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentExpression(this);
}

void NeoBasicParser::AssignmentExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentExpression(this);
}

NeoBasicParser::AssignmentExpressionContext* NeoBasicParser::assignmentExpression() {
  AssignmentExpressionContext *_localctx = _tracker.createInstance<AssignmentExpressionContext>(_ctx, getState());
  enterRule(_localctx, 194, NeoBasicParser::RuleAssignmentExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(746);
    primaryExpression(0);
    setState(747);
    assignmentOperator();
    setState(748);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CondicionalExpressionContext ------------------------------------------------------------------

NeoBasicParser::CondicionalExpressionContext::CondicionalExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::GuardsExpressionContext* NeoBasicParser::CondicionalExpressionContext::guardsExpression() {
  return getRuleContext<NeoBasicParser::GuardsExpressionContext>(0);
}


size_t NeoBasicParser::CondicionalExpressionContext::getRuleIndex() const {
  return NeoBasicParser::RuleCondicionalExpression;
}

void NeoBasicParser::CondicionalExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCondicionalExpression(this);
}

void NeoBasicParser::CondicionalExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCondicionalExpression(this);
}

NeoBasicParser::CondicionalExpressionContext* NeoBasicParser::condicionalExpression() {
  CondicionalExpressionContext *_localctx = _tracker.createInstance<CondicionalExpressionContext>(_ctx, getState());
  enterRule(_localctx, 196, NeoBasicParser::RuleCondicionalExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(750);
    guardsExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GuardsExpressionContext ------------------------------------------------------------------

NeoBasicParser::GuardsExpressionContext::GuardsExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NeoBasicParser::GuardClauseContext *> NeoBasicParser::GuardsExpressionContext::guardClause() {
  return getRuleContexts<NeoBasicParser::GuardClauseContext>();
}

NeoBasicParser::GuardClauseContext* NeoBasicParser::GuardsExpressionContext::guardClause(size_t i) {
  return getRuleContext<NeoBasicParser::GuardClauseContext>(i);
}

NeoBasicParser::GuardDefaultContext* NeoBasicParser::GuardsExpressionContext::guardDefault() {
  return getRuleContext<NeoBasicParser::GuardDefaultContext>(0);
}


size_t NeoBasicParser::GuardsExpressionContext::getRuleIndex() const {
  return NeoBasicParser::RuleGuardsExpression;
}

void NeoBasicParser::GuardsExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGuardsExpression(this);
}

void NeoBasicParser::GuardsExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGuardsExpression(this);
}

NeoBasicParser::GuardsExpressionContext* NeoBasicParser::guardsExpression() {
  GuardsExpressionContext *_localctx = _tracker.createInstance<GuardsExpressionContext>(_ctx, getState());
  enterRule(_localctx, 198, NeoBasicParser::RuleGuardsExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(753); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(752);
              guardClause();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(755); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(758);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
    case 1: {
      setState(757);
      guardDefault();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GuardClauseContext ------------------------------------------------------------------

NeoBasicParser::GuardClauseContext::GuardClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::GuardClauseContext::PIPE() {
  return getToken(NeoBasicParser::PIPE, 0);
}

std::vector<NeoBasicParser::ExpressionContext *> NeoBasicParser::GuardClauseContext::expression() {
  return getRuleContexts<NeoBasicParser::ExpressionContext>();
}

NeoBasicParser::ExpressionContext* NeoBasicParser::GuardClauseContext::expression(size_t i) {
  return getRuleContext<NeoBasicParser::ExpressionContext>(i);
}

tree::TerminalNode* NeoBasicParser::GuardClauseContext::IMPLICIT_RETURN() {
  return getToken(NeoBasicParser::IMPLICIT_RETURN, 0);
}


size_t NeoBasicParser::GuardClauseContext::getRuleIndex() const {
  return NeoBasicParser::RuleGuardClause;
}

void NeoBasicParser::GuardClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGuardClause(this);
}

void NeoBasicParser::GuardClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGuardClause(this);
}

NeoBasicParser::GuardClauseContext* NeoBasicParser::guardClause() {
  GuardClauseContext *_localctx = _tracker.createInstance<GuardClauseContext>(_ctx, getState());
  enterRule(_localctx, 200, NeoBasicParser::RuleGuardClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(760);
    match(NeoBasicParser::PIPE);
    setState(761);
    expression(0);
    setState(762);
    match(NeoBasicParser::IMPLICIT_RETURN);
    setState(763);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GuardDefaultContext ------------------------------------------------------------------

NeoBasicParser::GuardDefaultContext::GuardDefaultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::GuardDefaultContext::PIPE() {
  return getToken(NeoBasicParser::PIPE, 0);
}

NeoBasicParser::ExpressionContext* NeoBasicParser::GuardDefaultContext::expression() {
  return getRuleContext<NeoBasicParser::ExpressionContext>(0);
}


size_t NeoBasicParser::GuardDefaultContext::getRuleIndex() const {
  return NeoBasicParser::RuleGuardDefault;
}

void NeoBasicParser::GuardDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGuardDefault(this);
}

void NeoBasicParser::GuardDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGuardDefault(this);
}

NeoBasicParser::GuardDefaultContext* NeoBasicParser::guardDefault() {
  GuardDefaultContext *_localctx = _tracker.createInstance<GuardDefaultContext>(_ctx, getState());
  enterRule(_localctx, 202, NeoBasicParser::RuleGuardDefault);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(765);
    match(NeoBasicParser::PIPE);
    setState(766);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

NeoBasicParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::EscalarLiteralContext* NeoBasicParser::LiteralContext::escalarLiteral() {
  return getRuleContext<NeoBasicParser::EscalarLiteralContext>(0);
}

NeoBasicParser::CompositeLiteralContext* NeoBasicParser::LiteralContext::compositeLiteral() {
  return getRuleContext<NeoBasicParser::CompositeLiteralContext>(0);
}

NeoBasicParser::OptionLiteralContext* NeoBasicParser::LiteralContext::optionLiteral() {
  return getRuleContext<NeoBasicParser::OptionLiteralContext>(0);
}


size_t NeoBasicParser::LiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleLiteral;
}

void NeoBasicParser::LiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral(this);
}

void NeoBasicParser::LiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral(this);
}

NeoBasicParser::LiteralContext* NeoBasicParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 204, NeoBasicParser::RuleLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(771);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::NUMBER_LIT:
      case NeoBasicParser::TIME_LIT:
      case NeoBasicParser::SEQUENCE_LIT:
      case NeoBasicParser::HEREDOC_LITERAL:
      case NeoBasicParser::CHAR_LIT:
      case NeoBasicParser::TRUE:
      case NeoBasicParser::FALSE:
      case NeoBasicParser::NONZERO:
      case NeoBasicParser::ZERO:
      case NeoBasicParser::MINVALUE:
      case NeoBasicParser::MAXVALUE:
      case NeoBasicParser::NAN:
      case NeoBasicParser::POSITIVEINFINITY:
      case NeoBasicParser::NEGATIVEINFINITY:
      case NeoBasicParser::LOCALDATE:
      case NeoBasicParser::LOCALDATETIME:
      case NeoBasicParser::OFFSETDATE:
      case NeoBasicParser::OFFSETDATETIME:
      case NeoBasicParser::ZONEDDATE:
      case NeoBasicParser::ZONEDDATETIME:
      case NeoBasicParser::TOMORROW:
      case NeoBasicParser::TODAY:
      case NeoBasicParser::NOW:
      case NeoBasicParser::YESTERDAY:
      case NeoBasicParser::EON:
      case NeoBasicParser::EPOCH:
      case NeoBasicParser::LETTER:
      case NeoBasicParser::DIGIT:
      case NeoBasicParser::PUNCTUATION:
      case NeoBasicParser::SYMBOL:
      case NeoBasicParser::SEPARATOR:
      case NeoBasicParser::NONPRINTABLE:
      case NeoBasicParser::NULL_:
      case NeoBasicParser::BLANK:
      case NeoBasicParser::NONBLANK: {
        enterOuterAlt(_localctx, 1);
        setState(768);
        escalarLiteral();
        break;
      }

      case NeoBasicParser::RANGE_LIT: {
        enterOuterAlt(_localctx, 2);
        setState(769);
        compositeLiteral();
        break;
      }

      case NeoBasicParser::OKAY:
      case NeoBasicParser::FAIL:
      case NeoBasicParser::SOME:
      case NeoBasicParser::NONE:
      case NeoBasicParser::YEA:
      case NeoBasicParser::NAY:
      case NeoBasicParser::DATA:
      case NeoBasicParser::EOT: {
        enterOuterAlt(_localctx, 3);
        setState(770);
        optionLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PredeclaredValueContext ------------------------------------------------------------------

NeoBasicParser::PredeclaredValueContext::PredeclaredValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::PredeclaredValueContext::THIS() {
  return getToken(NeoBasicParser::THIS, 0);
}

tree::TerminalNode* NeoBasicParser::PredeclaredValueContext::IOTA() {
  return getToken(NeoBasicParser::IOTA, 0);
}


size_t NeoBasicParser::PredeclaredValueContext::getRuleIndex() const {
  return NeoBasicParser::RulePredeclaredValue;
}

void NeoBasicParser::PredeclaredValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredeclaredValue(this);
}

void NeoBasicParser::PredeclaredValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredeclaredValue(this);
}

NeoBasicParser::PredeclaredValueContext* NeoBasicParser::predeclaredValue() {
  PredeclaredValueContext *_localctx = _tracker.createInstance<PredeclaredValueContext>(_ctx, getState());
  enterRule(_localctx, 206, NeoBasicParser::RulePredeclaredValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(773);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::THIS

    || _la == NeoBasicParser::IOTA)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueConstructContext ------------------------------------------------------------------

NeoBasicParser::ValueConstructContext::ValueConstructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::ValueConstructContext::LEFT_PARENTHESIS() {
  return getToken(NeoBasicParser::LEFT_PARENTHESIS, 0);
}

NeoBasicParser::ExpressionContext* NeoBasicParser::ValueConstructContext::expression() {
  return getRuleContext<NeoBasicParser::ExpressionContext>(0);
}

tree::TerminalNode* NeoBasicParser::ValueConstructContext::RIGHT_PARENTHESIS() {
  return getToken(NeoBasicParser::RIGHT_PARENTHESIS, 0);
}


size_t NeoBasicParser::ValueConstructContext::getRuleIndex() const {
  return NeoBasicParser::RuleValueConstruct;
}

void NeoBasicParser::ValueConstructContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValueConstruct(this);
}

void NeoBasicParser::ValueConstructContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValueConstruct(this);
}

NeoBasicParser::ValueConstructContext* NeoBasicParser::valueConstruct() {
  ValueConstructContext *_localctx = _tracker.createInstance<ValueConstructContext>(_ctx, getState());
  enterRule(_localctx, 208, NeoBasicParser::RuleValueConstruct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(775);
    match(NeoBasicParser::LEFT_PARENTHESIS);
    setState(776);
    expression(0);
    setState(777);
    match(NeoBasicParser::RIGHT_PARENTHESIS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EscalarLiteralContext ------------------------------------------------------------------

NeoBasicParser::EscalarLiteralContext::EscalarLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::BooleanLiteralContext* NeoBasicParser::EscalarLiteralContext::booleanLiteral() {
  return getRuleContext<NeoBasicParser::BooleanLiteralContext>(0);
}

NeoBasicParser::NumericLiteralContext* NeoBasicParser::EscalarLiteralContext::numericLiteral() {
  return getRuleContext<NeoBasicParser::NumericLiteralContext>(0);
}

NeoBasicParser::TemporalLiteralContext* NeoBasicParser::EscalarLiteralContext::temporalLiteral() {
  return getRuleContext<NeoBasicParser::TemporalLiteralContext>(0);
}

NeoBasicParser::CharacterLiteralContext* NeoBasicParser::EscalarLiteralContext::characterLiteral() {
  return getRuleContext<NeoBasicParser::CharacterLiteralContext>(0);
}

NeoBasicParser::SequenceLiteralContext* NeoBasicParser::EscalarLiteralContext::sequenceLiteral() {
  return getRuleContext<NeoBasicParser::SequenceLiteralContext>(0);
}


size_t NeoBasicParser::EscalarLiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleEscalarLiteral;
}

void NeoBasicParser::EscalarLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEscalarLiteral(this);
}

void NeoBasicParser::EscalarLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEscalarLiteral(this);
}

NeoBasicParser::EscalarLiteralContext* NeoBasicParser::escalarLiteral() {
  EscalarLiteralContext *_localctx = _tracker.createInstance<EscalarLiteralContext>(_ctx, getState());
  enterRule(_localctx, 210, NeoBasicParser::RuleEscalarLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(784);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::TRUE:
      case NeoBasicParser::FALSE: {
        enterOuterAlt(_localctx, 1);
        setState(779);
        booleanLiteral();
        break;
      }

      case NeoBasicParser::NUMBER_LIT:
      case NeoBasicParser::NONZERO:
      case NeoBasicParser::ZERO:
      case NeoBasicParser::MINVALUE:
      case NeoBasicParser::MAXVALUE:
      case NeoBasicParser::NAN:
      case NeoBasicParser::POSITIVEINFINITY:
      case NeoBasicParser::NEGATIVEINFINITY: {
        enterOuterAlt(_localctx, 2);
        setState(780);
        numericLiteral();
        break;
      }

      case NeoBasicParser::TIME_LIT:
      case NeoBasicParser::LOCALDATE:
      case NeoBasicParser::LOCALDATETIME:
      case NeoBasicParser::OFFSETDATE:
      case NeoBasicParser::OFFSETDATETIME:
      case NeoBasicParser::ZONEDDATE:
      case NeoBasicParser::ZONEDDATETIME:
      case NeoBasicParser::TOMORROW:
      case NeoBasicParser::TODAY:
      case NeoBasicParser::NOW:
      case NeoBasicParser::YESTERDAY:
      case NeoBasicParser::EON:
      case NeoBasicParser::EPOCH: {
        enterOuterAlt(_localctx, 3);
        setState(781);
        temporalLiteral();
        break;
      }

      case NeoBasicParser::CHAR_LIT:
      case NeoBasicParser::LETTER:
      case NeoBasicParser::DIGIT:
      case NeoBasicParser::PUNCTUATION:
      case NeoBasicParser::SYMBOL:
      case NeoBasicParser::SEPARATOR:
      case NeoBasicParser::NONPRINTABLE:
      case NeoBasicParser::NULL_: {
        enterOuterAlt(_localctx, 4);
        setState(782);
        characterLiteral();
        break;
      }

      case NeoBasicParser::SEQUENCE_LIT:
      case NeoBasicParser::HEREDOC_LITERAL:
      case NeoBasicParser::BLANK:
      case NeoBasicParser::NONBLANK: {
        enterOuterAlt(_localctx, 5);
        setState(783);
        sequenceLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BooleanLiteralContext ------------------------------------------------------------------

NeoBasicParser::BooleanLiteralContext::BooleanLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BooleanLiteralContext::TRUE() {
  return getToken(NeoBasicParser::TRUE, 0);
}

tree::TerminalNode* NeoBasicParser::BooleanLiteralContext::FALSE() {
  return getToken(NeoBasicParser::FALSE, 0);
}


size_t NeoBasicParser::BooleanLiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleBooleanLiteral;
}

void NeoBasicParser::BooleanLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBooleanLiteral(this);
}

void NeoBasicParser::BooleanLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBooleanLiteral(this);
}

NeoBasicParser::BooleanLiteralContext* NeoBasicParser::booleanLiteral() {
  BooleanLiteralContext *_localctx = _tracker.createInstance<BooleanLiteralContext>(_ctx, getState());
  enterRule(_localctx, 212, NeoBasicParser::RuleBooleanLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(786);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::TRUE

    || _la == NeoBasicParser::FALSE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericLiteralContext ------------------------------------------------------------------

NeoBasicParser::NumericLiteralContext::NumericLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::NumericLiteralContext::NUMBER_LIT() {
  return getToken(NeoBasicParser::NUMBER_LIT, 0);
}

tree::TerminalNode* NeoBasicParser::NumericLiteralContext::NONZERO() {
  return getToken(NeoBasicParser::NONZERO, 0);
}

NeoBasicParser::ValueConstructContext* NeoBasicParser::NumericLiteralContext::valueConstruct() {
  return getRuleContext<NeoBasicParser::ValueConstructContext>(0);
}

tree::TerminalNode* NeoBasicParser::NumericLiteralContext::ZERO() {
  return getToken(NeoBasicParser::ZERO, 0);
}

tree::TerminalNode* NeoBasicParser::NumericLiteralContext::MINVALUE() {
  return getToken(NeoBasicParser::MINVALUE, 0);
}

tree::TerminalNode* NeoBasicParser::NumericLiteralContext::MAXVALUE() {
  return getToken(NeoBasicParser::MAXVALUE, 0);
}

tree::TerminalNode* NeoBasicParser::NumericLiteralContext::NAN() {
  return getToken(NeoBasicParser::NAN, 0);
}

tree::TerminalNode* NeoBasicParser::NumericLiteralContext::POSITIVEINFINITY() {
  return getToken(NeoBasicParser::POSITIVEINFINITY, 0);
}

tree::TerminalNode* NeoBasicParser::NumericLiteralContext::NEGATIVEINFINITY() {
  return getToken(NeoBasicParser::NEGATIVEINFINITY, 0);
}


size_t NeoBasicParser::NumericLiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleNumericLiteral;
}

void NeoBasicParser::NumericLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericLiteral(this);
}

void NeoBasicParser::NumericLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericLiteral(this);
}

NeoBasicParser::NumericLiteralContext* NeoBasicParser::numericLiteral() {
  NumericLiteralContext *_localctx = _tracker.createInstance<NumericLiteralContext>(_ctx, getState());
  enterRule(_localctx, 214, NeoBasicParser::RuleNumericLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(797);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::NUMBER_LIT: {
        enterOuterAlt(_localctx, 1);
        setState(788);
        match(NeoBasicParser::NUMBER_LIT);
        break;
      }

      case NeoBasicParser::NONZERO: {
        enterOuterAlt(_localctx, 2);
        setState(789);
        match(NeoBasicParser::NONZERO);
        setState(790);
        valueConstruct();
        break;
      }

      case NeoBasicParser::ZERO: {
        enterOuterAlt(_localctx, 3);
        setState(791);
        match(NeoBasicParser::ZERO);
        break;
      }

      case NeoBasicParser::MINVALUE: {
        enterOuterAlt(_localctx, 4);
        setState(792);
        match(NeoBasicParser::MINVALUE);
        break;
      }

      case NeoBasicParser::MAXVALUE: {
        enterOuterAlt(_localctx, 5);
        setState(793);
        match(NeoBasicParser::MAXVALUE);
        break;
      }

      case NeoBasicParser::NAN: {
        enterOuterAlt(_localctx, 6);
        setState(794);
        match(NeoBasicParser::NAN);
        break;
      }

      case NeoBasicParser::POSITIVEINFINITY: {
        enterOuterAlt(_localctx, 7);
        setState(795);
        match(NeoBasicParser::POSITIVEINFINITY);
        break;
      }

      case NeoBasicParser::NEGATIVEINFINITY: {
        enterOuterAlt(_localctx, 8);
        setState(796);
        match(NeoBasicParser::NEGATIVEINFINITY);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TemporalLiteralContext ------------------------------------------------------------------

NeoBasicParser::TemporalLiteralContext::TemporalLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::TIME_LIT() {
  return getToken(NeoBasicParser::TIME_LIT, 0);
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::LOCALDATE() {
  return getToken(NeoBasicParser::LOCALDATE, 0);
}

NeoBasicParser::ValueConstructContext* NeoBasicParser::TemporalLiteralContext::valueConstruct() {
  return getRuleContext<NeoBasicParser::ValueConstructContext>(0);
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::LOCALDATETIME() {
  return getToken(NeoBasicParser::LOCALDATETIME, 0);
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::OFFSETDATE() {
  return getToken(NeoBasicParser::OFFSETDATE, 0);
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::OFFSETDATETIME() {
  return getToken(NeoBasicParser::OFFSETDATETIME, 0);
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::ZONEDDATE() {
  return getToken(NeoBasicParser::ZONEDDATE, 0);
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::ZONEDDATETIME() {
  return getToken(NeoBasicParser::ZONEDDATETIME, 0);
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::TOMORROW() {
  return getToken(NeoBasicParser::TOMORROW, 0);
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::TODAY() {
  return getToken(NeoBasicParser::TODAY, 0);
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::NOW() {
  return getToken(NeoBasicParser::NOW, 0);
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::YESTERDAY() {
  return getToken(NeoBasicParser::YESTERDAY, 0);
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::EON() {
  return getToken(NeoBasicParser::EON, 0);
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::EPOCH() {
  return getToken(NeoBasicParser::EPOCH, 0);
}


size_t NeoBasicParser::TemporalLiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleTemporalLiteral;
}

void NeoBasicParser::TemporalLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemporalLiteral(this);
}

void NeoBasicParser::TemporalLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemporalLiteral(this);
}

NeoBasicParser::TemporalLiteralContext* NeoBasicParser::temporalLiteral() {
  TemporalLiteralContext *_localctx = _tracker.createInstance<TemporalLiteralContext>(_ctx, getState());
  enterRule(_localctx, 216, NeoBasicParser::RuleTemporalLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(830);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::TIME_LIT: {
        enterOuterAlt(_localctx, 1);
        setState(799);
        match(NeoBasicParser::TIME_LIT);
        break;
      }

      case NeoBasicParser::LOCALDATE: {
        enterOuterAlt(_localctx, 2);
        setState(800);
        match(NeoBasicParser::LOCALDATE);
        setState(802);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 55, _ctx)) {
        case 1: {
          setState(801);
          valueConstruct();
          break;
        }

        default:
          break;
        }
        break;
      }

      case NeoBasicParser::LOCALDATETIME: {
        enterOuterAlt(_localctx, 3);
        setState(804);
        match(NeoBasicParser::LOCALDATETIME);
        setState(806);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 56, _ctx)) {
        case 1: {
          setState(805);
          valueConstruct();
          break;
        }

        default:
          break;
        }
        break;
      }

      case NeoBasicParser::OFFSETDATE: {
        enterOuterAlt(_localctx, 4);
        setState(808);
        match(NeoBasicParser::OFFSETDATE);
        setState(810);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx)) {
        case 1: {
          setState(809);
          valueConstruct();
          break;
        }

        default:
          break;
        }
        break;
      }

      case NeoBasicParser::OFFSETDATETIME: {
        enterOuterAlt(_localctx, 5);
        setState(812);
        match(NeoBasicParser::OFFSETDATETIME);
        setState(814);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx)) {
        case 1: {
          setState(813);
          valueConstruct();
          break;
        }

        default:
          break;
        }
        break;
      }

      case NeoBasicParser::ZONEDDATE: {
        enterOuterAlt(_localctx, 6);
        setState(816);
        match(NeoBasicParser::ZONEDDATE);
        setState(818);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx)) {
        case 1: {
          setState(817);
          valueConstruct();
          break;
        }

        default:
          break;
        }
        break;
      }

      case NeoBasicParser::ZONEDDATETIME: {
        enterOuterAlt(_localctx, 7);
        setState(820);
        match(NeoBasicParser::ZONEDDATETIME);
        setState(822);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx)) {
        case 1: {
          setState(821);
          valueConstruct();
          break;
        }

        default:
          break;
        }
        break;
      }

      case NeoBasicParser::TOMORROW: {
        enterOuterAlt(_localctx, 8);
        setState(824);
        match(NeoBasicParser::TOMORROW);
        break;
      }

      case NeoBasicParser::TODAY: {
        enterOuterAlt(_localctx, 9);
        setState(825);
        match(NeoBasicParser::TODAY);
        break;
      }

      case NeoBasicParser::NOW: {
        enterOuterAlt(_localctx, 10);
        setState(826);
        match(NeoBasicParser::NOW);
        break;
      }

      case NeoBasicParser::YESTERDAY: {
        enterOuterAlt(_localctx, 11);
        setState(827);
        match(NeoBasicParser::YESTERDAY);
        break;
      }

      case NeoBasicParser::EON: {
        enterOuterAlt(_localctx, 12);
        setState(828);
        match(NeoBasicParser::EON);
        break;
      }

      case NeoBasicParser::EPOCH: {
        enterOuterAlt(_localctx, 13);
        setState(829);
        match(NeoBasicParser::EPOCH);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharacterLiteralContext ------------------------------------------------------------------

NeoBasicParser::CharacterLiteralContext::CharacterLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::CharacterLiteralContext::CHAR_LIT() {
  return getToken(NeoBasicParser::CHAR_LIT, 0);
}

tree::TerminalNode* NeoBasicParser::CharacterLiteralContext::LETTER() {
  return getToken(NeoBasicParser::LETTER, 0);
}

NeoBasicParser::ValueConstructContext* NeoBasicParser::CharacterLiteralContext::valueConstruct() {
  return getRuleContext<NeoBasicParser::ValueConstructContext>(0);
}

tree::TerminalNode* NeoBasicParser::CharacterLiteralContext::DIGIT() {
  return getToken(NeoBasicParser::DIGIT, 0);
}

tree::TerminalNode* NeoBasicParser::CharacterLiteralContext::PUNCTUATION() {
  return getToken(NeoBasicParser::PUNCTUATION, 0);
}

tree::TerminalNode* NeoBasicParser::CharacterLiteralContext::SYMBOL() {
  return getToken(NeoBasicParser::SYMBOL, 0);
}

tree::TerminalNode* NeoBasicParser::CharacterLiteralContext::SEPARATOR() {
  return getToken(NeoBasicParser::SEPARATOR, 0);
}

tree::TerminalNode* NeoBasicParser::CharacterLiteralContext::NONPRINTABLE() {
  return getToken(NeoBasicParser::NONPRINTABLE, 0);
}

tree::TerminalNode* NeoBasicParser::CharacterLiteralContext::NULL_() {
  return getToken(NeoBasicParser::NULL_, 0);
}


size_t NeoBasicParser::CharacterLiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleCharacterLiteral;
}

void NeoBasicParser::CharacterLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharacterLiteral(this);
}

void NeoBasicParser::CharacterLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharacterLiteral(this);
}

NeoBasicParser::CharacterLiteralContext* NeoBasicParser::characterLiteral() {
  CharacterLiteralContext *_localctx = _tracker.createInstance<CharacterLiteralContext>(_ctx, getState());
  enterRule(_localctx, 218, NeoBasicParser::RuleCharacterLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(846);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::CHAR_LIT: {
        enterOuterAlt(_localctx, 1);
        setState(832);
        match(NeoBasicParser::CHAR_LIT);
        break;
      }

      case NeoBasicParser::LETTER: {
        enterOuterAlt(_localctx, 2);
        setState(833);
        match(NeoBasicParser::LETTER);
        setState(834);
        valueConstruct();
        break;
      }

      case NeoBasicParser::DIGIT: {
        enterOuterAlt(_localctx, 3);
        setState(835);
        match(NeoBasicParser::DIGIT);
        setState(836);
        valueConstruct();
        break;
      }

      case NeoBasicParser::PUNCTUATION: {
        enterOuterAlt(_localctx, 4);
        setState(837);
        match(NeoBasicParser::PUNCTUATION);
        setState(838);
        valueConstruct();
        break;
      }

      case NeoBasicParser::SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(839);
        match(NeoBasicParser::SYMBOL);
        setState(840);
        valueConstruct();
        break;
      }

      case NeoBasicParser::SEPARATOR: {
        enterOuterAlt(_localctx, 6);
        setState(841);
        match(NeoBasicParser::SEPARATOR);
        setState(842);
        valueConstruct();
        break;
      }

      case NeoBasicParser::NONPRINTABLE: {
        enterOuterAlt(_localctx, 7);
        setState(843);
        match(NeoBasicParser::NONPRINTABLE);
        setState(844);
        valueConstruct();
        break;
      }

      case NeoBasicParser::NULL_: {
        enterOuterAlt(_localctx, 8);
        setState(845);
        match(NeoBasicParser::NULL_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SequenceLiteralContext ------------------------------------------------------------------

NeoBasicParser::SequenceLiteralContext::SequenceLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::SequenceLiteralContext::HEREDOC_LITERAL() {
  return getToken(NeoBasicParser::HEREDOC_LITERAL, 0);
}

tree::TerminalNode* NeoBasicParser::SequenceLiteralContext::SEQUENCE_LIT() {
  return getToken(NeoBasicParser::SEQUENCE_LIT, 0);
}

tree::TerminalNode* NeoBasicParser::SequenceLiteralContext::NONBLANK() {
  return getToken(NeoBasicParser::NONBLANK, 0);
}

NeoBasicParser::ValueConstructContext* NeoBasicParser::SequenceLiteralContext::valueConstruct() {
  return getRuleContext<NeoBasicParser::ValueConstructContext>(0);
}

tree::TerminalNode* NeoBasicParser::SequenceLiteralContext::BLANK() {
  return getToken(NeoBasicParser::BLANK, 0);
}


size_t NeoBasicParser::SequenceLiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleSequenceLiteral;
}

void NeoBasicParser::SequenceLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSequenceLiteral(this);
}

void NeoBasicParser::SequenceLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSequenceLiteral(this);
}

NeoBasicParser::SequenceLiteralContext* NeoBasicParser::sequenceLiteral() {
  SequenceLiteralContext *_localctx = _tracker.createInstance<SequenceLiteralContext>(_ctx, getState());
  enterRule(_localctx, 220, NeoBasicParser::RuleSequenceLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(853);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::HEREDOC_LITERAL: {
        enterOuterAlt(_localctx, 1);
        setState(848);
        match(NeoBasicParser::HEREDOC_LITERAL);
        break;
      }

      case NeoBasicParser::SEQUENCE_LIT: {
        enterOuterAlt(_localctx, 2);
        setState(849);
        match(NeoBasicParser::SEQUENCE_LIT);
        break;
      }

      case NeoBasicParser::NONBLANK: {
        enterOuterAlt(_localctx, 3);
        setState(850);
        match(NeoBasicParser::NONBLANK);
        setState(851);
        valueConstruct();
        break;
      }

      case NeoBasicParser::BLANK: {
        enterOuterAlt(_localctx, 4);
        setState(852);
        match(NeoBasicParser::BLANK);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompositeLiteralContext ------------------------------------------------------------------

NeoBasicParser::CompositeLiteralContext::CompositeLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::CompositeLiteralContext::RANGE_LIT() {
  return getToken(NeoBasicParser::RANGE_LIT, 0);
}


size_t NeoBasicParser::CompositeLiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleCompositeLiteral;
}

void NeoBasicParser::CompositeLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompositeLiteral(this);
}

void NeoBasicParser::CompositeLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompositeLiteral(this);
}

NeoBasicParser::CompositeLiteralContext* NeoBasicParser::compositeLiteral() {
  CompositeLiteralContext *_localctx = _tracker.createInstance<CompositeLiteralContext>(_ctx, getState());
  enterRule(_localctx, 222, NeoBasicParser::RuleCompositeLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(855);
    match(NeoBasicParser::RANGE_LIT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionLiteralContext ------------------------------------------------------------------

NeoBasicParser::OptionLiteralContext::OptionLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::ResultLiteralContext* NeoBasicParser::OptionLiteralContext::resultLiteral() {
  return getRuleContext<NeoBasicParser::ResultLiteralContext>(0);
}

NeoBasicParser::MaybeLiteralContext* NeoBasicParser::OptionLiteralContext::maybeLiteral() {
  return getRuleContext<NeoBasicParser::MaybeLiteralContext>(0);
}

NeoBasicParser::EitherLiteralContext* NeoBasicParser::OptionLiteralContext::eitherLiteral() {
  return getRuleContext<NeoBasicParser::EitherLiteralContext>(0);
}

NeoBasicParser::StreamLiteralContext* NeoBasicParser::OptionLiteralContext::streamLiteral() {
  return getRuleContext<NeoBasicParser::StreamLiteralContext>(0);
}


size_t NeoBasicParser::OptionLiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleOptionLiteral;
}

void NeoBasicParser::OptionLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionLiteral(this);
}

void NeoBasicParser::OptionLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionLiteral(this);
}

NeoBasicParser::OptionLiteralContext* NeoBasicParser::optionLiteral() {
  OptionLiteralContext *_localctx = _tracker.createInstance<OptionLiteralContext>(_ctx, getState());
  enterRule(_localctx, 224, NeoBasicParser::RuleOptionLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(861);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::OKAY:
      case NeoBasicParser::FAIL: {
        enterOuterAlt(_localctx, 1);
        setState(857);
        resultLiteral();
        break;
      }

      case NeoBasicParser::SOME:
      case NeoBasicParser::NONE: {
        enterOuterAlt(_localctx, 2);
        setState(858);
        maybeLiteral();
        break;
      }

      case NeoBasicParser::YEA:
      case NeoBasicParser::NAY: {
        enterOuterAlt(_localctx, 3);
        setState(859);
        eitherLiteral();
        break;
      }

      case NeoBasicParser::DATA:
      case NeoBasicParser::EOT: {
        enterOuterAlt(_localctx, 4);
        setState(860);
        streamLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResultLiteralContext ------------------------------------------------------------------

NeoBasicParser::ResultLiteralContext::ResultLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::ResultLiteralContext::OKAY() {
  return getToken(NeoBasicParser::OKAY, 0);
}

NeoBasicParser::ValueConstructContext* NeoBasicParser::ResultLiteralContext::valueConstruct() {
  return getRuleContext<NeoBasicParser::ValueConstructContext>(0);
}

tree::TerminalNode* NeoBasicParser::ResultLiteralContext::FAIL() {
  return getToken(NeoBasicParser::FAIL, 0);
}


size_t NeoBasicParser::ResultLiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleResultLiteral;
}

void NeoBasicParser::ResultLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResultLiteral(this);
}

void NeoBasicParser::ResultLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResultLiteral(this);
}

NeoBasicParser::ResultLiteralContext* NeoBasicParser::resultLiteral() {
  ResultLiteralContext *_localctx = _tracker.createInstance<ResultLiteralContext>(_ctx, getState());
  enterRule(_localctx, 226, NeoBasicParser::RuleResultLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(867);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::OKAY: {
        enterOuterAlt(_localctx, 1);
        setState(863);
        match(NeoBasicParser::OKAY);
        setState(864);
        valueConstruct();
        break;
      }

      case NeoBasicParser::FAIL: {
        enterOuterAlt(_localctx, 2);
        setState(865);
        match(NeoBasicParser::FAIL);
        setState(866);
        valueConstruct();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MaybeLiteralContext ------------------------------------------------------------------

NeoBasicParser::MaybeLiteralContext::MaybeLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::MaybeLiteralContext::SOME() {
  return getToken(NeoBasicParser::SOME, 0);
}

NeoBasicParser::ValueConstructContext* NeoBasicParser::MaybeLiteralContext::valueConstruct() {
  return getRuleContext<NeoBasicParser::ValueConstructContext>(0);
}

tree::TerminalNode* NeoBasicParser::MaybeLiteralContext::NONE() {
  return getToken(NeoBasicParser::NONE, 0);
}


size_t NeoBasicParser::MaybeLiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleMaybeLiteral;
}

void NeoBasicParser::MaybeLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMaybeLiteral(this);
}

void NeoBasicParser::MaybeLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMaybeLiteral(this);
}

NeoBasicParser::MaybeLiteralContext* NeoBasicParser::maybeLiteral() {
  MaybeLiteralContext *_localctx = _tracker.createInstance<MaybeLiteralContext>(_ctx, getState());
  enterRule(_localctx, 228, NeoBasicParser::RuleMaybeLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(872);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::SOME: {
        enterOuterAlt(_localctx, 1);
        setState(869);
        match(NeoBasicParser::SOME);
        setState(870);
        valueConstruct();
        break;
      }

      case NeoBasicParser::NONE: {
        enterOuterAlt(_localctx, 2);
        setState(871);
        match(NeoBasicParser::NONE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EitherLiteralContext ------------------------------------------------------------------

NeoBasicParser::EitherLiteralContext::EitherLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::EitherLiteralContext::YEA() {
  return getToken(NeoBasicParser::YEA, 0);
}

NeoBasicParser::ValueConstructContext* NeoBasicParser::EitherLiteralContext::valueConstruct() {
  return getRuleContext<NeoBasicParser::ValueConstructContext>(0);
}

tree::TerminalNode* NeoBasicParser::EitherLiteralContext::NAY() {
  return getToken(NeoBasicParser::NAY, 0);
}


size_t NeoBasicParser::EitherLiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleEitherLiteral;
}

void NeoBasicParser::EitherLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEitherLiteral(this);
}

void NeoBasicParser::EitherLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEitherLiteral(this);
}

NeoBasicParser::EitherLiteralContext* NeoBasicParser::eitherLiteral() {
  EitherLiteralContext *_localctx = _tracker.createInstance<EitherLiteralContext>(_ctx, getState());
  enterRule(_localctx, 230, NeoBasicParser::RuleEitherLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(878);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::YEA: {
        enterOuterAlt(_localctx, 1);
        setState(874);
        match(NeoBasicParser::YEA);
        setState(875);
        valueConstruct();
        break;
      }

      case NeoBasicParser::NAY: {
        enterOuterAlt(_localctx, 2);
        setState(876);
        match(NeoBasicParser::NAY);
        setState(877);
        valueConstruct();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StreamLiteralContext ------------------------------------------------------------------

NeoBasicParser::StreamLiteralContext::StreamLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::StreamLiteralContext::DATA() {
  return getToken(NeoBasicParser::DATA, 0);
}

NeoBasicParser::ValueConstructContext* NeoBasicParser::StreamLiteralContext::valueConstruct() {
  return getRuleContext<NeoBasicParser::ValueConstructContext>(0);
}

tree::TerminalNode* NeoBasicParser::StreamLiteralContext::EOT() {
  return getToken(NeoBasicParser::EOT, 0);
}


size_t NeoBasicParser::StreamLiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleStreamLiteral;
}

void NeoBasicParser::StreamLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStreamLiteral(this);
}

void NeoBasicParser::StreamLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStreamLiteral(this);
}

NeoBasicParser::StreamLiteralContext* NeoBasicParser::streamLiteral() {
  StreamLiteralContext *_localctx = _tracker.createInstance<StreamLiteralContext>(_ctx, getState());
  enterRule(_localctx, 232, NeoBasicParser::RuleStreamLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(883);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::DATA: {
        enterOuterAlt(_localctx, 1);
        setState(880);
        match(NeoBasicParser::DATA);
        setState(881);
        valueConstruct();
        break;
      }

      case NeoBasicParser::EOT: {
        enterOuterAlt(_localctx, 2);
        setState(882);
        match(NeoBasicParser::EOT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool NeoBasicParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 87: return expressionSempred(antlrcpp::downCast<ExpressionContext *>(context), predicateIndex);
    case 88: return primaryExpressionSempred(antlrcpp::downCast<PrimaryExpressionContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool NeoBasicParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 16);
    case 1: return precpred(_ctx, 15);
    case 2: return precpred(_ctx, 14);
    case 3: return precpred(_ctx, 13);
    case 4: return precpred(_ctx, 12);
    case 5: return precpred(_ctx, 11);
    case 6: return precpred(_ctx, 10);
    case 7: return precpred(_ctx, 9);
    case 8: return precpred(_ctx, 8);
    case 9: return precpred(_ctx, 7);
    case 10: return precpred(_ctx, 6);
    case 11: return precpred(_ctx, 5);
    case 12: return precpred(_ctx, 4);
    case 13: return precpred(_ctx, 17);
    case 14: return precpred(_ctx, 3);

  default:
    break;
  }
  return true;
}

bool NeoBasicParser::primaryExpressionSempred(PrimaryExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 15: return precpred(_ctx, 5);
    case 16: return precpred(_ctx, 4);
    case 17: return precpred(_ctx, 3);
    case 18: return precpred(_ctx, 2);
    case 19: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

void NeoBasicParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  neobasicparserParserInitialize();
#else
  ::antlr4::internal::call_once(neobasicparserParserOnceFlag, neobasicparserParserInitialize);
#endif
}
