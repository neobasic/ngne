
// Generated from NeoBasicParser.g4 by ANTLR 4.13.2


#include "NeoBasicParserListener.h"

#include "NeoBasicParser.h"


using namespace antlrcpp;
using namespace parser;

using namespace antlr4;

namespace {

struct NeoBasicParserStaticData final {
  NeoBasicParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  NeoBasicParserStaticData(const NeoBasicParserStaticData&) = delete;
  NeoBasicParserStaticData(NeoBasicParserStaticData&&) = delete;
  NeoBasicParserStaticData& operator=(const NeoBasicParserStaticData&) = delete;
  NeoBasicParserStaticData& operator=(NeoBasicParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag neobasicparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
std::unique_ptr<NeoBasicParserStaticData> neobasicparserParserStaticData = nullptr;

void neobasicparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (neobasicparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(neobasicparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<NeoBasicParserStaticData>(
    std::vector<std::string>{
      "neoProgram", "oneLinerProgram", "scriptFileProgram", "instructionSentence", 
      "directive", "interpreterDirective", "pragmaDirective", "canaryTestingDirective", 
      "declaration", "accessSpecifier", "constSentence", "constSpecifier", 
      "constClause", "constDeclare", "constDeclareSingle", "constDeclareMultiple", 
      "constDeclareParallel", "valSentence", "valSpecifier", "valClause", 
      "valDeclare", "valDeclareSingle", "valDeclareMultiple", "valDeclareParallel", 
      "varSentence", "varSpecifier", "varClause", "varDeclare", "varDeclareSingle", 
      "varDeclareMultiple", "varDeclareParallel", "statement", "simpleStatement", 
      "emptyStatement", "expressionStatement", "assignmentStatement", "assignmentSingle", 
      "assignmentMultiple", "assignmentParallel", "compoundStatement", "conditionalStatement", 
      "ifStatement", "ifThenClause", "unlessStatement", "unlessClause", 
      "prefixUnaryOperator", "posfixUnaryOperator", "unaryArithmeticOperator", 
      "unaryBitwiseOperator", "unaryLogicalOperator", "unarySpreadOperator", 
      "unarySortOperator", "unaryCloneOperator", "unaryMetaOperator", "binaryExponentialOperator", 
      "binaryMultiplicativeOperator", "binaryAdditiveOperator", "bitShiftOperator", 
      "bitConjunctionOperator", "bitExclusiveDisjunctionOperator", "bitDisjunctionOperator", 
      "binaryComparisonOperator", "binaryRelationalOperator", "binaryConditionalOperator", 
      "binaryConjunctionOperator", "binaryExclusiveDisjunctionOperator", 
      "binaryDisjunctionOperator", "binaryCoalescingOperator", "assignmentOperator", 
      "singleAssignmentOperator", "multipleAssignmentOperator", "compoundAssignmentOperator", 
      "labelIdentifier", "symbolIdentifier", "qualifiedIdentifier", "identifiers", 
      "symbolIdentifiers", "qualifiedIdentifiers", "type", "nativeType", 
      "posfixTypeWrapper", "escalarType", "booleanType", "numericType", 
      "numericDigit", "numericNatural", "numericInteger", "numericReal", 
      "numericDecimal", "numericRatio", "numericComplex", "numericQuaternion", 
      "temporalType", "characterType", "sequenceType", "compositeType", 
      "metaType", "expressions", "juxtapositionExpressions", "primaryExpressions", 
      "expression", "primaryExpression", "operand", "factScope", "converter", 
      "selector", "indexing", "slicing", "slicingRange", "rangeExpression", 
      "arguments", "assignmentExpression", "condicionalExpression", "guardsExpression", 
      "guardClause", "guardDefault", "macroExpression", "macroCall", "literal", 
      "predeclaredValue", "valueConstruct", "escalarLiteral", "booleanLiteral", 
      "numericLiteral", "temporalLiteral", "characterLiteral", "sequenceLiteral", 
      "optionLiteral", "resultLiteral", "maybeLiteral", "eitherLiteral", 
      "streamLiteral", "loggingLevel"
    },
    std::vector<std::string>{
      "", "'('", "')'", "'['", "']'", "'{'", "'}'", "'<'", "'>'", "'.'", 
      "','", "';'", "':'", "'!'", "'\\u003F'", "'''", "'\"'", "'`'", "'@'", 
      "'#'", "'$'", "'&'", "'*'", "'/'", "'\\u00F7'", "'%'", "'\\'", "'~'", 
      "'^'", "'|'", "'_'", "'='", "'+'", "'-'", "'...'", "'(\\'", "'[['", 
      "']]'", "'{{'", "'}}'", "'<<'", "'>>'", "'!!'", "'\\u003F\\u003F'", 
      "'::'", "';;'", "'~='", "'++'", "'--'", "'**'", "'*/'", "'*!'", "'~~'", 
      "'==='", "'^^'", "'%%'", "'%/'", "'%*'", "'%+'", "'%-'", "'%^'", "'&~'", 
      "'>>>'", "'\\u003F%'", "'!%'", "'\\u003F:'", "'<=>'", "'=='", "'!='", 
      "'~=='", "'~!='", "'<='", "'>='", "'!\\u003F'", "'<-'", "'<<-'", "'<|'", 
      "':='", "'+='", "'-='", "'*='", "'/='", "'\\u00F7='", "'%%='", "'%='", 
      "'**='", "'*/='", "'%/='", "'%*='", "'%+='", "'%-='", "'%^\\u207C'", 
      "'&='", "'|='", "'^='", "'&^='", "'<<='", "'>>='", "'>>>='", "'\\u003F\\u003F='", 
      "'..'", "'>..'", "'..<'", "'>..<'", "", "", "", "'<>'", "'->'", "':-'", 
      "'=>'", "'=>>'", "'|>'", "'&&'", "'\\u003F&'", "'!&'", "'|&'", "'&>'", 
      "'&>>'", "'&1>'", "'&1>>'", "'&2>'", "'&2>>'", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
      "", "", "", "'L'", "", "", "'a'", "", "", "", "", "", "", "", "", 
      "", "", "", "", "", "", "", "", "", "", "", "", "'f'", "'s'", "'#!'", 
      "'#\\u003F'", "'#$'", "", "", "", "", "", "", "", "", "", "'\\uEFBBBF'", 
      "'\\uFEFF'", "'\\u0000FEFF'", "", "", "'module'", "'algorithm'", "'notabene'", 
      "'use'", "'as'", "'of'", "'include'", "'interface'", "'extern'", "'rproc'", 
      "'foreign'", "'const'", "'val'", "'var'", "'func'", "'feed'", "'fmap'", 
      "'sub'", "'type'", "'dim'", "'fact'", "'enum'", "'struct'", "'proto'", 
      "'trait'", "'class'", "'get'", "'set'", "'oper'", "'event'", "'def'", 
      "'defn'", "'undef'", "'public'", "'protected'", "'private'", "'linear'", 
      "'shared'", "'volatile'", "'local'", "'atomic'", "'static'", "'comptime'", 
      "'mutable'", "'transient'", "'inline'", "'view'", "'synchro'", "'virtual'", 
      "'override'", "'final'", "'off'", "'async'", "'abstract'", "'sealed'", 
      "'singleton'", "'record'", "'monad'", "'measure'", "'infix'", "'explicit'", 
      "'defer'", "'with'", "'do'", "'if'", "'then'", "'elif'", "'else'", 
      "'unless'", "'otherwise'", "'match'", "'case'", "'fallthrough'", "'try'", 
      "'catch'", "'loop'", "'upto'", "'for'", "'each'", "'step'", "'while'", 
      "'until'", "'redo'", "'next'", "'break'", "'return'", "'yield'", "'go'", 
      "'to'", "'await'", "'switch'", "'when'", "'default'", "'continue'", 
      "'begin'", "'finally'", "'invar'", "'this'", "'iota'", "'nth'", "'top'", 
      "'end'", "'it'", "'self'", "'super'", "'parent'", "'all'", "'any'", 
      "'one'", "'two'", "'nil'", "'let'", "'own'", "'mut'", "'typeof'", 
      "'instanceof'", "'sizeof'", "'is'", "'in'", "'between'", "'like'", 
      "'not'", "'and'", "'or'", "'xor'", "'nand'", "'nor'", "'nxor'", "'new'", 
      "'del'", "'atom'", "'auto'", "'void'", "'Bool8'", "'Bool16'", "'Bool32'", 
      "'Bool64'", "'Bool128'", "'Bool'", "'Dig'", "'Bit'", "'Oct'", "'Hex'", 
      "'Roman'", "'Nibble'", "'Byte'", "'Number'", "'Nat8'", "'Nat16'", 
      "'Nat32'", "'Nat64'", "'Nat128'", "'Nat'", "'Bignat'", "'Int8'", "'Int16'", 
      "'Int32'", "'Int64'", "'Int128'", "'Int'", "'Bigint'", "'Real16'", 
      "'Real32'", "'Real64'", "'Real128'", "'Real'", "'Bigreal'", "'Dec1'", 
      "'Dec2'", "'Dec3'", "'Dec4'", "'Dec5'", "'Dec6'", "'Dec7'", "'Dec8'", 
      "'Decimal'", "'Money'", "'Bigdecimal'", "'Ratio8'", "'Ratio16'", "'Ratio32'", 
      "'Ratio64'", "'Ratio128'", "'Ratio'", "'Complex16'", "'Complex32'", 
      "'Complex64'", "'Complex128'", "'Complex'", "'Quatern16'", "'Quatern32'", 
      "'Quatern64'", "'Quatern128'", "'Quatern'", "'Date'", "'Elapse'", 
      "'Ascii'", "'Char8'", "'Char16'", "'Char32'", "'Char'", "'wchar'", 
      "'Ansi'", "'Str8'", "'Str16'", "'Str32'", "'Str'", "'cstr'", "'wstr'", 
      "'Regex'", "'Binary'", "'Path'", "'Uri'", "'Inet'", "'Range'", "'Pair'", 
      "'Tuple'", "'Array'", "'List'", "'Dict'", "'Chan'", "'Vec'", "'Mat'", 
      "'Set'", "'Queue'", "'Deque'", "'Xml'", "'Table'", "'Memo'", "'True'", 
      "'False'", "'Nonzero'", "'Zero'", "'MinValue'", "'MaxValue'", "'NaN'", 
      "'PositiveInfinity'", "'NegativeInfinity'", "'LocalDate'", "'LocalDateTime'", 
      "'OffsetDate'", "'OffsetDateTime'", "'ZonedDate'", "'ZonedDateTime'", 
      "'Tomorrow'", "'Today'", "'Now'", "'Yesterday'", "'Eon'", "'Epoch'", 
      "'Letter'", "'Mark'", "'Digit'", "'Punctuation'", "'Symbol'", "'Separator'", 
      "'NonPrintable'", "'Null'", "'Blank'", "'Nonblank'", "'Folder'", "'File'", 
      "'LinkFile'", "'PipeFile'", "'SocketFile'", "'BlockDevice'", "'CharDevice'", 
      "'NullDevice'", "'Url'", "'Urn'", "'Ipv4'", "'Ipv6'", "'Okay'", "'Fail'", 
      "'Some'", "'None'", "'Yea'", "'Nay'", "'Data'", "'EoT'", "'scan'", 
      "'echo'", "'alert'", "'entry'", "'till'", "'since'", "'timely'", "'cancel'", 
      "'play'", "'cls'", "'cd'", "'pwd'", "'ls'", "'mkdir'", "'rmdir'", 
      "'touch'", "'rm'", "'cp'", "'mv'", "'rename'", "'chmod'", "'chown'", 
      "'chgrp'", "'raise'", "'panic'", "'unit'", "'from'", "'once'", "'data'", 
      "'call'", "'hide'", "'show'", "'into'", "'pass'", "'past'", "'fail'", 
      "'trace'", "'debug'", "'info'", "'warn'", "'error'", "'fatal'"
    },
    std::vector<std::string>{
      "", "LEFT_PARENTHESIS", "RIGHT_PARENTHESIS", "LEFT_BRACKET", "RIGHT_BRACKET", 
      "LEFT_CURLY", "RIGHT_CURLY", "LEFT_ANGLE", "RIGHT_ANGLE", "DOT", "COMMA", 
      "SEMICOLON", "COLON", "EXCLAMATION", "QUESTION", "APOSTROPHE", "QUOTE", 
      "BACKTICK", "AT", "HASH", "DOLLAR", "AMPERSAND", "ASTERISK", "SLASH", 
      "DIVISION", "PERCENT", "BACKSLASH", "TILDE", "CARET", "PIPE", "UNDERSCORE", 
      "EQUAL", "PLUS", "MINUS", "ELLIPSIS", "LAMBDA", "DOUBLE_LEFT_BRACKET", 
      "DOUBLE_RIGHT_BRACKET", "DOUBLE_LEFT_CURLY", "DOUBLE_RIGHT_CURLY", 
      "DOUBLE_LEFT_ANGLE", "DOUBLE_RIGHT_ANGLE", "DOUBLE_EXCLAMATION", "DOUBLE_QUESTION", 
      "DOUBLE_COLON", "DOUBLE_SEMICOLON", "SPECIAL_ASSIGNMENT", "INCREMENT", 
      "DECREMENT", "SQUARE_POWER", "SQUARE_ROOT", "FACTORIAL", "BIT_NEGATION", 
      "DEEP_CLONING", "SORTING", "QUOTIENT", "PERCENTAGE_RATE", "PERCENTAGE_AMOUNT", 
      "PERCENTAGE_INCREASE", "PERCENTAGE_DECREASE", "PERCENTAGE_VARIATION", 
      "BIT_CLEAR", "UNSIGNED_RIGHT_SHIFT", "DIVISIBLE_BY", "NOT_DIVISIBLE_BY", 
      "ELVIS_TEST", "THREE_WAY_TEST", "STRICT_EQUALITY", "STRICT_INEQUALITY", 
      "LOOSE_EQUALITY", "LOOSE_INEQUALITY", "LESS_OR_EQUALS", "GREATER_OR_EQUALS", 
      "ERROR_PROPAGATION_NONE_COALESCING", "POP_ONE_ASSIGNMENT", "PULL_ALL_ASSIGNMENT", 
      "PIPE_ASSIGNMENT", "DESTRUCTURING_ASSIGNMENT", "ADDITION_ASSIGNMENT", 
      "SUBTRACTION_ASSIGNMENT", "MULTIPLICATION_ASSIGNMENT", "REAL_DIVISION_ASSIGNMENT", 
      "INTEGER_DIVISION_ASSIGNMENT", "QUOTIENT_ASSIGNMENT", "MODULO_ASSIGNMENT", 
      "NTH_POWER_ASSIGNMENT", "NTH_ROOT_ASSIGNMENT", "PERCENTAGE_RATE_ASSIGNMENT", 
      "PERCENTAGE_AMOUNT_ASSIGNMENT", "PERCENTAGE_INCREASE_ASSIGNMENT", 
      "PERCENTAGE_DECREASE_ASSIGNMENT", "PERCENTAGE_VARIATION_ASSIGNMENT", 
      "BIT_AND_ASSIGNMENT", "BIT_OR_ASSIGNMENT", "BIT_XOR_ASSIGNMENT", "BIT_CLEAR_ASSIGNMENT", 
      "LEFT_SHIFT_ASSIGNMENT", "SIGNED_RIGHT_SHIFT_ASSIGNMENT", "UNSIGNED_RIGHT_SHIFT_ASSIGNMENT", 
      "NONE_COALESCING_ASSIGNMENT", "INTERVAL_INCLUSIVE", "INTERVAL_LEFT_EXCLUSIVE", 
      "INTERVAL_RIGHT_EXCLUSIVE", "INTERVAL_EXCLUSIVE", "INTERVAL", "INTERVAL_LEFT", 
      "INTERVAL_RIGHT", "MIXIN", "EXTENDS", "NECK_RULE", "ONELINER_SUITE", 
      "MONAD_BIND", "PIPELINE", "COMMAND_SEQUENCE", "COMMAND_SEQUENCE_OKAY", 
      "COMMAND_SEQUENCE_FAIL", "COMMAND_BACKGROUND", "OUTPUT_REDIRECTION", 
      "APPEND_OUTPUT_REDIRECTION", "STDOUT_REDIRECTION", "APPEND_STDOUT_REDIRECTION", 
      "STDERR_REDIRECTION", "APPEND_STDERR_REDIRECTION", "DEC_LIT", "DECIMAL_NUMBER", 
      "REAL_LIT", "REAL_NUMBER", "RATIO_LIT", "RATIONAL_NUMBER", "IMAGINARY_LIT", 
      "IMAGINARY_NUMBER", "NATURAL_LIT", "INTEGER_LIT", "INTEGER_NUMBER", 
      "BINARY_LIT", "HEREDOC_LITERAL", "HEREDOC_CONTENT", "REGULAR_EXPRESSION_LIT", 
      "REGULAR_EXPRESSION_CONTENT", "STRING_LIT", "STRING_PREFIX", "WSTRING_LIT", 
      "STRING_SEQUENCE", "VERBATIM_STRING", "TEMPLATE_STRING", "PLACEHOLDER_VALUE", 
      "CHAR_LIT", "WCHAR_LIT", "WCHAR_PREFIX", "UNICODE_CHAR", "ASCII_LIT", 
      "ASCII_PREFIX", "ASCII_CHAR", "ATOM_DOT_LIT", "DOT_FRACTION", "SHELL_LIT", 
      "SHELL_PATH_LIT", "FILESYSTEM_PATH", "ABSOLUTE_PATH", "RELATIVE_PATH", 
      "TILDE_PATH", "PATH_NAME", "FILE_NAME", "DRIVE_LETTER", "TAG", "IDENTIFIER", 
      "ATOM_IDENTIFIER", "ASPECT_IDENTIFIER", "SHELL_IDENTIFIER", "MUSIC_NOTE", 
      "MUSIC_ALPHABET", "OCTAVE_DIGIT", "PITCH_FLAT", "PITCH_SHARP", "SHEBANG", 
      "WOODSTOCK", "SHERLOCK", "RUBBERDUCK", "SONGBIRD", "LINE_COMMENT", 
      "BLOCK_COMMENT", "CELL_COMMENT", "HASHTAG", "EOS", "EOL", "BOM", "UTF8_BOM", 
      "UTF16_BOM", "UTF32_BOM", "WSP", "UnexpectedCharacter", "MODULE", 
      "ALGORITHM", "NOTABENE", "USE", "AS", "OF", "INCLUDE", "INTERFACE", 
      "EXTERN", "RPROC", "FOREIGN", "CONST", "VAL", "VAR", "FUNC", "FEED", 
      "FMAP", "SUB", "TYPE", "DIM", "FACT", "ENUM", "STRUCT", "PROTO", "TRAIT", 
      "CLASS", "GET", "SET", "OPER", "EVENT", "DEF", "DEFN", "UNDEF", "PUBLIC", 
      "PROTECTED", "PRIVATE", "LINEAR", "SHARED", "VOLATILE", "LOCAL", "ATOMIC", 
      "STATIC", "COMPTIME", "MUTABLE", "TRANSIENT", "INLINE", "VIEW", "SYNCHRO", 
      "VIRTUAL", "OVERRIDE", "FINAL", "OFF", "ASYNC", "ABSTRACT", "SEALED", 
      "SINGLETON", "RECORD", "MONAD", "MEASURE", "INFIX", "EXPLICIT", "DEFER", 
      "WITH", "DO", "IF", "THEN", "ELIF", "ELSE", "UNLESS", "OTHERWISE", 
      "MATCH", "CASE", "FALLTHROUGH", "TRY", "CATCH", "LOOP", "UPTO", "FOR", 
      "EACH", "STEP", "WHILE", "UNTIL", "REDO", "NEXT", "BREAK", "RETURN", 
      "YIELD", "GO", "TO", "AWAIT", "SWITCH", "WHEN", "DEFAULT", "CONTINUE", 
      "BEGIN", "FINALLY", "INVAR", "THIS", "IOTA", "NTH", "TOP", "END", 
      "IT", "SELF", "SUPER", "PARENT", "ALL", "ANY", "ONE", "TWO", "NIL", 
      "LET", "OWN", "MUT", "TYPEOF", "INSTANCEOF", "SIZEOF", "IS", "IN", 
      "BETWEEN", "LIKE", "NOT", "AND", "OR", "XOR", "NAND", "NOR", "NXOR", 
      "NEW", "DEL", "ATOM", "AUTO", "VOID", "BOOL8", "BOOL16", "BOOL32", 
      "BOOL64", "BOOL128", "BOOL", "DIG", "BIT", "OCT", "HEX", "ROMAN", 
      "NIBBLE", "BYTE", "NUMBER", "NAT8", "NAT16", "NAT32", "NAT64", "NAT128", 
      "NAT", "BIGNAT", "INT8", "INT16", "INT32", "INT64", "INT128", "INT", 
      "BIGINT", "REAL16", "REAL32", "REAL64", "REAL128", "REAL", "BIGREAL", 
      "DEC1", "DEC2", "DEC3", "DEC4", "DEC5", "DEC6", "DEC7", "DEC8", "DECIMAL", 
      "MONEY", "BIGDECIMAL", "RATIO8", "RATIO16", "RATIO32", "RATIO64", 
      "RATIO128", "RATIO", "COMPLEX16", "COMPLEX32", "COMPLEX64", "COMPLEX128", 
      "COMPLEX", "QUATERN16", "QUATERN32", "QUATERN64", "QUATERN128", "QUATERN", 
      "DATE", "ELAPSE", "ASCII", "CHAR8", "CHAR16", "CHAR32", "CHAR", "WCHAR", 
      "ANSI", "STR8", "STR16", "STR32", "STR", "CSTR", "WSTR", "REGEX", 
      "BINARY", "PATH", "URI", "INET", "RANGE", "PAIR", "TUPLE", "ARRAY", 
      "LIST", "DICT", "CHAN", "VEC", "MAT", "TSET", "QUEUE", "DEQUE", "XML", 
      "TABLE", "MEMO", "TRUE", "FALSE", "NONZERO", "ZERO", "MINVALUE", "MAXVALUE", 
      "NAN", "POSITIVEINFINITY", "NEGATIVEINFINITY", "LOCALDATE", "LOCALDATETIME", 
      "OFFSETDATE", "OFFSETDATETIME", "ZONEDDATE", "ZONEDDATETIME", "TOMORROW", 
      "TODAY", "NOW", "YESTERDAY", "EON", "EPOCH", "LETTER", "MARK", "DIGIT", 
      "PUNCTUATION", "SYMBOL", "SEPARATOR", "NONPRINTABLE", "NULL", "BLANK", 
      "NONBLANK", "FOLDER", "FILE", "LINKLINKFILE", "PIPEFILE", "SOCKETFILE", 
      "BLOCKDEVICE", "CHARDEVICE", "NULLDEVICE", "URL", "URN", "IPV4", "IPV6", 
      "OKAY", "FAIL", "SOME", "NONE", "YEA", "NAY", "DATA", "EOT", "SCAN", 
      "ECHO", "ALERT", "ENTRY", "TILL", "SINCE", "TIMELY", "CANCEL", "PLAY", 
      "CLS", "CD", "PWD", "LS", "MKDIR", "RMDIR", "TOUCH", "RM", "CP", "MV", 
      "RENAME", "CHMOD", "CHOWN", "CHGRP", "RAISE", "PANIC", "UNIT", "FROM", 
      "ONCE", "TDATA", "CALL", "HIDE", "SHOW", "INTO", "PASS", "PAST", "TFAIL", 
      "TRACE", "DEBUG", "INFO", "WARN", "ERROR", "FATAL"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,512,1035,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,
  	7,122,2,123,7,123,2,124,7,124,2,125,7,125,2,126,7,126,2,127,7,127,2,128,
  	7,128,2,129,7,129,2,130,7,130,2,131,7,131,2,132,7,132,1,0,1,0,3,0,269,
  	8,0,1,1,1,1,1,2,1,2,1,2,4,2,276,8,2,11,2,12,2,277,1,3,1,3,1,3,3,3,283,
  	8,3,1,4,1,4,1,4,3,4,288,8,4,1,5,1,5,1,5,1,5,1,6,1,6,1,6,3,6,297,8,6,1,
  	7,1,7,1,7,1,7,1,7,3,7,304,8,7,1,8,1,8,1,8,1,8,1,8,1,8,3,8,312,8,8,1,9,
  	1,9,1,10,5,10,317,8,10,10,10,12,10,320,9,10,1,10,1,10,1,11,1,11,1,12,
  	1,12,1,12,1,13,1,13,1,13,3,13,332,8,13,1,14,1,14,3,14,336,8,14,1,14,1,
  	14,1,14,1,15,1,15,1,15,4,15,344,8,15,11,15,12,15,345,1,16,1,16,1,16,1,
  	16,1,17,5,17,353,8,17,10,17,12,17,356,9,17,1,17,1,17,1,18,1,18,1,19,1,
  	19,1,19,1,20,1,20,1,20,3,20,368,8,20,1,21,1,21,3,21,372,8,21,1,21,1,21,
  	1,21,3,21,377,8,21,1,22,1,22,1,22,4,22,382,8,22,11,22,12,22,383,1,23,
  	1,23,1,23,1,23,1,24,5,24,391,8,24,10,24,12,24,394,9,24,1,24,1,24,1,25,
  	1,25,1,26,1,26,1,26,1,27,1,27,1,27,3,27,406,8,27,1,28,1,28,3,28,410,8,
  	28,1,28,1,28,1,28,3,28,415,8,28,1,29,1,29,1,29,4,29,420,8,29,11,29,12,
  	29,421,1,30,1,30,1,30,1,30,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,
  	31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,1,31,3,31,445,8,31,1,32,1,32,1,
  	32,3,32,450,8,32,1,33,1,33,1,34,1,34,1,35,1,35,1,35,3,35,459,8,35,1,36,
  	1,36,1,36,1,36,1,37,1,37,1,37,4,37,468,8,37,11,37,12,37,469,1,38,1,38,
  	1,38,3,38,475,8,38,1,38,1,38,1,39,1,39,1,40,1,40,3,40,483,8,40,1,41,1,
  	41,1,42,1,42,1,42,1,42,1,42,1,43,1,43,1,44,1,44,1,44,1,44,1,45,1,45,1,
  	45,1,45,1,45,1,45,3,45,504,8,45,1,46,1,46,3,46,508,8,46,1,47,1,47,1,48,
  	1,48,1,49,1,49,1,50,1,50,1,51,1,51,1,52,1,52,1,53,1,53,1,54,1,54,1,55,
  	1,55,1,56,1,56,1,57,1,57,1,58,1,58,1,59,1,59,1,60,1,60,1,61,1,61,1,62,
  	1,62,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,1,63,
  	1,63,3,63,556,8,63,1,64,1,64,1,65,1,65,1,66,1,66,1,67,1,67,1,68,1,68,
  	1,68,3,68,569,8,68,1,69,1,69,1,70,1,70,1,71,1,71,1,72,1,72,1,73,1,73,
  	1,74,1,74,1,74,5,74,584,8,74,10,74,12,74,587,9,74,1,75,1,75,1,75,5,75,
  	592,8,75,10,75,12,75,595,9,75,1,76,1,76,1,76,5,76,600,8,76,10,76,12,76,
  	603,9,76,1,77,1,77,1,77,5,77,608,8,77,10,77,12,77,611,9,77,1,78,1,78,
  	1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,1,78,3,78,626,8,78,
  	1,79,1,79,1,79,3,79,631,8,79,1,80,1,80,1,80,1,80,1,80,1,80,1,80,1,80,
  	1,80,1,80,1,80,1,80,1,80,1,80,3,80,647,8,80,1,81,1,81,1,81,1,81,1,81,
  	3,81,654,8,81,1,82,1,82,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,1,83,
  	3,83,667,8,83,1,84,1,84,1,85,1,85,1,86,1,86,1,87,1,87,1,88,1,88,1,89,
  	1,89,1,90,1,90,1,91,1,91,1,92,1,92,1,93,1,93,1,94,1,94,1,95,1,95,1,96,
  	1,96,1,97,1,97,1,97,5,97,698,8,97,10,97,12,97,701,9,97,1,98,1,98,5,98,
  	705,8,98,10,98,12,98,708,9,98,1,99,1,99,1,99,5,99,713,8,99,10,99,12,99,
  	716,9,99,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,3,100,726,8,
  	100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,
  	1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,
  	1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,
  	1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,
  	1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,1,100,3,100,785,
  	8,100,5,100,787,8,100,10,100,12,100,790,9,100,1,101,1,101,1,101,1,101,
  	1,101,1,101,1,101,1,101,1,101,1,101,1,101,1,101,1,101,5,101,805,8,101,
  	10,101,12,101,808,9,101,1,102,1,102,1,102,1,102,1,102,1,102,1,102,1,102,
  	1,102,1,102,1,102,1,102,1,102,1,102,1,102,3,102,825,8,102,1,103,1,103,
  	1,104,1,104,1,104,1,105,1,105,1,105,1,106,1,106,1,106,1,106,1,107,1,107,
  	1,107,1,107,1,108,1,108,1,108,1,108,1,108,3,108,848,8,108,1,109,1,109,
  	1,109,1,109,1,109,1,109,1,109,1,109,1,109,1,109,3,109,860,8,109,1,109,
  	1,109,1,109,5,109,865,8,109,10,109,12,109,868,9,109,1,110,1,110,1,110,
  	1,110,1,111,1,111,1,111,1,111,1,112,1,112,1,113,4,113,881,8,113,11,113,
  	12,113,882,1,113,3,113,886,8,113,1,114,1,114,1,114,1,114,1,114,1,115,
  	1,115,1,115,1,116,4,116,897,8,116,11,116,12,116,898,1,117,1,117,5,117,
  	903,8,117,10,117,12,117,906,9,117,1,118,1,118,3,118,910,8,118,1,119,1,
  	119,1,120,1,120,1,120,1,120,1,121,1,121,1,121,1,121,1,121,3,121,923,8,
  	121,1,122,1,122,1,123,1,123,1,123,1,123,1,123,1,123,1,123,1,123,1,123,
  	1,123,1,123,1,123,1,123,1,123,3,123,941,8,123,1,124,1,124,1,124,3,124,
  	946,8,124,1,124,1,124,3,124,950,8,124,1,124,1,124,3,124,954,8,124,1,124,
  	1,124,3,124,958,8,124,1,124,1,124,3,124,962,8,124,1,124,1,124,3,124,966,
  	8,124,1,124,1,124,1,124,1,124,1,124,1,124,3,124,974,8,124,1,125,1,125,
  	1,125,1,125,1,125,1,125,1,125,1,125,1,125,1,125,1,125,1,125,1,125,1,125,
  	1,125,1,125,3,125,992,8,125,1,126,1,126,1,126,1,126,1,126,1,126,1,126,
  	1,126,1,126,3,126,1003,8,126,1,127,1,127,1,127,1,127,3,127,1009,8,127,
  	1,128,1,128,1,128,1,128,3,128,1015,8,128,1,129,1,129,1,129,3,129,1020,
  	8,129,1,130,1,130,1,130,1,130,3,130,1026,8,130,1,131,1,131,1,131,3,131,
  	1031,8,131,1,132,1,132,1,132,0,3,200,202,218,133,0,2,4,6,8,10,12,14,16,
  	18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,
  	64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,
  	108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,
  	144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,
  	180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,
  	216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,
  	252,254,256,258,260,262,264,0,41,1,0,224,226,2,0,233,233,236,236,3,0,
  	227,227,232,233,236,236,2,0,227,233,236,236,2,0,32,33,47,51,2,0,27,27,
  	52,52,2,0,28,28,54,54,2,0,31,31,53,53,2,0,305,305,307,307,1,0,49,50,2,
  	0,22,25,55,60,1,0,32,33,2,0,40,41,62,62,2,0,21,21,61,61,1,0,65,66,2,0,
  	7,8,67,72,2,0,313,313,316,316,2,0,315,315,318,318,2,0,314,314,317,317,
  	4,0,13,14,42,43,73,73,260,260,2,0,31,31,74,76,2,0,31,31,77,77,2,0,78,
  	82,84,99,1,0,324,329,2,0,330,333,335,336,1,0,338,344,1,0,345,351,1,0,
  	352,357,1,0,358,368,1,0,369,374,1,0,375,379,1,0,380,384,1,0,385,386,1,
  	0,387,392,1,0,393,401,1,0,405,406,1,0,321,323,1,0,297,301,1,0,288,289,
  	1,0,420,421,1,0,507,512,1087,0,268,1,0,0,0,2,270,1,0,0,0,4,275,1,0,0,
  	0,6,282,1,0,0,0,8,287,1,0,0,0,10,289,1,0,0,0,12,293,1,0,0,0,14,298,1,
  	0,0,0,16,311,1,0,0,0,18,313,1,0,0,0,20,318,1,0,0,0,22,323,1,0,0,0,24,
  	325,1,0,0,0,26,331,1,0,0,0,28,333,1,0,0,0,30,340,1,0,0,0,32,347,1,0,0,
  	0,34,354,1,0,0,0,36,359,1,0,0,0,38,361,1,0,0,0,40,367,1,0,0,0,42,369,
  	1,0,0,0,44,378,1,0,0,0,46,385,1,0,0,0,48,392,1,0,0,0,50,397,1,0,0,0,52,
  	399,1,0,0,0,54,405,1,0,0,0,56,407,1,0,0,0,58,416,1,0,0,0,60,423,1,0,0,
  	0,62,444,1,0,0,0,64,449,1,0,0,0,66,451,1,0,0,0,68,453,1,0,0,0,70,458,
  	1,0,0,0,72,460,1,0,0,0,74,464,1,0,0,0,76,471,1,0,0,0,78,478,1,0,0,0,80,
  	482,1,0,0,0,82,484,1,0,0,0,84,486,1,0,0,0,86,491,1,0,0,0,88,493,1,0,0,
  	0,90,503,1,0,0,0,92,507,1,0,0,0,94,509,1,0,0,0,96,511,1,0,0,0,98,513,
  	1,0,0,0,100,515,1,0,0,0,102,517,1,0,0,0,104,519,1,0,0,0,106,521,1,0,0,
  	0,108,523,1,0,0,0,110,525,1,0,0,0,112,527,1,0,0,0,114,529,1,0,0,0,116,
  	531,1,0,0,0,118,533,1,0,0,0,120,535,1,0,0,0,122,537,1,0,0,0,124,539,1,
  	0,0,0,126,555,1,0,0,0,128,557,1,0,0,0,130,559,1,0,0,0,132,561,1,0,0,0,
  	134,563,1,0,0,0,136,568,1,0,0,0,138,570,1,0,0,0,140,572,1,0,0,0,142,574,
  	1,0,0,0,144,576,1,0,0,0,146,578,1,0,0,0,148,580,1,0,0,0,150,588,1,0,0,
  	0,152,596,1,0,0,0,154,604,1,0,0,0,156,625,1,0,0,0,158,630,1,0,0,0,160,
  	646,1,0,0,0,162,653,1,0,0,0,164,655,1,0,0,0,166,666,1,0,0,0,168,668,1,
  	0,0,0,170,670,1,0,0,0,172,672,1,0,0,0,174,674,1,0,0,0,176,676,1,0,0,0,
  	178,678,1,0,0,0,180,680,1,0,0,0,182,682,1,0,0,0,184,684,1,0,0,0,186,686,
  	1,0,0,0,188,688,1,0,0,0,190,690,1,0,0,0,192,692,1,0,0,0,194,694,1,0,0,
  	0,196,702,1,0,0,0,198,709,1,0,0,0,200,725,1,0,0,0,202,791,1,0,0,0,204,
  	824,1,0,0,0,206,826,1,0,0,0,208,828,1,0,0,0,210,831,1,0,0,0,212,834,1,
  	0,0,0,214,838,1,0,0,0,216,847,1,0,0,0,218,859,1,0,0,0,220,869,1,0,0,0,
  	222,873,1,0,0,0,224,877,1,0,0,0,226,880,1,0,0,0,228,887,1,0,0,0,230,892,
  	1,0,0,0,232,896,1,0,0,0,234,900,1,0,0,0,236,909,1,0,0,0,238,911,1,0,0,
  	0,240,913,1,0,0,0,242,922,1,0,0,0,244,924,1,0,0,0,246,940,1,0,0,0,248,
  	973,1,0,0,0,250,991,1,0,0,0,252,1002,1,0,0,0,254,1008,1,0,0,0,256,1014,
  	1,0,0,0,258,1019,1,0,0,0,260,1025,1,0,0,0,262,1030,1,0,0,0,264,1032,1,
  	0,0,0,266,269,3,2,1,0,267,269,3,4,2,0,268,266,1,0,0,0,268,267,1,0,0,0,
  	269,1,1,0,0,0,270,271,3,6,3,0,271,3,1,0,0,0,272,273,3,6,3,0,273,274,5,
  	183,0,0,274,276,1,0,0,0,275,272,1,0,0,0,276,277,1,0,0,0,277,275,1,0,0,
  	0,277,278,1,0,0,0,278,5,1,0,0,0,279,283,3,8,4,0,280,283,3,16,8,0,281,
  	283,3,62,31,0,282,279,1,0,0,0,282,280,1,0,0,0,282,281,1,0,0,0,283,7,1,
  	0,0,0,284,288,3,10,5,0,285,288,3,12,6,0,286,288,3,14,7,0,287,284,1,0,
  	0,0,287,285,1,0,0,0,287,286,1,0,0,0,288,9,1,0,0,0,289,290,5,174,0,0,290,
  	291,3,200,100,0,291,292,3,200,100,0,292,11,1,0,0,0,293,294,5,174,0,0,
  	294,296,5,165,0,0,295,297,3,194,97,0,296,295,1,0,0,0,296,297,1,0,0,0,
  	297,13,1,0,0,0,298,299,5,175,0,0,299,303,3,200,100,0,300,304,5,13,0,0,
  	301,302,5,13,0,0,302,304,3,200,100,0,303,300,1,0,0,0,303,301,1,0,0,0,
  	303,304,1,0,0,0,304,15,1,0,0,0,305,306,3,18,9,0,306,307,3,16,8,0,307,
  	312,1,0,0,0,308,312,3,20,10,0,309,312,3,34,17,0,310,312,3,48,24,0,311,
  	305,1,0,0,0,311,308,1,0,0,0,311,309,1,0,0,0,311,310,1,0,0,0,312,17,1,
  	0,0,0,313,314,7,0,0,0,314,19,1,0,0,0,315,317,3,22,11,0,316,315,1,0,0,
  	0,317,320,1,0,0,0,318,316,1,0,0,0,318,319,1,0,0,0,319,321,1,0,0,0,320,
  	318,1,0,0,0,321,322,3,24,12,0,322,21,1,0,0,0,323,324,7,1,0,0,324,23,1,
  	0,0,0,325,326,5,202,0,0,326,327,3,26,13,0,327,25,1,0,0,0,328,332,3,28,
  	14,0,329,332,3,30,15,0,330,332,3,32,16,0,331,328,1,0,0,0,331,329,1,0,
  	0,0,331,330,1,0,0,0,332,27,1,0,0,0,333,335,3,146,73,0,334,336,3,156,78,
  	0,335,334,1,0,0,0,335,336,1,0,0,0,336,337,1,0,0,0,337,338,3,138,69,0,
  	338,339,3,200,100,0,339,29,1,0,0,0,340,343,3,28,14,0,341,342,5,10,0,0,
  	342,344,3,28,14,0,343,341,1,0,0,0,344,345,1,0,0,0,345,343,1,0,0,0,345,
  	346,1,0,0,0,346,31,1,0,0,0,347,348,3,152,76,0,348,349,3,140,70,0,349,
  	350,3,194,97,0,350,33,1,0,0,0,351,353,3,36,18,0,352,351,1,0,0,0,353,356,
  	1,0,0,0,354,352,1,0,0,0,354,355,1,0,0,0,355,357,1,0,0,0,356,354,1,0,0,
  	0,357,358,3,38,19,0,358,35,1,0,0,0,359,360,7,2,0,0,360,37,1,0,0,0,361,
  	362,5,203,0,0,362,363,3,54,27,0,363,39,1,0,0,0,364,368,3,42,21,0,365,
  	368,3,44,22,0,366,368,3,46,23,0,367,364,1,0,0,0,367,365,1,0,0,0,367,366,
  	1,0,0,0,368,41,1,0,0,0,369,371,3,146,73,0,370,372,3,156,78,0,371,370,
  	1,0,0,0,371,372,1,0,0,0,372,376,1,0,0,0,373,374,3,138,69,0,374,375,3,
  	200,100,0,375,377,1,0,0,0,376,373,1,0,0,0,376,377,1,0,0,0,377,43,1,0,
  	0,0,378,381,3,42,21,0,379,380,5,10,0,0,380,382,3,42,21,0,381,379,1,0,
  	0,0,382,383,1,0,0,0,383,381,1,0,0,0,383,384,1,0,0,0,384,45,1,0,0,0,385,
  	386,3,152,76,0,386,387,3,140,70,0,387,388,3,194,97,0,388,47,1,0,0,0,389,
  	391,3,50,25,0,390,389,1,0,0,0,391,394,1,0,0,0,392,390,1,0,0,0,392,393,
  	1,0,0,0,393,395,1,0,0,0,394,392,1,0,0,0,395,396,3,52,26,0,396,49,1,0,
  	0,0,397,398,7,3,0,0,398,51,1,0,0,0,399,400,5,204,0,0,400,401,3,54,27,
  	0,401,53,1,0,0,0,402,406,3,56,28,0,403,406,3,58,29,0,404,406,3,60,30,
  	0,405,402,1,0,0,0,405,403,1,0,0,0,405,404,1,0,0,0,406,55,1,0,0,0,407,
  	409,3,146,73,0,408,410,3,156,78,0,409,408,1,0,0,0,409,410,1,0,0,0,410,
  	414,1,0,0,0,411,412,3,138,69,0,412,413,3,200,100,0,413,415,1,0,0,0,414,
  	411,1,0,0,0,414,415,1,0,0,0,415,57,1,0,0,0,416,419,3,56,28,0,417,418,
  	5,10,0,0,418,420,3,56,28,0,419,417,1,0,0,0,420,421,1,0,0,0,421,419,1,
  	0,0,0,421,422,1,0,0,0,422,59,1,0,0,0,423,424,3,152,76,0,424,425,3,140,
  	70,0,425,426,3,194,97,0,426,61,1,0,0,0,427,428,3,144,72,0,428,429,5,12,
  	0,0,429,445,1,0,0,0,430,431,3,144,72,0,431,432,5,12,0,0,432,433,3,62,
  	31,0,433,445,1,0,0,0,434,435,5,177,0,0,435,445,3,62,31,0,436,437,5,178,
  	0,0,437,445,3,62,31,0,438,439,5,1,0,0,439,440,3,62,31,0,440,441,5,2,0,
  	0,441,445,1,0,0,0,442,445,3,64,32,0,443,445,3,78,39,0,444,427,1,0,0,0,
  	444,430,1,0,0,0,444,434,1,0,0,0,444,436,1,0,0,0,444,438,1,0,0,0,444,442,
  	1,0,0,0,444,443,1,0,0,0,445,63,1,0,0,0,446,450,3,66,33,0,447,450,3,68,
  	34,0,448,450,3,70,35,0,449,446,1,0,0,0,449,447,1,0,0,0,449,448,1,0,0,
  	0,450,65,1,0,0,0,451,452,5,34,0,0,452,67,1,0,0,0,453,454,3,194,97,0,454,
  	69,1,0,0,0,455,459,3,72,36,0,456,459,3,74,37,0,457,459,3,76,38,0,458,
  	455,1,0,0,0,458,456,1,0,0,0,458,457,1,0,0,0,459,71,1,0,0,0,460,461,3,
  	202,101,0,461,462,3,138,69,0,462,463,3,200,100,0,463,73,1,0,0,0,464,467,
  	3,72,36,0,465,466,5,10,0,0,466,468,3,72,36,0,467,465,1,0,0,0,468,469,
  	1,0,0,0,469,467,1,0,0,0,469,470,1,0,0,0,470,75,1,0,0,0,471,474,3,198,
  	99,0,472,475,3,138,69,0,473,475,3,140,70,0,474,472,1,0,0,0,474,473,1,
  	0,0,0,475,476,1,0,0,0,476,477,3,194,97,0,477,77,1,0,0,0,478,479,3,80,
  	40,0,479,79,1,0,0,0,480,483,3,82,41,0,481,483,3,86,43,0,482,480,1,0,0,
  	0,482,481,1,0,0,0,483,81,1,0,0,0,484,485,3,84,42,0,485,83,1,0,0,0,486,
  	487,5,255,0,0,487,488,3,200,100,0,488,489,5,256,0,0,489,490,3,64,32,0,
  	490,85,1,0,0,0,491,492,3,88,44,0,492,87,1,0,0,0,493,494,3,64,32,0,494,
  	495,5,259,0,0,495,496,3,200,100,0,496,89,1,0,0,0,497,504,3,94,47,0,498,
  	504,3,96,48,0,499,504,3,98,49,0,500,504,3,100,50,0,501,504,3,102,51,0,
  	502,504,3,106,53,0,503,497,1,0,0,0,503,498,1,0,0,0,503,499,1,0,0,0,503,
  	500,1,0,0,0,503,501,1,0,0,0,503,502,1,0,0,0,504,91,1,0,0,0,505,508,3,
  	102,51,0,506,508,3,104,52,0,507,505,1,0,0,0,507,506,1,0,0,0,508,93,1,
  	0,0,0,509,510,7,4,0,0,510,95,1,0,0,0,511,512,7,5,0,0,512,97,1,0,0,0,513,
  	514,5,312,0,0,514,99,1,0,0,0,515,516,5,34,0,0,516,101,1,0,0,0,517,518,
  	7,6,0,0,518,103,1,0,0,0,519,520,7,7,0,0,520,105,1,0,0,0,521,522,7,8,0,
  	0,522,107,1,0,0,0,523,524,7,9,0,0,524,109,1,0,0,0,525,526,7,10,0,0,526,
  	111,1,0,0,0,527,528,7,11,0,0,528,113,1,0,0,0,529,530,7,12,0,0,530,115,
  	1,0,0,0,531,532,7,13,0,0,532,117,1,0,0,0,533,534,5,28,0,0,534,119,1,0,
  	0,0,535,536,5,29,0,0,536,121,1,0,0,0,537,538,7,14,0,0,538,123,1,0,0,0,
  	539,540,7,15,0,0,540,125,1,0,0,0,541,556,5,308,0,0,542,543,5,308,0,0,
  	543,556,5,312,0,0,544,556,5,309,0,0,545,546,5,312,0,0,546,556,5,309,0,
  	0,547,556,5,310,0,0,548,549,5,312,0,0,549,556,5,310,0,0,550,556,5,311,
  	0,0,551,552,5,312,0,0,552,556,5,311,0,0,553,556,5,63,0,0,554,556,5,64,
  	0,0,555,541,1,0,0,0,555,542,1,0,0,0,555,544,1,0,0,0,555,545,1,0,0,0,555,
  	547,1,0,0,0,555,548,1,0,0,0,555,550,1,0,0,0,555,551,1,0,0,0,555,553,1,
  	0,0,0,555,554,1,0,0,0,556,127,1,0,0,0,557,558,7,16,0,0,558,129,1,0,0,
  	0,559,560,7,17,0,0,560,131,1,0,0,0,561,562,7,18,0,0,562,133,1,0,0,0,563,
  	564,7,19,0,0,564,135,1,0,0,0,565,569,3,138,69,0,566,569,3,140,70,0,567,
  	569,3,142,71,0,568,565,1,0,0,0,568,566,1,0,0,0,568,567,1,0,0,0,569,137,
  	1,0,0,0,570,571,7,20,0,0,571,139,1,0,0,0,572,573,7,21,0,0,573,141,1,0,
  	0,0,574,575,7,22,0,0,575,143,1,0,0,0,576,577,5,164,0,0,577,145,1,0,0,
  	0,578,579,5,165,0,0,579,147,1,0,0,0,580,585,5,165,0,0,581,582,5,9,0,0,
  	582,584,5,165,0,0,583,581,1,0,0,0,584,587,1,0,0,0,585,583,1,0,0,0,585,
  	586,1,0,0,0,586,149,1,0,0,0,587,585,1,0,0,0,588,593,5,165,0,0,589,590,
  	5,10,0,0,590,592,5,165,0,0,591,589,1,0,0,0,592,595,1,0,0,0,593,591,1,
  	0,0,0,593,594,1,0,0,0,594,151,1,0,0,0,595,593,1,0,0,0,596,601,3,146,73,
  	0,597,598,5,10,0,0,598,600,3,146,73,0,599,597,1,0,0,0,600,603,1,0,0,0,
  	601,599,1,0,0,0,601,602,1,0,0,0,602,153,1,0,0,0,603,601,1,0,0,0,604,609,
  	3,148,74,0,605,606,5,10,0,0,606,608,3,148,74,0,607,605,1,0,0,0,608,611,
  	1,0,0,0,609,607,1,0,0,0,609,610,1,0,0,0,610,155,1,0,0,0,611,609,1,0,0,
  	0,612,626,3,158,79,0,613,614,3,158,79,0,614,615,3,160,80,0,615,626,1,
  	0,0,0,616,617,3,158,79,0,617,618,5,21,0,0,618,619,3,158,79,0,619,626,
  	1,0,0,0,620,621,3,158,79,0,621,622,5,29,0,0,622,623,3,156,78,0,623,626,
  	1,0,0,0,624,626,3,158,79,0,625,612,1,0,0,0,625,613,1,0,0,0,625,616,1,
  	0,0,0,625,620,1,0,0,0,625,624,1,0,0,0,626,157,1,0,0,0,627,631,3,162,81,
  	0,628,631,3,190,95,0,629,631,3,192,96,0,630,627,1,0,0,0,630,628,1,0,0,
  	0,630,629,1,0,0,0,631,159,1,0,0,0,632,647,5,13,0,0,633,647,5,14,0,0,634,
  	635,5,14,0,0,635,647,5,14,0,0,636,637,5,29,0,0,637,647,5,8,0,0,638,639,
  	5,13,0,0,639,647,5,14,0,0,640,641,5,13,0,0,641,642,5,14,0,0,642,647,5,
  	14,0,0,643,644,5,13,0,0,644,645,5,29,0,0,645,647,5,8,0,0,646,632,1,0,
  	0,0,646,633,1,0,0,0,646,634,1,0,0,0,646,636,1,0,0,0,646,638,1,0,0,0,646,
  	640,1,0,0,0,646,643,1,0,0,0,647,161,1,0,0,0,648,654,3,164,82,0,649,654,
  	3,166,83,0,650,654,3,184,92,0,651,654,3,186,93,0,652,654,3,188,94,0,653,
  	648,1,0,0,0,653,649,1,0,0,0,653,650,1,0,0,0,653,651,1,0,0,0,653,652,1,
  	0,0,0,654,163,1,0,0,0,655,656,7,23,0,0,656,165,1,0,0,0,657,667,3,168,
  	84,0,658,667,3,170,85,0,659,667,3,172,86,0,660,667,3,174,87,0,661,667,
  	3,176,88,0,662,667,3,178,89,0,663,667,3,180,90,0,664,667,3,182,91,0,665,
  	667,5,337,0,0,666,657,1,0,0,0,666,658,1,0,0,0,666,659,1,0,0,0,666,660,
  	1,0,0,0,666,661,1,0,0,0,666,662,1,0,0,0,666,663,1,0,0,0,666,664,1,0,0,
  	0,666,665,1,0,0,0,667,167,1,0,0,0,668,669,7,24,0,0,669,169,1,0,0,0,670,
  	671,7,25,0,0,671,171,1,0,0,0,672,673,7,26,0,0,673,173,1,0,0,0,674,675,
  	7,27,0,0,675,175,1,0,0,0,676,677,7,28,0,0,677,177,1,0,0,0,678,679,7,29,
  	0,0,679,179,1,0,0,0,680,681,7,30,0,0,681,181,1,0,0,0,682,683,7,31,0,0,
  	683,183,1,0,0,0,684,685,7,32,0,0,685,185,1,0,0,0,686,687,7,33,0,0,687,
  	187,1,0,0,0,688,689,7,34,0,0,689,189,1,0,0,0,690,691,7,35,0,0,691,191,
  	1,0,0,0,692,693,7,36,0,0,693,193,1,0,0,0,694,699,3,200,100,0,695,696,
  	5,10,0,0,696,698,3,200,100,0,697,695,1,0,0,0,698,701,1,0,0,0,699,697,
  	1,0,0,0,699,700,1,0,0,0,700,195,1,0,0,0,701,699,1,0,0,0,702,706,3,200,
  	100,0,703,705,3,200,100,0,704,703,1,0,0,0,705,708,1,0,0,0,706,704,1,0,
  	0,0,706,707,1,0,0,0,707,197,1,0,0,0,708,706,1,0,0,0,709,714,3,202,101,
  	0,710,711,5,10,0,0,711,713,3,202,101,0,712,710,1,0,0,0,713,716,1,0,0,
  	0,714,712,1,0,0,0,714,715,1,0,0,0,715,199,1,0,0,0,716,714,1,0,0,0,717,
  	718,6,100,-1,0,718,726,3,202,101,0,719,720,3,90,45,0,720,721,3,200,100,
  	19,721,726,1,0,0,0,722,726,3,222,111,0,723,726,3,224,112,0,724,726,3,
  	232,116,0,725,717,1,0,0,0,725,719,1,0,0,0,725,722,1,0,0,0,725,723,1,0,
  	0,0,725,724,1,0,0,0,726,788,1,0,0,0,727,728,10,17,0,0,728,729,3,108,54,
  	0,729,730,3,200,100,18,730,787,1,0,0,0,731,732,10,16,0,0,732,733,3,110,
  	55,0,733,734,3,200,100,17,734,787,1,0,0,0,735,736,10,15,0,0,736,737,3,
  	112,56,0,737,738,3,200,100,16,738,787,1,0,0,0,739,740,10,14,0,0,740,741,
  	3,114,57,0,741,742,3,200,100,15,742,787,1,0,0,0,743,744,10,13,0,0,744,
  	745,3,116,58,0,745,746,3,200,100,14,746,787,1,0,0,0,747,748,10,12,0,0,
  	748,749,3,118,59,0,749,750,3,200,100,13,750,787,1,0,0,0,751,752,10,11,
  	0,0,752,753,3,120,60,0,753,754,3,200,100,12,754,787,1,0,0,0,755,756,10,
  	10,0,0,756,757,3,122,61,0,757,758,3,200,100,11,758,787,1,0,0,0,759,760,
  	10,9,0,0,760,761,3,124,62,0,761,762,3,200,100,10,762,787,1,0,0,0,763,
  	764,10,8,0,0,764,765,3,126,63,0,765,766,3,200,100,9,766,787,1,0,0,0,767,
  	768,10,7,0,0,768,769,3,128,64,0,769,770,3,200,100,8,770,787,1,0,0,0,771,
  	772,10,6,0,0,772,773,3,130,65,0,773,774,3,200,100,7,774,787,1,0,0,0,775,
  	776,10,5,0,0,776,777,3,132,66,0,777,778,3,200,100,6,778,787,1,0,0,0,779,
  	780,10,18,0,0,780,787,3,92,46,0,781,782,10,4,0,0,782,784,3,134,67,0,783,
  	785,3,200,100,0,784,783,1,0,0,0,784,785,1,0,0,0,785,787,1,0,0,0,786,727,
  	1,0,0,0,786,731,1,0,0,0,786,735,1,0,0,0,786,739,1,0,0,0,786,743,1,0,0,
  	0,786,747,1,0,0,0,786,751,1,0,0,0,786,755,1,0,0,0,786,759,1,0,0,0,786,
  	763,1,0,0,0,786,767,1,0,0,0,786,771,1,0,0,0,786,775,1,0,0,0,786,779,1,
  	0,0,0,786,781,1,0,0,0,787,790,1,0,0,0,788,786,1,0,0,0,788,789,1,0,0,0,
  	789,201,1,0,0,0,790,788,1,0,0,0,791,792,6,101,-1,0,792,793,3,204,102,
  	0,793,806,1,0,0,0,794,795,10,5,0,0,795,805,3,208,104,0,796,797,10,4,0,
  	0,797,805,3,210,105,0,798,799,10,3,0,0,799,805,3,212,106,0,800,801,10,
  	2,0,0,801,805,3,214,107,0,802,803,10,1,0,0,803,805,3,220,110,0,804,794,
  	1,0,0,0,804,796,1,0,0,0,804,798,1,0,0,0,804,800,1,0,0,0,804,802,1,0,0,
  	0,805,808,1,0,0,0,806,804,1,0,0,0,806,807,1,0,0,0,807,203,1,0,0,0,808,
  	806,1,0,0,0,809,825,3,236,118,0,810,825,3,238,119,0,811,825,3,148,74,
  	0,812,813,3,148,74,0,813,814,3,200,100,0,814,825,1,0,0,0,815,816,3,206,
  	103,0,816,817,5,17,0,0,817,818,3,148,74,0,818,819,3,194,97,0,819,825,
  	1,0,0,0,820,821,5,1,0,0,821,822,3,194,97,0,822,823,5,2,0,0,823,825,1,
  	0,0,0,824,809,1,0,0,0,824,810,1,0,0,0,824,811,1,0,0,0,824,812,1,0,0,0,
  	824,815,1,0,0,0,824,820,1,0,0,0,825,205,1,0,0,0,826,827,7,37,0,0,827,
  	207,1,0,0,0,828,829,5,11,0,0,829,830,3,148,74,0,830,209,1,0,0,0,831,832,
  	5,9,0,0,832,833,5,165,0,0,833,211,1,0,0,0,834,835,5,3,0,0,835,836,3,194,
  	97,0,836,837,5,4,0,0,837,213,1,0,0,0,838,839,5,3,0,0,839,840,3,216,108,
  	0,840,841,5,4,0,0,841,215,1,0,0,0,842,848,3,218,109,0,843,844,3,218,109,
  	0,844,845,5,12,0,0,845,846,3,200,100,0,846,848,1,0,0,0,847,842,1,0,0,
  	0,847,843,1,0,0,0,848,217,1,0,0,0,849,850,6,109,-1,0,850,851,3,200,100,
  	0,851,852,5,104,0,0,852,853,3,200,100,0,853,860,1,0,0,0,854,855,3,200,
  	100,0,855,856,5,105,0,0,856,860,1,0,0,0,857,858,5,106,0,0,858,860,3,200,
  	100,0,859,849,1,0,0,0,859,854,1,0,0,0,859,857,1,0,0,0,860,866,1,0,0,0,
  	861,862,10,1,0,0,862,863,5,12,0,0,863,865,5,133,0,0,864,861,1,0,0,0,865,
  	868,1,0,0,0,866,864,1,0,0,0,866,867,1,0,0,0,867,219,1,0,0,0,868,866,1,
  	0,0,0,869,870,5,1,0,0,870,871,3,194,97,0,871,872,5,2,0,0,872,221,1,0,
  	0,0,873,874,3,202,101,0,874,875,3,136,68,0,875,876,3,200,100,0,876,223,
  	1,0,0,0,877,878,3,226,113,0,878,225,1,0,0,0,879,881,3,228,114,0,880,879,
  	1,0,0,0,881,882,1,0,0,0,882,880,1,0,0,0,882,883,1,0,0,0,883,885,1,0,0,
  	0,884,886,3,230,115,0,885,884,1,0,0,0,885,886,1,0,0,0,886,227,1,0,0,0,
  	887,888,5,29,0,0,888,889,3,200,100,0,889,890,5,12,0,0,890,891,3,200,100,
  	0,891,229,1,0,0,0,892,893,5,29,0,0,893,894,3,200,100,0,894,231,1,0,0,
  	0,895,897,3,234,117,0,896,895,1,0,0,0,897,898,1,0,0,0,898,896,1,0,0,0,
  	898,899,1,0,0,0,899,233,1,0,0,0,900,904,3,148,74,0,901,903,3,200,100,
  	0,902,901,1,0,0,0,903,906,1,0,0,0,904,902,1,0,0,0,904,905,1,0,0,0,905,
  	235,1,0,0,0,906,904,1,0,0,0,907,910,3,242,121,0,908,910,3,254,127,0,909,
  	907,1,0,0,0,909,908,1,0,0,0,910,237,1,0,0,0,911,912,7,38,0,0,912,239,
  	1,0,0,0,913,914,5,1,0,0,914,915,3,200,100,0,915,916,5,2,0,0,916,241,1,
  	0,0,0,917,923,3,244,122,0,918,923,3,246,123,0,919,923,3,248,124,0,920,
  	923,3,250,125,0,921,923,3,252,126,0,922,917,1,0,0,0,922,918,1,0,0,0,922,
  	919,1,0,0,0,922,920,1,0,0,0,922,921,1,0,0,0,923,243,1,0,0,0,924,925,7,
  	39,0,0,925,245,1,0,0,0,926,941,5,131,0,0,927,941,5,132,0,0,928,941,5,
  	123,0,0,929,941,5,125,0,0,930,941,5,127,0,0,931,941,5,129,0,0,932,933,
  	5,422,0,0,933,941,3,240,120,0,934,941,5,423,0,0,935,941,5,424,0,0,936,
  	941,5,425,0,0,937,941,5,426,0,0,938,941,5,427,0,0,939,941,5,428,0,0,940,
  	926,1,0,0,0,940,927,1,0,0,0,940,928,1,0,0,0,940,929,1,0,0,0,940,930,1,
  	0,0,0,940,931,1,0,0,0,940,932,1,0,0,0,940,934,1,0,0,0,940,935,1,0,0,0,
  	940,936,1,0,0,0,940,937,1,0,0,0,940,938,1,0,0,0,940,939,1,0,0,0,941,247,
  	1,0,0,0,942,974,5,153,0,0,943,945,5,429,0,0,944,946,3,240,120,0,945,944,
  	1,0,0,0,945,946,1,0,0,0,946,974,1,0,0,0,947,949,5,430,0,0,948,950,3,240,
  	120,0,949,948,1,0,0,0,949,950,1,0,0,0,950,974,1,0,0,0,951,953,5,431,0,
  	0,952,954,3,240,120,0,953,952,1,0,0,0,953,954,1,0,0,0,954,974,1,0,0,0,
  	955,957,5,432,0,0,956,958,3,240,120,0,957,956,1,0,0,0,957,958,1,0,0,0,
  	958,974,1,0,0,0,959,961,5,433,0,0,960,962,3,240,120,0,961,960,1,0,0,0,
  	961,962,1,0,0,0,962,974,1,0,0,0,963,965,5,434,0,0,964,966,3,240,120,0,
  	965,964,1,0,0,0,965,966,1,0,0,0,966,974,1,0,0,0,967,974,5,435,0,0,968,
  	974,5,436,0,0,969,974,5,437,0,0,970,974,5,438,0,0,971,974,5,439,0,0,972,
  	974,5,440,0,0,973,942,1,0,0,0,973,943,1,0,0,0,973,947,1,0,0,0,973,951,
  	1,0,0,0,973,955,1,0,0,0,973,959,1,0,0,0,973,963,1,0,0,0,973,967,1,0,0,
  	0,973,968,1,0,0,0,973,969,1,0,0,0,973,970,1,0,0,0,973,971,1,0,0,0,973,
  	972,1,0,0,0,974,249,1,0,0,0,975,992,5,150,0,0,976,992,5,147,0,0,977,992,
  	5,146,0,0,978,979,5,441,0,0,979,992,3,240,120,0,980,981,5,443,0,0,981,
  	992,3,240,120,0,982,983,5,444,0,0,983,992,3,240,120,0,984,985,5,445,0,
  	0,985,992,3,240,120,0,986,987,5,446,0,0,987,992,3,240,120,0,988,989,5,
  	447,0,0,989,992,3,240,120,0,990,992,5,448,0,0,991,975,1,0,0,0,991,976,
  	1,0,0,0,991,977,1,0,0,0,991,978,1,0,0,0,991,980,1,0,0,0,991,982,1,0,0,
  	0,991,984,1,0,0,0,991,986,1,0,0,0,991,988,1,0,0,0,991,990,1,0,0,0,992,
  	251,1,0,0,0,993,1003,5,135,0,0,994,1003,5,137,0,0,995,1003,5,141,0,0,
  	996,1003,5,139,0,0,997,1003,5,153,0,0,998,1003,5,134,0,0,999,1000,5,450,
  	0,0,1000,1003,3,240,120,0,1001,1003,5,449,0,0,1002,993,1,0,0,0,1002,994,
  	1,0,0,0,1002,995,1,0,0,0,1002,996,1,0,0,0,1002,997,1,0,0,0,1002,998,1,
  	0,0,0,1002,999,1,0,0,0,1002,1001,1,0,0,0,1003,253,1,0,0,0,1004,1009,3,
  	256,128,0,1005,1009,3,258,129,0,1006,1009,3,260,130,0,1007,1009,3,262,
  	131,0,1008,1004,1,0,0,0,1008,1005,1,0,0,0,1008,1006,1,0,0,0,1008,1007,
  	1,0,0,0,1009,255,1,0,0,0,1010,1011,5,463,0,0,1011,1015,3,240,120,0,1012,
  	1013,5,464,0,0,1013,1015,3,240,120,0,1014,1010,1,0,0,0,1014,1012,1,0,
  	0,0,1015,257,1,0,0,0,1016,1017,5,465,0,0,1017,1020,3,240,120,0,1018,1020,
  	5,466,0,0,1019,1016,1,0,0,0,1019,1018,1,0,0,0,1020,259,1,0,0,0,1021,1022,
  	5,467,0,0,1022,1026,3,240,120,0,1023,1024,5,468,0,0,1024,1026,3,240,120,
  	0,1025,1021,1,0,0,0,1025,1023,1,0,0,0,1026,261,1,0,0,0,1027,1028,5,469,
  	0,0,1028,1031,3,240,120,0,1029,1031,5,470,0,0,1030,1027,1,0,0,0,1030,
  	1029,1,0,0,0,1031,263,1,0,0,0,1032,1033,7,40,0,0,1033,265,1,0,0,0,74,
  	268,277,282,287,296,303,311,318,331,335,345,354,367,371,376,383,392,405,
  	409,414,421,444,449,458,469,474,482,503,507,555,568,585,593,601,609,625,
  	630,646,653,666,699,706,714,725,784,786,788,804,806,824,847,859,866,882,
  	885,898,904,909,922,940,945,949,953,957,961,965,973,991,1002,1008,1014,
  	1019,1025,1030
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  neobasicparserParserStaticData = std::move(staticData);
}

}

NeoBasicParser::NeoBasicParser(TokenStream *input) : NeoBasicParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

NeoBasicParser::NeoBasicParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : NeoBasicParserBase(input) {
  NeoBasicParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *neobasicparserParserStaticData->atn, neobasicparserParserStaticData->decisionToDFA, neobasicparserParserStaticData->sharedContextCache, options);
}

NeoBasicParser::~NeoBasicParser() {
  delete _interpreter;
}

const atn::ATN& NeoBasicParser::getATN() const {
  return *neobasicparserParserStaticData->atn;
}

std::string NeoBasicParser::getGrammarFileName() const {
  return "NeoBasicParser.g4";
}

const std::vector<std::string>& NeoBasicParser::getRuleNames() const {
  return neobasicparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& NeoBasicParser::getVocabulary() const {
  return neobasicparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView NeoBasicParser::getSerializedATN() const {
  return neobasicparserParserStaticData->serializedATN;
}


//----------------- NeoProgramContext ------------------------------------------------------------------

NeoBasicParser::NeoProgramContext::NeoProgramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::OneLinerProgramContext* NeoBasicParser::NeoProgramContext::oneLinerProgram() {
  return getRuleContext<NeoBasicParser::OneLinerProgramContext>(0);
}

NeoBasicParser::ScriptFileProgramContext* NeoBasicParser::NeoProgramContext::scriptFileProgram() {
  return getRuleContext<NeoBasicParser::ScriptFileProgramContext>(0);
}


size_t NeoBasicParser::NeoProgramContext::getRuleIndex() const {
  return NeoBasicParser::RuleNeoProgram;
}

void NeoBasicParser::NeoProgramContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNeoProgram(this);
}

void NeoBasicParser::NeoProgramContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNeoProgram(this);
}

NeoBasicParser::NeoProgramContext* NeoBasicParser::neoProgram() {
  NeoProgramContext *_localctx = _tracker.createInstance<NeoProgramContext>(_ctx, getState());
  enterRule(_localctx, 0, NeoBasicParser::RuleNeoProgram);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(268);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(266);
      oneLinerProgram();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(267);
      scriptFileProgram();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OneLinerProgramContext ------------------------------------------------------------------

NeoBasicParser::OneLinerProgramContext::OneLinerProgramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::InstructionSentenceContext* NeoBasicParser::OneLinerProgramContext::instructionSentence() {
  return getRuleContext<NeoBasicParser::InstructionSentenceContext>(0);
}


size_t NeoBasicParser::OneLinerProgramContext::getRuleIndex() const {
  return NeoBasicParser::RuleOneLinerProgram;
}

void NeoBasicParser::OneLinerProgramContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOneLinerProgram(this);
}

void NeoBasicParser::OneLinerProgramContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOneLinerProgram(this);
}

NeoBasicParser::OneLinerProgramContext* NeoBasicParser::oneLinerProgram() {
  OneLinerProgramContext *_localctx = _tracker.createInstance<OneLinerProgramContext>(_ctx, getState());
  enterRule(_localctx, 2, NeoBasicParser::RuleOneLinerProgram);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(270);
    instructionSentence();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ScriptFileProgramContext ------------------------------------------------------------------

NeoBasicParser::ScriptFileProgramContext::ScriptFileProgramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NeoBasicParser::InstructionSentenceContext *> NeoBasicParser::ScriptFileProgramContext::instructionSentence() {
  return getRuleContexts<NeoBasicParser::InstructionSentenceContext>();
}

NeoBasicParser::InstructionSentenceContext* NeoBasicParser::ScriptFileProgramContext::instructionSentence(size_t i) {
  return getRuleContext<NeoBasicParser::InstructionSentenceContext>(i);
}

std::vector<tree::TerminalNode *> NeoBasicParser::ScriptFileProgramContext::EOS() {
  return getTokens(NeoBasicParser::EOS);
}

tree::TerminalNode* NeoBasicParser::ScriptFileProgramContext::EOS(size_t i) {
  return getToken(NeoBasicParser::EOS, i);
}


size_t NeoBasicParser::ScriptFileProgramContext::getRuleIndex() const {
  return NeoBasicParser::RuleScriptFileProgram;
}

void NeoBasicParser::ScriptFileProgramContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterScriptFileProgram(this);
}

void NeoBasicParser::ScriptFileProgramContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitScriptFileProgram(this);
}

NeoBasicParser::ScriptFileProgramContext* NeoBasicParser::scriptFileProgram() {
  ScriptFileProgramContext *_localctx = _tracker.createInstance<ScriptFileProgramContext>(_ctx, getState());
  enterRule(_localctx, 4, NeoBasicParser::RuleScriptFileProgram);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(275); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(272);
      instructionSentence();
      setState(273);
      match(NeoBasicParser::EOS);
      setState(277); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 26880891280162818) != 0) || ((((_la - 123) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 123)) & 60805193272744789) != 0) || ((((_la - 202) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 202)) & 9007220725383175) != 0) || ((((_la - 288) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 288)) & 17448451) != 0) || ((((_la - 420) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 420)) & 2243005863952383) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InstructionSentenceContext ------------------------------------------------------------------

NeoBasicParser::InstructionSentenceContext::InstructionSentenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::DirectiveContext* NeoBasicParser::InstructionSentenceContext::directive() {
  return getRuleContext<NeoBasicParser::DirectiveContext>(0);
}

NeoBasicParser::DeclarationContext* NeoBasicParser::InstructionSentenceContext::declaration() {
  return getRuleContext<NeoBasicParser::DeclarationContext>(0);
}

NeoBasicParser::StatementContext* NeoBasicParser::InstructionSentenceContext::statement() {
  return getRuleContext<NeoBasicParser::StatementContext>(0);
}


size_t NeoBasicParser::InstructionSentenceContext::getRuleIndex() const {
  return NeoBasicParser::RuleInstructionSentence;
}

void NeoBasicParser::InstructionSentenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInstructionSentence(this);
}

void NeoBasicParser::InstructionSentenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInstructionSentence(this);
}

NeoBasicParser::InstructionSentenceContext* NeoBasicParser::instructionSentence() {
  InstructionSentenceContext *_localctx = _tracker.createInstance<InstructionSentenceContext>(_ctx, getState());
  enterRule(_localctx, 6, NeoBasicParser::RuleInstructionSentence);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(282);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::SHEBANG:
      case NeoBasicParser::WOODSTOCK: {
        enterOuterAlt(_localctx, 1);
        setState(279);
        directive();
        break;
      }

      case NeoBasicParser::CONST:
      case NeoBasicParser::VAL:
      case NeoBasicParser::VAR:
      case NeoBasicParser::PUBLIC:
      case NeoBasicParser::PROTECTED:
      case NeoBasicParser::PRIVATE:
      case NeoBasicParser::LINEAR:
      case NeoBasicParser::SHARED:
      case NeoBasicParser::VOLATILE:
      case NeoBasicParser::LOCAL:
      case NeoBasicParser::ATOMIC:
      case NeoBasicParser::STATIC:
      case NeoBasicParser::COMPTIME:
      case NeoBasicParser::INLINE: {
        enterOuterAlt(_localctx, 2);
        setState(280);
        declaration();
        break;
      }

      case NeoBasicParser::LEFT_PARENTHESIS:
      case NeoBasicParser::TILDE:
      case NeoBasicParser::CARET:
      case NeoBasicParser::PIPE:
      case NeoBasicParser::PLUS:
      case NeoBasicParser::MINUS:
      case NeoBasicParser::ELLIPSIS:
      case NeoBasicParser::INCREMENT:
      case NeoBasicParser::DECREMENT:
      case NeoBasicParser::SQUARE_POWER:
      case NeoBasicParser::SQUARE_ROOT:
      case NeoBasicParser::FACTORIAL:
      case NeoBasicParser::BIT_NEGATION:
      case NeoBasicParser::SORTING:
      case NeoBasicParser::DEC_LIT:
      case NeoBasicParser::REAL_LIT:
      case NeoBasicParser::RATIO_LIT:
      case NeoBasicParser::IMAGINARY_LIT:
      case NeoBasicParser::NATURAL_LIT:
      case NeoBasicParser::INTEGER_LIT:
      case NeoBasicParser::BINARY_LIT:
      case NeoBasicParser::HEREDOC_LITERAL:
      case NeoBasicParser::REGULAR_EXPRESSION_LIT:
      case NeoBasicParser::STRING_LIT:
      case NeoBasicParser::WSTRING_LIT:
      case NeoBasicParser::CHAR_LIT:
      case NeoBasicParser::WCHAR_LIT:
      case NeoBasicParser::ASCII_LIT:
      case NeoBasicParser::ATOM_DOT_LIT:
      case NeoBasicParser::TAG:
      case NeoBasicParser::IDENTIFIER:
      case NeoBasicParser::RUBBERDUCK:
      case NeoBasicParser::SONGBIRD:
      case NeoBasicParser::IF:
      case NeoBasicParser::THIS:
      case NeoBasicParser::IOTA:
      case NeoBasicParser::ALL:
      case NeoBasicParser::ANY:
      case NeoBasicParser::ONE:
      case NeoBasicParser::TWO:
      case NeoBasicParser::NIL:
      case NeoBasicParser::TYPEOF:
      case NeoBasicParser::SIZEOF:
      case NeoBasicParser::NOT:
      case NeoBasicParser::TRUE:
      case NeoBasicParser::FALSE:
      case NeoBasicParser::NONZERO:
      case NeoBasicParser::ZERO:
      case NeoBasicParser::MINVALUE:
      case NeoBasicParser::MAXVALUE:
      case NeoBasicParser::NAN:
      case NeoBasicParser::POSITIVEINFINITY:
      case NeoBasicParser::NEGATIVEINFINITY:
      case NeoBasicParser::LOCALDATE:
      case NeoBasicParser::LOCALDATETIME:
      case NeoBasicParser::OFFSETDATE:
      case NeoBasicParser::OFFSETDATETIME:
      case NeoBasicParser::ZONEDDATE:
      case NeoBasicParser::ZONEDDATETIME:
      case NeoBasicParser::TOMORROW:
      case NeoBasicParser::TODAY:
      case NeoBasicParser::NOW:
      case NeoBasicParser::YESTERDAY:
      case NeoBasicParser::EON:
      case NeoBasicParser::EPOCH:
      case NeoBasicParser::LETTER:
      case NeoBasicParser::DIGIT:
      case NeoBasicParser::PUNCTUATION:
      case NeoBasicParser::SYMBOL:
      case NeoBasicParser::SEPARATOR:
      case NeoBasicParser::NONPRINTABLE:
      case NeoBasicParser::NULL_:
      case NeoBasicParser::BLANK:
      case NeoBasicParser::NONBLANK:
      case NeoBasicParser::OKAY:
      case NeoBasicParser::FAIL:
      case NeoBasicParser::SOME:
      case NeoBasicParser::NONE:
      case NeoBasicParser::YEA:
      case NeoBasicParser::NAY:
      case NeoBasicParser::DATA:
      case NeoBasicParser::EOT: {
        enterOuterAlt(_localctx, 3);
        setState(281);
        statement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DirectiveContext ------------------------------------------------------------------

NeoBasicParser::DirectiveContext::DirectiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::InterpreterDirectiveContext* NeoBasicParser::DirectiveContext::interpreterDirective() {
  return getRuleContext<NeoBasicParser::InterpreterDirectiveContext>(0);
}

NeoBasicParser::PragmaDirectiveContext* NeoBasicParser::DirectiveContext::pragmaDirective() {
  return getRuleContext<NeoBasicParser::PragmaDirectiveContext>(0);
}

NeoBasicParser::CanaryTestingDirectiveContext* NeoBasicParser::DirectiveContext::canaryTestingDirective() {
  return getRuleContext<NeoBasicParser::CanaryTestingDirectiveContext>(0);
}


size_t NeoBasicParser::DirectiveContext::getRuleIndex() const {
  return NeoBasicParser::RuleDirective;
}

void NeoBasicParser::DirectiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDirective(this);
}

void NeoBasicParser::DirectiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDirective(this);
}

NeoBasicParser::DirectiveContext* NeoBasicParser::directive() {
  DirectiveContext *_localctx = _tracker.createInstance<DirectiveContext>(_ctx, getState());
  enterRule(_localctx, 8, NeoBasicParser::RuleDirective);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(287);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(284);
      interpreterDirective();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(285);
      pragmaDirective();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(286);
      canaryTestingDirective();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InterpreterDirectiveContext ------------------------------------------------------------------

NeoBasicParser::InterpreterDirectiveContext::InterpreterDirectiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::InterpreterDirectiveContext::SHEBANG() {
  return getToken(NeoBasicParser::SHEBANG, 0);
}

std::vector<NeoBasicParser::ExpressionContext *> NeoBasicParser::InterpreterDirectiveContext::expression() {
  return getRuleContexts<NeoBasicParser::ExpressionContext>();
}

NeoBasicParser::ExpressionContext* NeoBasicParser::InterpreterDirectiveContext::expression(size_t i) {
  return getRuleContext<NeoBasicParser::ExpressionContext>(i);
}


size_t NeoBasicParser::InterpreterDirectiveContext::getRuleIndex() const {
  return NeoBasicParser::RuleInterpreterDirective;
}

void NeoBasicParser::InterpreterDirectiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterpreterDirective(this);
}

void NeoBasicParser::InterpreterDirectiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterpreterDirective(this);
}

NeoBasicParser::InterpreterDirectiveContext* NeoBasicParser::interpreterDirective() {
  InterpreterDirectiveContext *_localctx = _tracker.createInstance<InterpreterDirectiveContext>(_ctx, getState());
  enterRule(_localctx, 10, NeoBasicParser::RuleInterpreterDirective);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(289);
    match(NeoBasicParser::SHEBANG);
    setState(290);
    expression(0);
    setState(291);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PragmaDirectiveContext ------------------------------------------------------------------

NeoBasicParser::PragmaDirectiveContext::PragmaDirectiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::PragmaDirectiveContext::SHEBANG() {
  return getToken(NeoBasicParser::SHEBANG, 0);
}

tree::TerminalNode* NeoBasicParser::PragmaDirectiveContext::IDENTIFIER() {
  return getToken(NeoBasicParser::IDENTIFIER, 0);
}

NeoBasicParser::ExpressionsContext* NeoBasicParser::PragmaDirectiveContext::expressions() {
  return getRuleContext<NeoBasicParser::ExpressionsContext>(0);
}


size_t NeoBasicParser::PragmaDirectiveContext::getRuleIndex() const {
  return NeoBasicParser::RulePragmaDirective;
}

void NeoBasicParser::PragmaDirectiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragmaDirective(this);
}

void NeoBasicParser::PragmaDirectiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragmaDirective(this);
}

NeoBasicParser::PragmaDirectiveContext* NeoBasicParser::pragmaDirective() {
  PragmaDirectiveContext *_localctx = _tracker.createInstance<PragmaDirectiveContext>(_ctx, getState());
  enterRule(_localctx, 12, NeoBasicParser::RulePragmaDirective);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(293);
    match(NeoBasicParser::SHEBANG);
    setState(294);
    match(NeoBasicParser::IDENTIFIER);
    setState(296);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 26880891280162818) != 0) || ((((_la - 123) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 123)) & 4399279987541) != 0) || ((((_la - 288) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 288)) & 17448451) != 0) || ((((_la - 420) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 420)) & 2243005863952383) != 0)) {
      setState(295);
      expressions();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CanaryTestingDirectiveContext ------------------------------------------------------------------

NeoBasicParser::CanaryTestingDirectiveContext::CanaryTestingDirectiveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::CanaryTestingDirectiveContext::WOODSTOCK() {
  return getToken(NeoBasicParser::WOODSTOCK, 0);
}

std::vector<NeoBasicParser::ExpressionContext *> NeoBasicParser::CanaryTestingDirectiveContext::expression() {
  return getRuleContexts<NeoBasicParser::ExpressionContext>();
}

NeoBasicParser::ExpressionContext* NeoBasicParser::CanaryTestingDirectiveContext::expression(size_t i) {
  return getRuleContext<NeoBasicParser::ExpressionContext>(i);
}

tree::TerminalNode* NeoBasicParser::CanaryTestingDirectiveContext::EXCLAMATION() {
  return getToken(NeoBasicParser::EXCLAMATION, 0);
}


size_t NeoBasicParser::CanaryTestingDirectiveContext::getRuleIndex() const {
  return NeoBasicParser::RuleCanaryTestingDirective;
}

void NeoBasicParser::CanaryTestingDirectiveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCanaryTestingDirective(this);
}

void NeoBasicParser::CanaryTestingDirectiveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCanaryTestingDirective(this);
}

NeoBasicParser::CanaryTestingDirectiveContext* NeoBasicParser::canaryTestingDirective() {
  CanaryTestingDirectiveContext *_localctx = _tracker.createInstance<CanaryTestingDirectiveContext>(_ctx, getState());
  enterRule(_localctx, 14, NeoBasicParser::RuleCanaryTestingDirective);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(298);
    match(NeoBasicParser::WOODSTOCK);
    setState(299);
    expression(0);
    setState(303);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx)) {
    case 1: {
      setState(300);
      match(NeoBasicParser::EXCLAMATION);
      break;
    }

    case 2: {
      setState(301);
      match(NeoBasicParser::EXCLAMATION);
      setState(302);
      expression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeclarationContext ------------------------------------------------------------------

NeoBasicParser::DeclarationContext::DeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::AccessSpecifierContext* NeoBasicParser::DeclarationContext::accessSpecifier() {
  return getRuleContext<NeoBasicParser::AccessSpecifierContext>(0);
}

NeoBasicParser::DeclarationContext* NeoBasicParser::DeclarationContext::declaration() {
  return getRuleContext<NeoBasicParser::DeclarationContext>(0);
}

NeoBasicParser::ConstSentenceContext* NeoBasicParser::DeclarationContext::constSentence() {
  return getRuleContext<NeoBasicParser::ConstSentenceContext>(0);
}

NeoBasicParser::ValSentenceContext* NeoBasicParser::DeclarationContext::valSentence() {
  return getRuleContext<NeoBasicParser::ValSentenceContext>(0);
}

NeoBasicParser::VarSentenceContext* NeoBasicParser::DeclarationContext::varSentence() {
  return getRuleContext<NeoBasicParser::VarSentenceContext>(0);
}


size_t NeoBasicParser::DeclarationContext::getRuleIndex() const {
  return NeoBasicParser::RuleDeclaration;
}

void NeoBasicParser::DeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeclaration(this);
}

void NeoBasicParser::DeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeclaration(this);
}

NeoBasicParser::DeclarationContext* NeoBasicParser::declaration() {
  DeclarationContext *_localctx = _tracker.createInstance<DeclarationContext>(_ctx, getState());
  enterRule(_localctx, 16, NeoBasicParser::RuleDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(311);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(305);
      accessSpecifier();
      setState(306);
      declaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(308);
      constSentence();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(309);
      valSentence();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(310);
      varSentence();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AccessSpecifierContext ------------------------------------------------------------------

NeoBasicParser::AccessSpecifierContext::AccessSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::AccessSpecifierContext::PUBLIC() {
  return getToken(NeoBasicParser::PUBLIC, 0);
}

tree::TerminalNode* NeoBasicParser::AccessSpecifierContext::PROTECTED() {
  return getToken(NeoBasicParser::PROTECTED, 0);
}

tree::TerminalNode* NeoBasicParser::AccessSpecifierContext::PRIVATE() {
  return getToken(NeoBasicParser::PRIVATE, 0);
}


size_t NeoBasicParser::AccessSpecifierContext::getRuleIndex() const {
  return NeoBasicParser::RuleAccessSpecifier;
}

void NeoBasicParser::AccessSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAccessSpecifier(this);
}

void NeoBasicParser::AccessSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAccessSpecifier(this);
}

NeoBasicParser::AccessSpecifierContext* NeoBasicParser::accessSpecifier() {
  AccessSpecifierContext *_localctx = _tracker.createInstance<AccessSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 18, NeoBasicParser::RuleAccessSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(313);
    _la = _input->LA(1);
    if (!(((((_la - 224) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 224)) & 7) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstSentenceContext ------------------------------------------------------------------

NeoBasicParser::ConstSentenceContext::ConstSentenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::ConstClauseContext* NeoBasicParser::ConstSentenceContext::constClause() {
  return getRuleContext<NeoBasicParser::ConstClauseContext>(0);
}

std::vector<NeoBasicParser::ConstSpecifierContext *> NeoBasicParser::ConstSentenceContext::constSpecifier() {
  return getRuleContexts<NeoBasicParser::ConstSpecifierContext>();
}

NeoBasicParser::ConstSpecifierContext* NeoBasicParser::ConstSentenceContext::constSpecifier(size_t i) {
  return getRuleContext<NeoBasicParser::ConstSpecifierContext>(i);
}


size_t NeoBasicParser::ConstSentenceContext::getRuleIndex() const {
  return NeoBasicParser::RuleConstSentence;
}

void NeoBasicParser::ConstSentenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstSentence(this);
}

void NeoBasicParser::ConstSentenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstSentence(this);
}

NeoBasicParser::ConstSentenceContext* NeoBasicParser::constSentence() {
  ConstSentenceContext *_localctx = _tracker.createInstance<ConstSentenceContext>(_ctx, getState());
  enterRule(_localctx, 20, NeoBasicParser::RuleConstSentence);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(318);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NeoBasicParser::COMPTIME

    || _la == NeoBasicParser::INLINE) {
      setState(315);
      constSpecifier();
      setState(320);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(321);
    constClause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstSpecifierContext ------------------------------------------------------------------

NeoBasicParser::ConstSpecifierContext::ConstSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::ConstSpecifierContext::COMPTIME() {
  return getToken(NeoBasicParser::COMPTIME, 0);
}

tree::TerminalNode* NeoBasicParser::ConstSpecifierContext::INLINE() {
  return getToken(NeoBasicParser::INLINE, 0);
}


size_t NeoBasicParser::ConstSpecifierContext::getRuleIndex() const {
  return NeoBasicParser::RuleConstSpecifier;
}

void NeoBasicParser::ConstSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstSpecifier(this);
}

void NeoBasicParser::ConstSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstSpecifier(this);
}

NeoBasicParser::ConstSpecifierContext* NeoBasicParser::constSpecifier() {
  ConstSpecifierContext *_localctx = _tracker.createInstance<ConstSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 22, NeoBasicParser::RuleConstSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(323);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::COMPTIME

    || _la == NeoBasicParser::INLINE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstClauseContext ------------------------------------------------------------------

NeoBasicParser::ConstClauseContext::ConstClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::ConstClauseContext::CONST() {
  return getToken(NeoBasicParser::CONST, 0);
}

NeoBasicParser::ConstDeclareContext* NeoBasicParser::ConstClauseContext::constDeclare() {
  return getRuleContext<NeoBasicParser::ConstDeclareContext>(0);
}


size_t NeoBasicParser::ConstClauseContext::getRuleIndex() const {
  return NeoBasicParser::RuleConstClause;
}

void NeoBasicParser::ConstClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstClause(this);
}

void NeoBasicParser::ConstClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstClause(this);
}

NeoBasicParser::ConstClauseContext* NeoBasicParser::constClause() {
  ConstClauseContext *_localctx = _tracker.createInstance<ConstClauseContext>(_ctx, getState());
  enterRule(_localctx, 24, NeoBasicParser::RuleConstClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(325);
    match(NeoBasicParser::CONST);
    setState(326);
    constDeclare();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstDeclareContext ------------------------------------------------------------------

NeoBasicParser::ConstDeclareContext::ConstDeclareContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::ConstDeclareSingleContext* NeoBasicParser::ConstDeclareContext::constDeclareSingle() {
  return getRuleContext<NeoBasicParser::ConstDeclareSingleContext>(0);
}

NeoBasicParser::ConstDeclareMultipleContext* NeoBasicParser::ConstDeclareContext::constDeclareMultiple() {
  return getRuleContext<NeoBasicParser::ConstDeclareMultipleContext>(0);
}

NeoBasicParser::ConstDeclareParallelContext* NeoBasicParser::ConstDeclareContext::constDeclareParallel() {
  return getRuleContext<NeoBasicParser::ConstDeclareParallelContext>(0);
}


size_t NeoBasicParser::ConstDeclareContext::getRuleIndex() const {
  return NeoBasicParser::RuleConstDeclare;
}

void NeoBasicParser::ConstDeclareContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstDeclare(this);
}

void NeoBasicParser::ConstDeclareContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstDeclare(this);
}

NeoBasicParser::ConstDeclareContext* NeoBasicParser::constDeclare() {
  ConstDeclareContext *_localctx = _tracker.createInstance<ConstDeclareContext>(_ctx, getState());
  enterRule(_localctx, 26, NeoBasicParser::RuleConstDeclare);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(331);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(328);
      constDeclareSingle();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(329);
      constDeclareMultiple();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(330);
      constDeclareParallel();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstDeclareSingleContext ------------------------------------------------------------------

NeoBasicParser::ConstDeclareSingleContext::ConstDeclareSingleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::SymbolIdentifierContext* NeoBasicParser::ConstDeclareSingleContext::symbolIdentifier() {
  return getRuleContext<NeoBasicParser::SymbolIdentifierContext>(0);
}

NeoBasicParser::SingleAssignmentOperatorContext* NeoBasicParser::ConstDeclareSingleContext::singleAssignmentOperator() {
  return getRuleContext<NeoBasicParser::SingleAssignmentOperatorContext>(0);
}

NeoBasicParser::ExpressionContext* NeoBasicParser::ConstDeclareSingleContext::expression() {
  return getRuleContext<NeoBasicParser::ExpressionContext>(0);
}

NeoBasicParser::TypeContext* NeoBasicParser::ConstDeclareSingleContext::type() {
  return getRuleContext<NeoBasicParser::TypeContext>(0);
}


size_t NeoBasicParser::ConstDeclareSingleContext::getRuleIndex() const {
  return NeoBasicParser::RuleConstDeclareSingle;
}

void NeoBasicParser::ConstDeclareSingleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstDeclareSingle(this);
}

void NeoBasicParser::ConstDeclareSingleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstDeclareSingle(this);
}

NeoBasicParser::ConstDeclareSingleContext* NeoBasicParser::constDeclareSingle() {
  ConstDeclareSingleContext *_localctx = _tracker.createInstance<ConstDeclareSingleContext>(_ctx, getState());
  enterRule(_localctx, 28, NeoBasicParser::RuleConstDeclareSingle);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(333);
    symbolIdentifier();
    setState(335);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 321) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 321)) & -8193) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 385)) & 3276799) != 0)) {
      setState(334);
      type();
    }
    setState(337);
    singleAssignmentOperator();
    setState(338);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstDeclareMultipleContext ------------------------------------------------------------------

NeoBasicParser::ConstDeclareMultipleContext::ConstDeclareMultipleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NeoBasicParser::ConstDeclareSingleContext *> NeoBasicParser::ConstDeclareMultipleContext::constDeclareSingle() {
  return getRuleContexts<NeoBasicParser::ConstDeclareSingleContext>();
}

NeoBasicParser::ConstDeclareSingleContext* NeoBasicParser::ConstDeclareMultipleContext::constDeclareSingle(size_t i) {
  return getRuleContext<NeoBasicParser::ConstDeclareSingleContext>(i);
}

std::vector<tree::TerminalNode *> NeoBasicParser::ConstDeclareMultipleContext::COMMA() {
  return getTokens(NeoBasicParser::COMMA);
}

tree::TerminalNode* NeoBasicParser::ConstDeclareMultipleContext::COMMA(size_t i) {
  return getToken(NeoBasicParser::COMMA, i);
}


size_t NeoBasicParser::ConstDeclareMultipleContext::getRuleIndex() const {
  return NeoBasicParser::RuleConstDeclareMultiple;
}

void NeoBasicParser::ConstDeclareMultipleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstDeclareMultiple(this);
}

void NeoBasicParser::ConstDeclareMultipleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstDeclareMultiple(this);
}

NeoBasicParser::ConstDeclareMultipleContext* NeoBasicParser::constDeclareMultiple() {
  ConstDeclareMultipleContext *_localctx = _tracker.createInstance<ConstDeclareMultipleContext>(_ctx, getState());
  enterRule(_localctx, 30, NeoBasicParser::RuleConstDeclareMultiple);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(340);
    constDeclareSingle();
    setState(343); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(341);
      match(NeoBasicParser::COMMA);
      setState(342);
      constDeclareSingle();
      setState(345); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == NeoBasicParser::COMMA);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstDeclareParallelContext ------------------------------------------------------------------

NeoBasicParser::ConstDeclareParallelContext::ConstDeclareParallelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::SymbolIdentifiersContext* NeoBasicParser::ConstDeclareParallelContext::symbolIdentifiers() {
  return getRuleContext<NeoBasicParser::SymbolIdentifiersContext>(0);
}

NeoBasicParser::MultipleAssignmentOperatorContext* NeoBasicParser::ConstDeclareParallelContext::multipleAssignmentOperator() {
  return getRuleContext<NeoBasicParser::MultipleAssignmentOperatorContext>(0);
}

NeoBasicParser::ExpressionsContext* NeoBasicParser::ConstDeclareParallelContext::expressions() {
  return getRuleContext<NeoBasicParser::ExpressionsContext>(0);
}


size_t NeoBasicParser::ConstDeclareParallelContext::getRuleIndex() const {
  return NeoBasicParser::RuleConstDeclareParallel;
}

void NeoBasicParser::ConstDeclareParallelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstDeclareParallel(this);
}

void NeoBasicParser::ConstDeclareParallelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstDeclareParallel(this);
}

NeoBasicParser::ConstDeclareParallelContext* NeoBasicParser::constDeclareParallel() {
  ConstDeclareParallelContext *_localctx = _tracker.createInstance<ConstDeclareParallelContext>(_ctx, getState());
  enterRule(_localctx, 32, NeoBasicParser::RuleConstDeclareParallel);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(347);
    symbolIdentifiers();
    setState(348);
    multipleAssignmentOperator();
    setState(349);
    expressions();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValSentenceContext ------------------------------------------------------------------

NeoBasicParser::ValSentenceContext::ValSentenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::ValClauseContext* NeoBasicParser::ValSentenceContext::valClause() {
  return getRuleContext<NeoBasicParser::ValClauseContext>(0);
}

std::vector<NeoBasicParser::ValSpecifierContext *> NeoBasicParser::ValSentenceContext::valSpecifier() {
  return getRuleContexts<NeoBasicParser::ValSpecifierContext>();
}

NeoBasicParser::ValSpecifierContext* NeoBasicParser::ValSentenceContext::valSpecifier(size_t i) {
  return getRuleContext<NeoBasicParser::ValSpecifierContext>(i);
}


size_t NeoBasicParser::ValSentenceContext::getRuleIndex() const {
  return NeoBasicParser::RuleValSentence;
}

void NeoBasicParser::ValSentenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValSentence(this);
}

void NeoBasicParser::ValSentenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValSentence(this);
}

NeoBasicParser::ValSentenceContext* NeoBasicParser::valSentence() {
  ValSentenceContext *_localctx = _tracker.createInstance<ValSentenceContext>(_ctx, getState());
  enterRule(_localctx, 34, NeoBasicParser::RuleValSentence);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(354);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 227) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 227)) & 609) != 0)) {
      setState(351);
      valSpecifier();
      setState(356);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(357);
    valClause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValSpecifierContext ------------------------------------------------------------------

NeoBasicParser::ValSpecifierContext::ValSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::ValSpecifierContext::COMPTIME() {
  return getToken(NeoBasicParser::COMPTIME, 0);
}

tree::TerminalNode* NeoBasicParser::ValSpecifierContext::STATIC() {
  return getToken(NeoBasicParser::STATIC, 0);
}

tree::TerminalNode* NeoBasicParser::ValSpecifierContext::LINEAR() {
  return getToken(NeoBasicParser::LINEAR, 0);
}

tree::TerminalNode* NeoBasicParser::ValSpecifierContext::INLINE() {
  return getToken(NeoBasicParser::INLINE, 0);
}


size_t NeoBasicParser::ValSpecifierContext::getRuleIndex() const {
  return NeoBasicParser::RuleValSpecifier;
}

void NeoBasicParser::ValSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValSpecifier(this);
}

void NeoBasicParser::ValSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValSpecifier(this);
}

NeoBasicParser::ValSpecifierContext* NeoBasicParser::valSpecifier() {
  ValSpecifierContext *_localctx = _tracker.createInstance<ValSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 36, NeoBasicParser::RuleValSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(359);
    _la = _input->LA(1);
    if (!(((((_la - 227) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 227)) & 609) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValClauseContext ------------------------------------------------------------------

NeoBasicParser::ValClauseContext::ValClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::ValClauseContext::VAL() {
  return getToken(NeoBasicParser::VAL, 0);
}

NeoBasicParser::VarDeclareContext* NeoBasicParser::ValClauseContext::varDeclare() {
  return getRuleContext<NeoBasicParser::VarDeclareContext>(0);
}


size_t NeoBasicParser::ValClauseContext::getRuleIndex() const {
  return NeoBasicParser::RuleValClause;
}

void NeoBasicParser::ValClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValClause(this);
}

void NeoBasicParser::ValClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValClause(this);
}

NeoBasicParser::ValClauseContext* NeoBasicParser::valClause() {
  ValClauseContext *_localctx = _tracker.createInstance<ValClauseContext>(_ctx, getState());
  enterRule(_localctx, 38, NeoBasicParser::RuleValClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(361);
    match(NeoBasicParser::VAL);
    setState(362);
    varDeclare();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValDeclareContext ------------------------------------------------------------------

NeoBasicParser::ValDeclareContext::ValDeclareContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::ValDeclareSingleContext* NeoBasicParser::ValDeclareContext::valDeclareSingle() {
  return getRuleContext<NeoBasicParser::ValDeclareSingleContext>(0);
}

NeoBasicParser::ValDeclareMultipleContext* NeoBasicParser::ValDeclareContext::valDeclareMultiple() {
  return getRuleContext<NeoBasicParser::ValDeclareMultipleContext>(0);
}

NeoBasicParser::ValDeclareParallelContext* NeoBasicParser::ValDeclareContext::valDeclareParallel() {
  return getRuleContext<NeoBasicParser::ValDeclareParallelContext>(0);
}


size_t NeoBasicParser::ValDeclareContext::getRuleIndex() const {
  return NeoBasicParser::RuleValDeclare;
}

void NeoBasicParser::ValDeclareContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValDeclare(this);
}

void NeoBasicParser::ValDeclareContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValDeclare(this);
}

NeoBasicParser::ValDeclareContext* NeoBasicParser::valDeclare() {
  ValDeclareContext *_localctx = _tracker.createInstance<ValDeclareContext>(_ctx, getState());
  enterRule(_localctx, 40, NeoBasicParser::RuleValDeclare);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(367);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(364);
      valDeclareSingle();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(365);
      valDeclareMultiple();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(366);
      valDeclareParallel();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValDeclareSingleContext ------------------------------------------------------------------

NeoBasicParser::ValDeclareSingleContext::ValDeclareSingleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::SymbolIdentifierContext* NeoBasicParser::ValDeclareSingleContext::symbolIdentifier() {
  return getRuleContext<NeoBasicParser::SymbolIdentifierContext>(0);
}

NeoBasicParser::TypeContext* NeoBasicParser::ValDeclareSingleContext::type() {
  return getRuleContext<NeoBasicParser::TypeContext>(0);
}

NeoBasicParser::SingleAssignmentOperatorContext* NeoBasicParser::ValDeclareSingleContext::singleAssignmentOperator() {
  return getRuleContext<NeoBasicParser::SingleAssignmentOperatorContext>(0);
}

NeoBasicParser::ExpressionContext* NeoBasicParser::ValDeclareSingleContext::expression() {
  return getRuleContext<NeoBasicParser::ExpressionContext>(0);
}


size_t NeoBasicParser::ValDeclareSingleContext::getRuleIndex() const {
  return NeoBasicParser::RuleValDeclareSingle;
}

void NeoBasicParser::ValDeclareSingleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValDeclareSingle(this);
}

void NeoBasicParser::ValDeclareSingleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValDeclareSingle(this);
}

NeoBasicParser::ValDeclareSingleContext* NeoBasicParser::valDeclareSingle() {
  ValDeclareSingleContext *_localctx = _tracker.createInstance<ValDeclareSingleContext>(_ctx, getState());
  enterRule(_localctx, 42, NeoBasicParser::RuleValDeclareSingle);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(369);
    symbolIdentifier();
    setState(371);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 321) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 321)) & -8193) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 385)) & 3276799) != 0)) {
      setState(370);
      type();
    }
    setState(376);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 31) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 31)) & 61572651155457) != 0)) {
      setState(373);
      singleAssignmentOperator();
      setState(374);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValDeclareMultipleContext ------------------------------------------------------------------

NeoBasicParser::ValDeclareMultipleContext::ValDeclareMultipleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NeoBasicParser::ValDeclareSingleContext *> NeoBasicParser::ValDeclareMultipleContext::valDeclareSingle() {
  return getRuleContexts<NeoBasicParser::ValDeclareSingleContext>();
}

NeoBasicParser::ValDeclareSingleContext* NeoBasicParser::ValDeclareMultipleContext::valDeclareSingle(size_t i) {
  return getRuleContext<NeoBasicParser::ValDeclareSingleContext>(i);
}

std::vector<tree::TerminalNode *> NeoBasicParser::ValDeclareMultipleContext::COMMA() {
  return getTokens(NeoBasicParser::COMMA);
}

tree::TerminalNode* NeoBasicParser::ValDeclareMultipleContext::COMMA(size_t i) {
  return getToken(NeoBasicParser::COMMA, i);
}


size_t NeoBasicParser::ValDeclareMultipleContext::getRuleIndex() const {
  return NeoBasicParser::RuleValDeclareMultiple;
}

void NeoBasicParser::ValDeclareMultipleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValDeclareMultiple(this);
}

void NeoBasicParser::ValDeclareMultipleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValDeclareMultiple(this);
}

NeoBasicParser::ValDeclareMultipleContext* NeoBasicParser::valDeclareMultiple() {
  ValDeclareMultipleContext *_localctx = _tracker.createInstance<ValDeclareMultipleContext>(_ctx, getState());
  enterRule(_localctx, 44, NeoBasicParser::RuleValDeclareMultiple);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(378);
    valDeclareSingle();
    setState(381); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(379);
      match(NeoBasicParser::COMMA);
      setState(380);
      valDeclareSingle();
      setState(383); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == NeoBasicParser::COMMA);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValDeclareParallelContext ------------------------------------------------------------------

NeoBasicParser::ValDeclareParallelContext::ValDeclareParallelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::SymbolIdentifiersContext* NeoBasicParser::ValDeclareParallelContext::symbolIdentifiers() {
  return getRuleContext<NeoBasicParser::SymbolIdentifiersContext>(0);
}

NeoBasicParser::MultipleAssignmentOperatorContext* NeoBasicParser::ValDeclareParallelContext::multipleAssignmentOperator() {
  return getRuleContext<NeoBasicParser::MultipleAssignmentOperatorContext>(0);
}

NeoBasicParser::ExpressionsContext* NeoBasicParser::ValDeclareParallelContext::expressions() {
  return getRuleContext<NeoBasicParser::ExpressionsContext>(0);
}


size_t NeoBasicParser::ValDeclareParallelContext::getRuleIndex() const {
  return NeoBasicParser::RuleValDeclareParallel;
}

void NeoBasicParser::ValDeclareParallelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValDeclareParallel(this);
}

void NeoBasicParser::ValDeclareParallelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValDeclareParallel(this);
}

NeoBasicParser::ValDeclareParallelContext* NeoBasicParser::valDeclareParallel() {
  ValDeclareParallelContext *_localctx = _tracker.createInstance<ValDeclareParallelContext>(_ctx, getState());
  enterRule(_localctx, 46, NeoBasicParser::RuleValDeclareParallel);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(385);
    symbolIdentifiers();
    setState(386);
    multipleAssignmentOperator();
    setState(387);
    expressions();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarSentenceContext ------------------------------------------------------------------

NeoBasicParser::VarSentenceContext::VarSentenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::VarClauseContext* NeoBasicParser::VarSentenceContext::varClause() {
  return getRuleContext<NeoBasicParser::VarClauseContext>(0);
}

std::vector<NeoBasicParser::VarSpecifierContext *> NeoBasicParser::VarSentenceContext::varSpecifier() {
  return getRuleContexts<NeoBasicParser::VarSpecifierContext>();
}

NeoBasicParser::VarSpecifierContext* NeoBasicParser::VarSentenceContext::varSpecifier(size_t i) {
  return getRuleContext<NeoBasicParser::VarSpecifierContext>(i);
}


size_t NeoBasicParser::VarSentenceContext::getRuleIndex() const {
  return NeoBasicParser::RuleVarSentence;
}

void NeoBasicParser::VarSentenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarSentence(this);
}

void NeoBasicParser::VarSentenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarSentence(this);
}

NeoBasicParser::VarSentenceContext* NeoBasicParser::varSentence() {
  VarSentenceContext *_localctx = _tracker.createInstance<VarSentenceContext>(_ctx, getState());
  enterRule(_localctx, 48, NeoBasicParser::RuleVarSentence);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(392);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 227) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 227)) & 639) != 0)) {
      setState(389);
      varSpecifier();
      setState(394);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(395);
    varClause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarSpecifierContext ------------------------------------------------------------------

NeoBasicParser::VarSpecifierContext::VarSpecifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::VarSpecifierContext::COMPTIME() {
  return getToken(NeoBasicParser::COMPTIME, 0);
}

tree::TerminalNode* NeoBasicParser::VarSpecifierContext::STATIC() {
  return getToken(NeoBasicParser::STATIC, 0);
}

tree::TerminalNode* NeoBasicParser::VarSpecifierContext::VOLATILE() {
  return getToken(NeoBasicParser::VOLATILE, 0);
}

tree::TerminalNode* NeoBasicParser::VarSpecifierContext::SHARED() {
  return getToken(NeoBasicParser::SHARED, 0);
}

tree::TerminalNode* NeoBasicParser::VarSpecifierContext::LOCAL() {
  return getToken(NeoBasicParser::LOCAL, 0);
}

tree::TerminalNode* NeoBasicParser::VarSpecifierContext::ATOMIC() {
  return getToken(NeoBasicParser::ATOMIC, 0);
}

tree::TerminalNode* NeoBasicParser::VarSpecifierContext::LINEAR() {
  return getToken(NeoBasicParser::LINEAR, 0);
}

tree::TerminalNode* NeoBasicParser::VarSpecifierContext::INLINE() {
  return getToken(NeoBasicParser::INLINE, 0);
}


size_t NeoBasicParser::VarSpecifierContext::getRuleIndex() const {
  return NeoBasicParser::RuleVarSpecifier;
}

void NeoBasicParser::VarSpecifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarSpecifier(this);
}

void NeoBasicParser::VarSpecifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarSpecifier(this);
}

NeoBasicParser::VarSpecifierContext* NeoBasicParser::varSpecifier() {
  VarSpecifierContext *_localctx = _tracker.createInstance<VarSpecifierContext>(_ctx, getState());
  enterRule(_localctx, 50, NeoBasicParser::RuleVarSpecifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(397);
    _la = _input->LA(1);
    if (!(((((_la - 227) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 227)) & 639) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarClauseContext ------------------------------------------------------------------

NeoBasicParser::VarClauseContext::VarClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::VarClauseContext::VAR() {
  return getToken(NeoBasicParser::VAR, 0);
}

NeoBasicParser::VarDeclareContext* NeoBasicParser::VarClauseContext::varDeclare() {
  return getRuleContext<NeoBasicParser::VarDeclareContext>(0);
}


size_t NeoBasicParser::VarClauseContext::getRuleIndex() const {
  return NeoBasicParser::RuleVarClause;
}

void NeoBasicParser::VarClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarClause(this);
}

void NeoBasicParser::VarClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarClause(this);
}

NeoBasicParser::VarClauseContext* NeoBasicParser::varClause() {
  VarClauseContext *_localctx = _tracker.createInstance<VarClauseContext>(_ctx, getState());
  enterRule(_localctx, 52, NeoBasicParser::RuleVarClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(399);
    match(NeoBasicParser::VAR);
    setState(400);
    varDeclare();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarDeclareContext ------------------------------------------------------------------

NeoBasicParser::VarDeclareContext::VarDeclareContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::VarDeclareSingleContext* NeoBasicParser::VarDeclareContext::varDeclareSingle() {
  return getRuleContext<NeoBasicParser::VarDeclareSingleContext>(0);
}

NeoBasicParser::VarDeclareMultipleContext* NeoBasicParser::VarDeclareContext::varDeclareMultiple() {
  return getRuleContext<NeoBasicParser::VarDeclareMultipleContext>(0);
}

NeoBasicParser::VarDeclareParallelContext* NeoBasicParser::VarDeclareContext::varDeclareParallel() {
  return getRuleContext<NeoBasicParser::VarDeclareParallelContext>(0);
}


size_t NeoBasicParser::VarDeclareContext::getRuleIndex() const {
  return NeoBasicParser::RuleVarDeclare;
}

void NeoBasicParser::VarDeclareContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarDeclare(this);
}

void NeoBasicParser::VarDeclareContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarDeclare(this);
}

NeoBasicParser::VarDeclareContext* NeoBasicParser::varDeclare() {
  VarDeclareContext *_localctx = _tracker.createInstance<VarDeclareContext>(_ctx, getState());
  enterRule(_localctx, 54, NeoBasicParser::RuleVarDeclare);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(405);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 17, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(402);
      varDeclareSingle();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(403);
      varDeclareMultiple();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(404);
      varDeclareParallel();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarDeclareSingleContext ------------------------------------------------------------------

NeoBasicParser::VarDeclareSingleContext::VarDeclareSingleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::SymbolIdentifierContext* NeoBasicParser::VarDeclareSingleContext::symbolIdentifier() {
  return getRuleContext<NeoBasicParser::SymbolIdentifierContext>(0);
}

NeoBasicParser::TypeContext* NeoBasicParser::VarDeclareSingleContext::type() {
  return getRuleContext<NeoBasicParser::TypeContext>(0);
}

NeoBasicParser::SingleAssignmentOperatorContext* NeoBasicParser::VarDeclareSingleContext::singleAssignmentOperator() {
  return getRuleContext<NeoBasicParser::SingleAssignmentOperatorContext>(0);
}

NeoBasicParser::ExpressionContext* NeoBasicParser::VarDeclareSingleContext::expression() {
  return getRuleContext<NeoBasicParser::ExpressionContext>(0);
}


size_t NeoBasicParser::VarDeclareSingleContext::getRuleIndex() const {
  return NeoBasicParser::RuleVarDeclareSingle;
}

void NeoBasicParser::VarDeclareSingleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarDeclareSingle(this);
}

void NeoBasicParser::VarDeclareSingleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarDeclareSingle(this);
}

NeoBasicParser::VarDeclareSingleContext* NeoBasicParser::varDeclareSingle() {
  VarDeclareSingleContext *_localctx = _tracker.createInstance<VarDeclareSingleContext>(_ctx, getState());
  enterRule(_localctx, 56, NeoBasicParser::RuleVarDeclareSingle);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(407);
    symbolIdentifier();
    setState(409);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 321) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 321)) & -8193) != 0) || ((((_la - 385) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 385)) & 3276799) != 0)) {
      setState(408);
      type();
    }
    setState(414);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 31) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 31)) & 61572651155457) != 0)) {
      setState(411);
      singleAssignmentOperator();
      setState(412);
      expression(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarDeclareMultipleContext ------------------------------------------------------------------

NeoBasicParser::VarDeclareMultipleContext::VarDeclareMultipleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NeoBasicParser::VarDeclareSingleContext *> NeoBasicParser::VarDeclareMultipleContext::varDeclareSingle() {
  return getRuleContexts<NeoBasicParser::VarDeclareSingleContext>();
}

NeoBasicParser::VarDeclareSingleContext* NeoBasicParser::VarDeclareMultipleContext::varDeclareSingle(size_t i) {
  return getRuleContext<NeoBasicParser::VarDeclareSingleContext>(i);
}

std::vector<tree::TerminalNode *> NeoBasicParser::VarDeclareMultipleContext::COMMA() {
  return getTokens(NeoBasicParser::COMMA);
}

tree::TerminalNode* NeoBasicParser::VarDeclareMultipleContext::COMMA(size_t i) {
  return getToken(NeoBasicParser::COMMA, i);
}


size_t NeoBasicParser::VarDeclareMultipleContext::getRuleIndex() const {
  return NeoBasicParser::RuleVarDeclareMultiple;
}

void NeoBasicParser::VarDeclareMultipleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarDeclareMultiple(this);
}

void NeoBasicParser::VarDeclareMultipleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarDeclareMultiple(this);
}

NeoBasicParser::VarDeclareMultipleContext* NeoBasicParser::varDeclareMultiple() {
  VarDeclareMultipleContext *_localctx = _tracker.createInstance<VarDeclareMultipleContext>(_ctx, getState());
  enterRule(_localctx, 58, NeoBasicParser::RuleVarDeclareMultiple);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(416);
    varDeclareSingle();
    setState(419); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(417);
      match(NeoBasicParser::COMMA);
      setState(418);
      varDeclareSingle();
      setState(421); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == NeoBasicParser::COMMA);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarDeclareParallelContext ------------------------------------------------------------------

NeoBasicParser::VarDeclareParallelContext::VarDeclareParallelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::SymbolIdentifiersContext* NeoBasicParser::VarDeclareParallelContext::symbolIdentifiers() {
  return getRuleContext<NeoBasicParser::SymbolIdentifiersContext>(0);
}

NeoBasicParser::MultipleAssignmentOperatorContext* NeoBasicParser::VarDeclareParallelContext::multipleAssignmentOperator() {
  return getRuleContext<NeoBasicParser::MultipleAssignmentOperatorContext>(0);
}

NeoBasicParser::ExpressionsContext* NeoBasicParser::VarDeclareParallelContext::expressions() {
  return getRuleContext<NeoBasicParser::ExpressionsContext>(0);
}


size_t NeoBasicParser::VarDeclareParallelContext::getRuleIndex() const {
  return NeoBasicParser::RuleVarDeclareParallel;
}

void NeoBasicParser::VarDeclareParallelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarDeclareParallel(this);
}

void NeoBasicParser::VarDeclareParallelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarDeclareParallel(this);
}

NeoBasicParser::VarDeclareParallelContext* NeoBasicParser::varDeclareParallel() {
  VarDeclareParallelContext *_localctx = _tracker.createInstance<VarDeclareParallelContext>(_ctx, getState());
  enterRule(_localctx, 60, NeoBasicParser::RuleVarDeclareParallel);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(423);
    symbolIdentifiers();
    setState(424);
    multipleAssignmentOperator();
    setState(425);
    expressions();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementContext ------------------------------------------------------------------

NeoBasicParser::StatementContext::StatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::LabelIdentifierContext* NeoBasicParser::StatementContext::labelIdentifier() {
  return getRuleContext<NeoBasicParser::LabelIdentifierContext>(0);
}

tree::TerminalNode* NeoBasicParser::StatementContext::COLON() {
  return getToken(NeoBasicParser::COLON, 0);
}

NeoBasicParser::StatementContext* NeoBasicParser::StatementContext::statement() {
  return getRuleContext<NeoBasicParser::StatementContext>(0);
}

tree::TerminalNode* NeoBasicParser::StatementContext::RUBBERDUCK() {
  return getToken(NeoBasicParser::RUBBERDUCK, 0);
}

tree::TerminalNode* NeoBasicParser::StatementContext::SONGBIRD() {
  return getToken(NeoBasicParser::SONGBIRD, 0);
}

tree::TerminalNode* NeoBasicParser::StatementContext::LEFT_PARENTHESIS() {
  return getToken(NeoBasicParser::LEFT_PARENTHESIS, 0);
}

tree::TerminalNode* NeoBasicParser::StatementContext::RIGHT_PARENTHESIS() {
  return getToken(NeoBasicParser::RIGHT_PARENTHESIS, 0);
}

NeoBasicParser::SimpleStatementContext* NeoBasicParser::StatementContext::simpleStatement() {
  return getRuleContext<NeoBasicParser::SimpleStatementContext>(0);
}

NeoBasicParser::CompoundStatementContext* NeoBasicParser::StatementContext::compoundStatement() {
  return getRuleContext<NeoBasicParser::CompoundStatementContext>(0);
}


size_t NeoBasicParser::StatementContext::getRuleIndex() const {
  return NeoBasicParser::RuleStatement;
}

void NeoBasicParser::StatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatement(this);
}

void NeoBasicParser::StatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatement(this);
}

NeoBasicParser::StatementContext* NeoBasicParser::statement() {
  StatementContext *_localctx = _tracker.createInstance<StatementContext>(_ctx, getState());
  enterRule(_localctx, 62, NeoBasicParser::RuleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(444);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(427);
      labelIdentifier();
      setState(428);
      match(NeoBasicParser::COLON);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(430);
      labelIdentifier();
      setState(431);
      match(NeoBasicParser::COLON);
      setState(432);
      statement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(434);
      match(NeoBasicParser::RUBBERDUCK);
      setState(435);
      statement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(436);
      match(NeoBasicParser::SONGBIRD);
      setState(437);
      statement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(438);
      match(NeoBasicParser::LEFT_PARENTHESIS);
      setState(439);
      statement();
      setState(440);
      match(NeoBasicParser::RIGHT_PARENTHESIS);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(442);
      simpleStatement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(443);
      compoundStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleStatementContext ------------------------------------------------------------------

NeoBasicParser::SimpleStatementContext::SimpleStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::EmptyStatementContext* NeoBasicParser::SimpleStatementContext::emptyStatement() {
  return getRuleContext<NeoBasicParser::EmptyStatementContext>(0);
}

NeoBasicParser::ExpressionStatementContext* NeoBasicParser::SimpleStatementContext::expressionStatement() {
  return getRuleContext<NeoBasicParser::ExpressionStatementContext>(0);
}

NeoBasicParser::AssignmentStatementContext* NeoBasicParser::SimpleStatementContext::assignmentStatement() {
  return getRuleContext<NeoBasicParser::AssignmentStatementContext>(0);
}


size_t NeoBasicParser::SimpleStatementContext::getRuleIndex() const {
  return NeoBasicParser::RuleSimpleStatement;
}

void NeoBasicParser::SimpleStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleStatement(this);
}

void NeoBasicParser::SimpleStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleStatement(this);
}

NeoBasicParser::SimpleStatementContext* NeoBasicParser::simpleStatement() {
  SimpleStatementContext *_localctx = _tracker.createInstance<SimpleStatementContext>(_ctx, getState());
  enterRule(_localctx, 64, NeoBasicParser::RuleSimpleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(449);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(446);
      emptyStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(447);
      expressionStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(448);
      assignmentStatement();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EmptyStatementContext ------------------------------------------------------------------

NeoBasicParser::EmptyStatementContext::EmptyStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::EmptyStatementContext::ELLIPSIS() {
  return getToken(NeoBasicParser::ELLIPSIS, 0);
}


size_t NeoBasicParser::EmptyStatementContext::getRuleIndex() const {
  return NeoBasicParser::RuleEmptyStatement;
}

void NeoBasicParser::EmptyStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEmptyStatement(this);
}

void NeoBasicParser::EmptyStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEmptyStatement(this);
}

NeoBasicParser::EmptyStatementContext* NeoBasicParser::emptyStatement() {
  EmptyStatementContext *_localctx = _tracker.createInstance<EmptyStatementContext>(_ctx, getState());
  enterRule(_localctx, 66, NeoBasicParser::RuleEmptyStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(451);
    match(NeoBasicParser::ELLIPSIS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionStatementContext ------------------------------------------------------------------

NeoBasicParser::ExpressionStatementContext::ExpressionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::ExpressionsContext* NeoBasicParser::ExpressionStatementContext::expressions() {
  return getRuleContext<NeoBasicParser::ExpressionsContext>(0);
}


size_t NeoBasicParser::ExpressionStatementContext::getRuleIndex() const {
  return NeoBasicParser::RuleExpressionStatement;
}

void NeoBasicParser::ExpressionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressionStatement(this);
}

void NeoBasicParser::ExpressionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressionStatement(this);
}

NeoBasicParser::ExpressionStatementContext* NeoBasicParser::expressionStatement() {
  ExpressionStatementContext *_localctx = _tracker.createInstance<ExpressionStatementContext>(_ctx, getState());
  enterRule(_localctx, 68, NeoBasicParser::RuleExpressionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(453);
    expressions();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentStatementContext ------------------------------------------------------------------

NeoBasicParser::AssignmentStatementContext::AssignmentStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::AssignmentSingleContext* NeoBasicParser::AssignmentStatementContext::assignmentSingle() {
  return getRuleContext<NeoBasicParser::AssignmentSingleContext>(0);
}

NeoBasicParser::AssignmentMultipleContext* NeoBasicParser::AssignmentStatementContext::assignmentMultiple() {
  return getRuleContext<NeoBasicParser::AssignmentMultipleContext>(0);
}

NeoBasicParser::AssignmentParallelContext* NeoBasicParser::AssignmentStatementContext::assignmentParallel() {
  return getRuleContext<NeoBasicParser::AssignmentParallelContext>(0);
}


size_t NeoBasicParser::AssignmentStatementContext::getRuleIndex() const {
  return NeoBasicParser::RuleAssignmentStatement;
}

void NeoBasicParser::AssignmentStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentStatement(this);
}

void NeoBasicParser::AssignmentStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentStatement(this);
}

NeoBasicParser::AssignmentStatementContext* NeoBasicParser::assignmentStatement() {
  AssignmentStatementContext *_localctx = _tracker.createInstance<AssignmentStatementContext>(_ctx, getState());
  enterRule(_localctx, 70, NeoBasicParser::RuleAssignmentStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(458);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 23, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(455);
      assignmentSingle();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(456);
      assignmentMultiple();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(457);
      assignmentParallel();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentSingleContext ------------------------------------------------------------------

NeoBasicParser::AssignmentSingleContext::AssignmentSingleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::PrimaryExpressionContext* NeoBasicParser::AssignmentSingleContext::primaryExpression() {
  return getRuleContext<NeoBasicParser::PrimaryExpressionContext>(0);
}

NeoBasicParser::SingleAssignmentOperatorContext* NeoBasicParser::AssignmentSingleContext::singleAssignmentOperator() {
  return getRuleContext<NeoBasicParser::SingleAssignmentOperatorContext>(0);
}

NeoBasicParser::ExpressionContext* NeoBasicParser::AssignmentSingleContext::expression() {
  return getRuleContext<NeoBasicParser::ExpressionContext>(0);
}


size_t NeoBasicParser::AssignmentSingleContext::getRuleIndex() const {
  return NeoBasicParser::RuleAssignmentSingle;
}

void NeoBasicParser::AssignmentSingleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentSingle(this);
}

void NeoBasicParser::AssignmentSingleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentSingle(this);
}

NeoBasicParser::AssignmentSingleContext* NeoBasicParser::assignmentSingle() {
  AssignmentSingleContext *_localctx = _tracker.createInstance<AssignmentSingleContext>(_ctx, getState());
  enterRule(_localctx, 72, NeoBasicParser::RuleAssignmentSingle);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(460);
    primaryExpression(0);
    setState(461);
    singleAssignmentOperator();
    setState(462);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentMultipleContext ------------------------------------------------------------------

NeoBasicParser::AssignmentMultipleContext::AssignmentMultipleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NeoBasicParser::AssignmentSingleContext *> NeoBasicParser::AssignmentMultipleContext::assignmentSingle() {
  return getRuleContexts<NeoBasicParser::AssignmentSingleContext>();
}

NeoBasicParser::AssignmentSingleContext* NeoBasicParser::AssignmentMultipleContext::assignmentSingle(size_t i) {
  return getRuleContext<NeoBasicParser::AssignmentSingleContext>(i);
}

std::vector<tree::TerminalNode *> NeoBasicParser::AssignmentMultipleContext::COMMA() {
  return getTokens(NeoBasicParser::COMMA);
}

tree::TerminalNode* NeoBasicParser::AssignmentMultipleContext::COMMA(size_t i) {
  return getToken(NeoBasicParser::COMMA, i);
}


size_t NeoBasicParser::AssignmentMultipleContext::getRuleIndex() const {
  return NeoBasicParser::RuleAssignmentMultiple;
}

void NeoBasicParser::AssignmentMultipleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentMultiple(this);
}

void NeoBasicParser::AssignmentMultipleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentMultiple(this);
}

NeoBasicParser::AssignmentMultipleContext* NeoBasicParser::assignmentMultiple() {
  AssignmentMultipleContext *_localctx = _tracker.createInstance<AssignmentMultipleContext>(_ctx, getState());
  enterRule(_localctx, 74, NeoBasicParser::RuleAssignmentMultiple);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(464);
    assignmentSingle();
    setState(467); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(465);
      match(NeoBasicParser::COMMA);
      setState(466);
      assignmentSingle();
      setState(469); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == NeoBasicParser::COMMA);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentParallelContext ------------------------------------------------------------------

NeoBasicParser::AssignmentParallelContext::AssignmentParallelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::PrimaryExpressionsContext* NeoBasicParser::AssignmentParallelContext::primaryExpressions() {
  return getRuleContext<NeoBasicParser::PrimaryExpressionsContext>(0);
}

NeoBasicParser::ExpressionsContext* NeoBasicParser::AssignmentParallelContext::expressions() {
  return getRuleContext<NeoBasicParser::ExpressionsContext>(0);
}

NeoBasicParser::SingleAssignmentOperatorContext* NeoBasicParser::AssignmentParallelContext::singleAssignmentOperator() {
  return getRuleContext<NeoBasicParser::SingleAssignmentOperatorContext>(0);
}

NeoBasicParser::MultipleAssignmentOperatorContext* NeoBasicParser::AssignmentParallelContext::multipleAssignmentOperator() {
  return getRuleContext<NeoBasicParser::MultipleAssignmentOperatorContext>(0);
}


size_t NeoBasicParser::AssignmentParallelContext::getRuleIndex() const {
  return NeoBasicParser::RuleAssignmentParallel;
}

void NeoBasicParser::AssignmentParallelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentParallel(this);
}

void NeoBasicParser::AssignmentParallelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentParallel(this);
}

NeoBasicParser::AssignmentParallelContext* NeoBasicParser::assignmentParallel() {
  AssignmentParallelContext *_localctx = _tracker.createInstance<AssignmentParallelContext>(_ctx, getState());
  enterRule(_localctx, 76, NeoBasicParser::RuleAssignmentParallel);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(471);
    primaryExpressions();
    setState(474);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx)) {
    case 1: {
      setState(472);
      singleAssignmentOperator();
      break;
    }

    case 2: {
      setState(473);
      multipleAssignmentOperator();
      break;
    }

    default:
      break;
    }
    setState(476);
    expressions();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompoundStatementContext ------------------------------------------------------------------

NeoBasicParser::CompoundStatementContext::CompoundStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::ConditionalStatementContext* NeoBasicParser::CompoundStatementContext::conditionalStatement() {
  return getRuleContext<NeoBasicParser::ConditionalStatementContext>(0);
}


size_t NeoBasicParser::CompoundStatementContext::getRuleIndex() const {
  return NeoBasicParser::RuleCompoundStatement;
}

void NeoBasicParser::CompoundStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompoundStatement(this);
}

void NeoBasicParser::CompoundStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompoundStatement(this);
}

NeoBasicParser::CompoundStatementContext* NeoBasicParser::compoundStatement() {
  CompoundStatementContext *_localctx = _tracker.createInstance<CompoundStatementContext>(_ctx, getState());
  enterRule(_localctx, 78, NeoBasicParser::RuleCompoundStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(478);
    conditionalStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConditionalStatementContext ------------------------------------------------------------------

NeoBasicParser::ConditionalStatementContext::ConditionalStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::IfStatementContext* NeoBasicParser::ConditionalStatementContext::ifStatement() {
  return getRuleContext<NeoBasicParser::IfStatementContext>(0);
}

NeoBasicParser::UnlessStatementContext* NeoBasicParser::ConditionalStatementContext::unlessStatement() {
  return getRuleContext<NeoBasicParser::UnlessStatementContext>(0);
}


size_t NeoBasicParser::ConditionalStatementContext::getRuleIndex() const {
  return NeoBasicParser::RuleConditionalStatement;
}

void NeoBasicParser::ConditionalStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditionalStatement(this);
}

void NeoBasicParser::ConditionalStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditionalStatement(this);
}

NeoBasicParser::ConditionalStatementContext* NeoBasicParser::conditionalStatement() {
  ConditionalStatementContext *_localctx = _tracker.createInstance<ConditionalStatementContext>(_ctx, getState());
  enterRule(_localctx, 80, NeoBasicParser::RuleConditionalStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(482);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::IF: {
        enterOuterAlt(_localctx, 1);
        setState(480);
        ifStatement();
        break;
      }

      case NeoBasicParser::LEFT_PARENTHESIS:
      case NeoBasicParser::TILDE:
      case NeoBasicParser::CARET:
      case NeoBasicParser::PIPE:
      case NeoBasicParser::PLUS:
      case NeoBasicParser::MINUS:
      case NeoBasicParser::ELLIPSIS:
      case NeoBasicParser::INCREMENT:
      case NeoBasicParser::DECREMENT:
      case NeoBasicParser::SQUARE_POWER:
      case NeoBasicParser::SQUARE_ROOT:
      case NeoBasicParser::FACTORIAL:
      case NeoBasicParser::BIT_NEGATION:
      case NeoBasicParser::SORTING:
      case NeoBasicParser::DEC_LIT:
      case NeoBasicParser::REAL_LIT:
      case NeoBasicParser::RATIO_LIT:
      case NeoBasicParser::IMAGINARY_LIT:
      case NeoBasicParser::NATURAL_LIT:
      case NeoBasicParser::INTEGER_LIT:
      case NeoBasicParser::BINARY_LIT:
      case NeoBasicParser::HEREDOC_LITERAL:
      case NeoBasicParser::REGULAR_EXPRESSION_LIT:
      case NeoBasicParser::STRING_LIT:
      case NeoBasicParser::WSTRING_LIT:
      case NeoBasicParser::CHAR_LIT:
      case NeoBasicParser::WCHAR_LIT:
      case NeoBasicParser::ASCII_LIT:
      case NeoBasicParser::ATOM_DOT_LIT:
      case NeoBasicParser::IDENTIFIER:
      case NeoBasicParser::THIS:
      case NeoBasicParser::IOTA:
      case NeoBasicParser::ALL:
      case NeoBasicParser::ANY:
      case NeoBasicParser::ONE:
      case NeoBasicParser::TWO:
      case NeoBasicParser::NIL:
      case NeoBasicParser::TYPEOF:
      case NeoBasicParser::SIZEOF:
      case NeoBasicParser::NOT:
      case NeoBasicParser::TRUE:
      case NeoBasicParser::FALSE:
      case NeoBasicParser::NONZERO:
      case NeoBasicParser::ZERO:
      case NeoBasicParser::MINVALUE:
      case NeoBasicParser::MAXVALUE:
      case NeoBasicParser::NAN:
      case NeoBasicParser::POSITIVEINFINITY:
      case NeoBasicParser::NEGATIVEINFINITY:
      case NeoBasicParser::LOCALDATE:
      case NeoBasicParser::LOCALDATETIME:
      case NeoBasicParser::OFFSETDATE:
      case NeoBasicParser::OFFSETDATETIME:
      case NeoBasicParser::ZONEDDATE:
      case NeoBasicParser::ZONEDDATETIME:
      case NeoBasicParser::TOMORROW:
      case NeoBasicParser::TODAY:
      case NeoBasicParser::NOW:
      case NeoBasicParser::YESTERDAY:
      case NeoBasicParser::EON:
      case NeoBasicParser::EPOCH:
      case NeoBasicParser::LETTER:
      case NeoBasicParser::DIGIT:
      case NeoBasicParser::PUNCTUATION:
      case NeoBasicParser::SYMBOL:
      case NeoBasicParser::SEPARATOR:
      case NeoBasicParser::NONPRINTABLE:
      case NeoBasicParser::NULL_:
      case NeoBasicParser::BLANK:
      case NeoBasicParser::NONBLANK:
      case NeoBasicParser::OKAY:
      case NeoBasicParser::FAIL:
      case NeoBasicParser::SOME:
      case NeoBasicParser::NONE:
      case NeoBasicParser::YEA:
      case NeoBasicParser::NAY:
      case NeoBasicParser::DATA:
      case NeoBasicParser::EOT: {
        enterOuterAlt(_localctx, 2);
        setState(481);
        unlessStatement();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfStatementContext ------------------------------------------------------------------

NeoBasicParser::IfStatementContext::IfStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::IfThenClauseContext* NeoBasicParser::IfStatementContext::ifThenClause() {
  return getRuleContext<NeoBasicParser::IfThenClauseContext>(0);
}


size_t NeoBasicParser::IfStatementContext::getRuleIndex() const {
  return NeoBasicParser::RuleIfStatement;
}

void NeoBasicParser::IfStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfStatement(this);
}

void NeoBasicParser::IfStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfStatement(this);
}

NeoBasicParser::IfStatementContext* NeoBasicParser::ifStatement() {
  IfStatementContext *_localctx = _tracker.createInstance<IfStatementContext>(_ctx, getState());
  enterRule(_localctx, 82, NeoBasicParser::RuleIfStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(484);
    ifThenClause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfThenClauseContext ------------------------------------------------------------------

NeoBasicParser::IfThenClauseContext::IfThenClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::IfThenClauseContext::IF() {
  return getToken(NeoBasicParser::IF, 0);
}

NeoBasicParser::ExpressionContext* NeoBasicParser::IfThenClauseContext::expression() {
  return getRuleContext<NeoBasicParser::ExpressionContext>(0);
}

tree::TerminalNode* NeoBasicParser::IfThenClauseContext::THEN() {
  return getToken(NeoBasicParser::THEN, 0);
}

NeoBasicParser::SimpleStatementContext* NeoBasicParser::IfThenClauseContext::simpleStatement() {
  return getRuleContext<NeoBasicParser::SimpleStatementContext>(0);
}


size_t NeoBasicParser::IfThenClauseContext::getRuleIndex() const {
  return NeoBasicParser::RuleIfThenClause;
}

void NeoBasicParser::IfThenClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfThenClause(this);
}

void NeoBasicParser::IfThenClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfThenClause(this);
}

NeoBasicParser::IfThenClauseContext* NeoBasicParser::ifThenClause() {
  IfThenClauseContext *_localctx = _tracker.createInstance<IfThenClauseContext>(_ctx, getState());
  enterRule(_localctx, 84, NeoBasicParser::RuleIfThenClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(486);
    match(NeoBasicParser::IF);
    setState(487);
    expression(0);
    setState(488);
    match(NeoBasicParser::THEN);
    setState(489);
    simpleStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnlessStatementContext ------------------------------------------------------------------

NeoBasicParser::UnlessStatementContext::UnlessStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::UnlessClauseContext* NeoBasicParser::UnlessStatementContext::unlessClause() {
  return getRuleContext<NeoBasicParser::UnlessClauseContext>(0);
}


size_t NeoBasicParser::UnlessStatementContext::getRuleIndex() const {
  return NeoBasicParser::RuleUnlessStatement;
}

void NeoBasicParser::UnlessStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnlessStatement(this);
}

void NeoBasicParser::UnlessStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnlessStatement(this);
}

NeoBasicParser::UnlessStatementContext* NeoBasicParser::unlessStatement() {
  UnlessStatementContext *_localctx = _tracker.createInstance<UnlessStatementContext>(_ctx, getState());
  enterRule(_localctx, 86, NeoBasicParser::RuleUnlessStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(491);
    unlessClause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnlessClauseContext ------------------------------------------------------------------

NeoBasicParser::UnlessClauseContext::UnlessClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::SimpleStatementContext* NeoBasicParser::UnlessClauseContext::simpleStatement() {
  return getRuleContext<NeoBasicParser::SimpleStatementContext>(0);
}

tree::TerminalNode* NeoBasicParser::UnlessClauseContext::UNLESS() {
  return getToken(NeoBasicParser::UNLESS, 0);
}

NeoBasicParser::ExpressionContext* NeoBasicParser::UnlessClauseContext::expression() {
  return getRuleContext<NeoBasicParser::ExpressionContext>(0);
}


size_t NeoBasicParser::UnlessClauseContext::getRuleIndex() const {
  return NeoBasicParser::RuleUnlessClause;
}

void NeoBasicParser::UnlessClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnlessClause(this);
}

void NeoBasicParser::UnlessClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnlessClause(this);
}

NeoBasicParser::UnlessClauseContext* NeoBasicParser::unlessClause() {
  UnlessClauseContext *_localctx = _tracker.createInstance<UnlessClauseContext>(_ctx, getState());
  enterRule(_localctx, 88, NeoBasicParser::RuleUnlessClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(493);
    simpleStatement();
    setState(494);
    match(NeoBasicParser::UNLESS);
    setState(495);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrefixUnaryOperatorContext ------------------------------------------------------------------

NeoBasicParser::PrefixUnaryOperatorContext::PrefixUnaryOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::UnaryArithmeticOperatorContext* NeoBasicParser::PrefixUnaryOperatorContext::unaryArithmeticOperator() {
  return getRuleContext<NeoBasicParser::UnaryArithmeticOperatorContext>(0);
}

NeoBasicParser::UnaryBitwiseOperatorContext* NeoBasicParser::PrefixUnaryOperatorContext::unaryBitwiseOperator() {
  return getRuleContext<NeoBasicParser::UnaryBitwiseOperatorContext>(0);
}

NeoBasicParser::UnaryLogicalOperatorContext* NeoBasicParser::PrefixUnaryOperatorContext::unaryLogicalOperator() {
  return getRuleContext<NeoBasicParser::UnaryLogicalOperatorContext>(0);
}

NeoBasicParser::UnarySpreadOperatorContext* NeoBasicParser::PrefixUnaryOperatorContext::unarySpreadOperator() {
  return getRuleContext<NeoBasicParser::UnarySpreadOperatorContext>(0);
}

NeoBasicParser::UnarySortOperatorContext* NeoBasicParser::PrefixUnaryOperatorContext::unarySortOperator() {
  return getRuleContext<NeoBasicParser::UnarySortOperatorContext>(0);
}

NeoBasicParser::UnaryMetaOperatorContext* NeoBasicParser::PrefixUnaryOperatorContext::unaryMetaOperator() {
  return getRuleContext<NeoBasicParser::UnaryMetaOperatorContext>(0);
}


size_t NeoBasicParser::PrefixUnaryOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RulePrefixUnaryOperator;
}

void NeoBasicParser::PrefixUnaryOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrefixUnaryOperator(this);
}

void NeoBasicParser::PrefixUnaryOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrefixUnaryOperator(this);
}

NeoBasicParser::PrefixUnaryOperatorContext* NeoBasicParser::prefixUnaryOperator() {
  PrefixUnaryOperatorContext *_localctx = _tracker.createInstance<PrefixUnaryOperatorContext>(_ctx, getState());
  enterRule(_localctx, 90, NeoBasicParser::RulePrefixUnaryOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(503);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::PLUS:
      case NeoBasicParser::MINUS:
      case NeoBasicParser::INCREMENT:
      case NeoBasicParser::DECREMENT:
      case NeoBasicParser::SQUARE_POWER:
      case NeoBasicParser::SQUARE_ROOT:
      case NeoBasicParser::FACTORIAL: {
        enterOuterAlt(_localctx, 1);
        setState(497);
        unaryArithmeticOperator();
        break;
      }

      case NeoBasicParser::TILDE:
      case NeoBasicParser::BIT_NEGATION: {
        enterOuterAlt(_localctx, 2);
        setState(498);
        unaryBitwiseOperator();
        break;
      }

      case NeoBasicParser::NOT: {
        enterOuterAlt(_localctx, 3);
        setState(499);
        unaryLogicalOperator();
        break;
      }

      case NeoBasicParser::ELLIPSIS: {
        enterOuterAlt(_localctx, 4);
        setState(500);
        unarySpreadOperator();
        break;
      }

      case NeoBasicParser::CARET:
      case NeoBasicParser::SORTING: {
        enterOuterAlt(_localctx, 5);
        setState(501);
        unarySortOperator();
        break;
      }

      case NeoBasicParser::TYPEOF:
      case NeoBasicParser::SIZEOF: {
        enterOuterAlt(_localctx, 6);
        setState(502);
        unaryMetaOperator();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PosfixUnaryOperatorContext ------------------------------------------------------------------

NeoBasicParser::PosfixUnaryOperatorContext::PosfixUnaryOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::UnarySortOperatorContext* NeoBasicParser::PosfixUnaryOperatorContext::unarySortOperator() {
  return getRuleContext<NeoBasicParser::UnarySortOperatorContext>(0);
}

NeoBasicParser::UnaryCloneOperatorContext* NeoBasicParser::PosfixUnaryOperatorContext::unaryCloneOperator() {
  return getRuleContext<NeoBasicParser::UnaryCloneOperatorContext>(0);
}


size_t NeoBasicParser::PosfixUnaryOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RulePosfixUnaryOperator;
}

void NeoBasicParser::PosfixUnaryOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPosfixUnaryOperator(this);
}

void NeoBasicParser::PosfixUnaryOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPosfixUnaryOperator(this);
}

NeoBasicParser::PosfixUnaryOperatorContext* NeoBasicParser::posfixUnaryOperator() {
  PosfixUnaryOperatorContext *_localctx = _tracker.createInstance<PosfixUnaryOperatorContext>(_ctx, getState());
  enterRule(_localctx, 92, NeoBasicParser::RulePosfixUnaryOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(507);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::CARET:
      case NeoBasicParser::SORTING: {
        enterOuterAlt(_localctx, 1);
        setState(505);
        unarySortOperator();
        break;
      }

      case NeoBasicParser::EQUAL:
      case NeoBasicParser::DEEP_CLONING: {
        enterOuterAlt(_localctx, 2);
        setState(506);
        unaryCloneOperator();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnaryArithmeticOperatorContext ------------------------------------------------------------------

NeoBasicParser::UnaryArithmeticOperatorContext::UnaryArithmeticOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::UnaryArithmeticOperatorContext::PLUS() {
  return getToken(NeoBasicParser::PLUS, 0);
}

tree::TerminalNode* NeoBasicParser::UnaryArithmeticOperatorContext::MINUS() {
  return getToken(NeoBasicParser::MINUS, 0);
}

tree::TerminalNode* NeoBasicParser::UnaryArithmeticOperatorContext::INCREMENT() {
  return getToken(NeoBasicParser::INCREMENT, 0);
}

tree::TerminalNode* NeoBasicParser::UnaryArithmeticOperatorContext::DECREMENT() {
  return getToken(NeoBasicParser::DECREMENT, 0);
}

tree::TerminalNode* NeoBasicParser::UnaryArithmeticOperatorContext::SQUARE_POWER() {
  return getToken(NeoBasicParser::SQUARE_POWER, 0);
}

tree::TerminalNode* NeoBasicParser::UnaryArithmeticOperatorContext::SQUARE_ROOT() {
  return getToken(NeoBasicParser::SQUARE_ROOT, 0);
}

tree::TerminalNode* NeoBasicParser::UnaryArithmeticOperatorContext::FACTORIAL() {
  return getToken(NeoBasicParser::FACTORIAL, 0);
}


size_t NeoBasicParser::UnaryArithmeticOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleUnaryArithmeticOperator;
}

void NeoBasicParser::UnaryArithmeticOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryArithmeticOperator(this);
}

void NeoBasicParser::UnaryArithmeticOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryArithmeticOperator(this);
}

NeoBasicParser::UnaryArithmeticOperatorContext* NeoBasicParser::unaryArithmeticOperator() {
  UnaryArithmeticOperatorContext *_localctx = _tracker.createInstance<UnaryArithmeticOperatorContext>(_ctx, getState());
  enterRule(_localctx, 94, NeoBasicParser::RuleUnaryArithmeticOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(509);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4362875023917056) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnaryBitwiseOperatorContext ------------------------------------------------------------------

NeoBasicParser::UnaryBitwiseOperatorContext::UnaryBitwiseOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::UnaryBitwiseOperatorContext::TILDE() {
  return getToken(NeoBasicParser::TILDE, 0);
}

tree::TerminalNode* NeoBasicParser::UnaryBitwiseOperatorContext::BIT_NEGATION() {
  return getToken(NeoBasicParser::BIT_NEGATION, 0);
}


size_t NeoBasicParser::UnaryBitwiseOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleUnaryBitwiseOperator;
}

void NeoBasicParser::UnaryBitwiseOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryBitwiseOperator(this);
}

void NeoBasicParser::UnaryBitwiseOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryBitwiseOperator(this);
}

NeoBasicParser::UnaryBitwiseOperatorContext* NeoBasicParser::unaryBitwiseOperator() {
  UnaryBitwiseOperatorContext *_localctx = _tracker.createInstance<UnaryBitwiseOperatorContext>(_ctx, getState());
  enterRule(_localctx, 96, NeoBasicParser::RuleUnaryBitwiseOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(511);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::TILDE

    || _la == NeoBasicParser::BIT_NEGATION)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnaryLogicalOperatorContext ------------------------------------------------------------------

NeoBasicParser::UnaryLogicalOperatorContext::UnaryLogicalOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::UnaryLogicalOperatorContext::NOT() {
  return getToken(NeoBasicParser::NOT, 0);
}


size_t NeoBasicParser::UnaryLogicalOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleUnaryLogicalOperator;
}

void NeoBasicParser::UnaryLogicalOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryLogicalOperator(this);
}

void NeoBasicParser::UnaryLogicalOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryLogicalOperator(this);
}

NeoBasicParser::UnaryLogicalOperatorContext* NeoBasicParser::unaryLogicalOperator() {
  UnaryLogicalOperatorContext *_localctx = _tracker.createInstance<UnaryLogicalOperatorContext>(_ctx, getState());
  enterRule(_localctx, 98, NeoBasicParser::RuleUnaryLogicalOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(513);
    match(NeoBasicParser::NOT);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnarySpreadOperatorContext ------------------------------------------------------------------

NeoBasicParser::UnarySpreadOperatorContext::UnarySpreadOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::UnarySpreadOperatorContext::ELLIPSIS() {
  return getToken(NeoBasicParser::ELLIPSIS, 0);
}


size_t NeoBasicParser::UnarySpreadOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleUnarySpreadOperator;
}

void NeoBasicParser::UnarySpreadOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnarySpreadOperator(this);
}

void NeoBasicParser::UnarySpreadOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnarySpreadOperator(this);
}

NeoBasicParser::UnarySpreadOperatorContext* NeoBasicParser::unarySpreadOperator() {
  UnarySpreadOperatorContext *_localctx = _tracker.createInstance<UnarySpreadOperatorContext>(_ctx, getState());
  enterRule(_localctx, 100, NeoBasicParser::RuleUnarySpreadOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(515);
    match(NeoBasicParser::ELLIPSIS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnarySortOperatorContext ------------------------------------------------------------------

NeoBasicParser::UnarySortOperatorContext::UnarySortOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::UnarySortOperatorContext::CARET() {
  return getToken(NeoBasicParser::CARET, 0);
}

tree::TerminalNode* NeoBasicParser::UnarySortOperatorContext::SORTING() {
  return getToken(NeoBasicParser::SORTING, 0);
}


size_t NeoBasicParser::UnarySortOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleUnarySortOperator;
}

void NeoBasicParser::UnarySortOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnarySortOperator(this);
}

void NeoBasicParser::UnarySortOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnarySortOperator(this);
}

NeoBasicParser::UnarySortOperatorContext* NeoBasicParser::unarySortOperator() {
  UnarySortOperatorContext *_localctx = _tracker.createInstance<UnarySortOperatorContext>(_ctx, getState());
  enterRule(_localctx, 102, NeoBasicParser::RuleUnarySortOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(517);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::CARET

    || _la == NeoBasicParser::SORTING)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnaryCloneOperatorContext ------------------------------------------------------------------

NeoBasicParser::UnaryCloneOperatorContext::UnaryCloneOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::UnaryCloneOperatorContext::EQUAL() {
  return getToken(NeoBasicParser::EQUAL, 0);
}

tree::TerminalNode* NeoBasicParser::UnaryCloneOperatorContext::DEEP_CLONING() {
  return getToken(NeoBasicParser::DEEP_CLONING, 0);
}


size_t NeoBasicParser::UnaryCloneOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleUnaryCloneOperator;
}

void NeoBasicParser::UnaryCloneOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryCloneOperator(this);
}

void NeoBasicParser::UnaryCloneOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryCloneOperator(this);
}

NeoBasicParser::UnaryCloneOperatorContext* NeoBasicParser::unaryCloneOperator() {
  UnaryCloneOperatorContext *_localctx = _tracker.createInstance<UnaryCloneOperatorContext>(_ctx, getState());
  enterRule(_localctx, 104, NeoBasicParser::RuleUnaryCloneOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(519);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::EQUAL

    || _la == NeoBasicParser::DEEP_CLONING)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnaryMetaOperatorContext ------------------------------------------------------------------

NeoBasicParser::UnaryMetaOperatorContext::UnaryMetaOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::UnaryMetaOperatorContext::TYPEOF() {
  return getToken(NeoBasicParser::TYPEOF, 0);
}

tree::TerminalNode* NeoBasicParser::UnaryMetaOperatorContext::SIZEOF() {
  return getToken(NeoBasicParser::SIZEOF, 0);
}


size_t NeoBasicParser::UnaryMetaOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleUnaryMetaOperator;
}

void NeoBasicParser::UnaryMetaOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryMetaOperator(this);
}

void NeoBasicParser::UnaryMetaOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryMetaOperator(this);
}

NeoBasicParser::UnaryMetaOperatorContext* NeoBasicParser::unaryMetaOperator() {
  UnaryMetaOperatorContext *_localctx = _tracker.createInstance<UnaryMetaOperatorContext>(_ctx, getState());
  enterRule(_localctx, 106, NeoBasicParser::RuleUnaryMetaOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(521);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::TYPEOF

    || _la == NeoBasicParser::SIZEOF)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryExponentialOperatorContext ------------------------------------------------------------------

NeoBasicParser::BinaryExponentialOperatorContext::BinaryExponentialOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BinaryExponentialOperatorContext::SQUARE_POWER() {
  return getToken(NeoBasicParser::SQUARE_POWER, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryExponentialOperatorContext::SQUARE_ROOT() {
  return getToken(NeoBasicParser::SQUARE_ROOT, 0);
}


size_t NeoBasicParser::BinaryExponentialOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBinaryExponentialOperator;
}

void NeoBasicParser::BinaryExponentialOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryExponentialOperator(this);
}

void NeoBasicParser::BinaryExponentialOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryExponentialOperator(this);
}

NeoBasicParser::BinaryExponentialOperatorContext* NeoBasicParser::binaryExponentialOperator() {
  BinaryExponentialOperatorContext *_localctx = _tracker.createInstance<BinaryExponentialOperatorContext>(_ctx, getState());
  enterRule(_localctx, 108, NeoBasicParser::RuleBinaryExponentialOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(523);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::SQUARE_POWER

    || _la == NeoBasicParser::SQUARE_ROOT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryMultiplicativeOperatorContext ------------------------------------------------------------------

NeoBasicParser::BinaryMultiplicativeOperatorContext::BinaryMultiplicativeOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BinaryMultiplicativeOperatorContext::ASTERISK() {
  return getToken(NeoBasicParser::ASTERISK, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryMultiplicativeOperatorContext::SLASH() {
  return getToken(NeoBasicParser::SLASH, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryMultiplicativeOperatorContext::DIVISION() {
  return getToken(NeoBasicParser::DIVISION, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryMultiplicativeOperatorContext::QUOTIENT() {
  return getToken(NeoBasicParser::QUOTIENT, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryMultiplicativeOperatorContext::PERCENT() {
  return getToken(NeoBasicParser::PERCENT, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryMultiplicativeOperatorContext::PERCENTAGE_RATE() {
  return getToken(NeoBasicParser::PERCENTAGE_RATE, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryMultiplicativeOperatorContext::PERCENTAGE_AMOUNT() {
  return getToken(NeoBasicParser::PERCENTAGE_AMOUNT, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryMultiplicativeOperatorContext::PERCENTAGE_INCREASE() {
  return getToken(NeoBasicParser::PERCENTAGE_INCREASE, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryMultiplicativeOperatorContext::PERCENTAGE_DECREASE() {
  return getToken(NeoBasicParser::PERCENTAGE_DECREASE, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryMultiplicativeOperatorContext::PERCENTAGE_VARIATION() {
  return getToken(NeoBasicParser::PERCENTAGE_VARIATION, 0);
}


size_t NeoBasicParser::BinaryMultiplicativeOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBinaryMultiplicativeOperator;
}

void NeoBasicParser::BinaryMultiplicativeOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryMultiplicativeOperator(this);
}

void NeoBasicParser::BinaryMultiplicativeOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryMultiplicativeOperator(this);
}

NeoBasicParser::BinaryMultiplicativeOperatorContext* NeoBasicParser::binaryMultiplicativeOperator() {
  BinaryMultiplicativeOperatorContext *_localctx = _tracker.createInstance<BinaryMultiplicativeOperatorContext>(_ctx, getState());
  enterRule(_localctx, 110, NeoBasicParser::RuleBinaryMultiplicativeOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(525);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2269814212257644544) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryAdditiveOperatorContext ------------------------------------------------------------------

NeoBasicParser::BinaryAdditiveOperatorContext::BinaryAdditiveOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BinaryAdditiveOperatorContext::PLUS() {
  return getToken(NeoBasicParser::PLUS, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryAdditiveOperatorContext::MINUS() {
  return getToken(NeoBasicParser::MINUS, 0);
}


size_t NeoBasicParser::BinaryAdditiveOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBinaryAdditiveOperator;
}

void NeoBasicParser::BinaryAdditiveOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryAdditiveOperator(this);
}

void NeoBasicParser::BinaryAdditiveOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryAdditiveOperator(this);
}

NeoBasicParser::BinaryAdditiveOperatorContext* NeoBasicParser::binaryAdditiveOperator() {
  BinaryAdditiveOperatorContext *_localctx = _tracker.createInstance<BinaryAdditiveOperatorContext>(_ctx, getState());
  enterRule(_localctx, 112, NeoBasicParser::RuleBinaryAdditiveOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(527);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::PLUS

    || _la == NeoBasicParser::MINUS)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitShiftOperatorContext ------------------------------------------------------------------

NeoBasicParser::BitShiftOperatorContext::BitShiftOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BitShiftOperatorContext::DOUBLE_LEFT_ANGLE() {
  return getToken(NeoBasicParser::DOUBLE_LEFT_ANGLE, 0);
}

tree::TerminalNode* NeoBasicParser::BitShiftOperatorContext::DOUBLE_RIGHT_ANGLE() {
  return getToken(NeoBasicParser::DOUBLE_RIGHT_ANGLE, 0);
}

tree::TerminalNode* NeoBasicParser::BitShiftOperatorContext::UNSIGNED_RIGHT_SHIFT() {
  return getToken(NeoBasicParser::UNSIGNED_RIGHT_SHIFT, 0);
}


size_t NeoBasicParser::BitShiftOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBitShiftOperator;
}

void NeoBasicParser::BitShiftOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitShiftOperator(this);
}

void NeoBasicParser::BitShiftOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitShiftOperator(this);
}

NeoBasicParser::BitShiftOperatorContext* NeoBasicParser::bitShiftOperator() {
  BitShiftOperatorContext *_localctx = _tracker.createInstance<BitShiftOperatorContext>(_ctx, getState());
  enterRule(_localctx, 114, NeoBasicParser::RuleBitShiftOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(529);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 4611689316962271232) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitConjunctionOperatorContext ------------------------------------------------------------------

NeoBasicParser::BitConjunctionOperatorContext::BitConjunctionOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BitConjunctionOperatorContext::AMPERSAND() {
  return getToken(NeoBasicParser::AMPERSAND, 0);
}

tree::TerminalNode* NeoBasicParser::BitConjunctionOperatorContext::BIT_CLEAR() {
  return getToken(NeoBasicParser::BIT_CLEAR, 0);
}


size_t NeoBasicParser::BitConjunctionOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBitConjunctionOperator;
}

void NeoBasicParser::BitConjunctionOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitConjunctionOperator(this);
}

void NeoBasicParser::BitConjunctionOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitConjunctionOperator(this);
}

NeoBasicParser::BitConjunctionOperatorContext* NeoBasicParser::bitConjunctionOperator() {
  BitConjunctionOperatorContext *_localctx = _tracker.createInstance<BitConjunctionOperatorContext>(_ctx, getState());
  enterRule(_localctx, 116, NeoBasicParser::RuleBitConjunctionOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(531);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::AMPERSAND

    || _la == NeoBasicParser::BIT_CLEAR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitExclusiveDisjunctionOperatorContext ------------------------------------------------------------------

NeoBasicParser::BitExclusiveDisjunctionOperatorContext::BitExclusiveDisjunctionOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BitExclusiveDisjunctionOperatorContext::CARET() {
  return getToken(NeoBasicParser::CARET, 0);
}


size_t NeoBasicParser::BitExclusiveDisjunctionOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBitExclusiveDisjunctionOperator;
}

void NeoBasicParser::BitExclusiveDisjunctionOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitExclusiveDisjunctionOperator(this);
}

void NeoBasicParser::BitExclusiveDisjunctionOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitExclusiveDisjunctionOperator(this);
}

NeoBasicParser::BitExclusiveDisjunctionOperatorContext* NeoBasicParser::bitExclusiveDisjunctionOperator() {
  BitExclusiveDisjunctionOperatorContext *_localctx = _tracker.createInstance<BitExclusiveDisjunctionOperatorContext>(_ctx, getState());
  enterRule(_localctx, 118, NeoBasicParser::RuleBitExclusiveDisjunctionOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(533);
    match(NeoBasicParser::CARET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitDisjunctionOperatorContext ------------------------------------------------------------------

NeoBasicParser::BitDisjunctionOperatorContext::BitDisjunctionOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BitDisjunctionOperatorContext::PIPE() {
  return getToken(NeoBasicParser::PIPE, 0);
}


size_t NeoBasicParser::BitDisjunctionOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBitDisjunctionOperator;
}

void NeoBasicParser::BitDisjunctionOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitDisjunctionOperator(this);
}

void NeoBasicParser::BitDisjunctionOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitDisjunctionOperator(this);
}

NeoBasicParser::BitDisjunctionOperatorContext* NeoBasicParser::bitDisjunctionOperator() {
  BitDisjunctionOperatorContext *_localctx = _tracker.createInstance<BitDisjunctionOperatorContext>(_ctx, getState());
  enterRule(_localctx, 120, NeoBasicParser::RuleBitDisjunctionOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(535);
    match(NeoBasicParser::PIPE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryComparisonOperatorContext ------------------------------------------------------------------

NeoBasicParser::BinaryComparisonOperatorContext::BinaryComparisonOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BinaryComparisonOperatorContext::ELVIS_TEST() {
  return getToken(NeoBasicParser::ELVIS_TEST, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryComparisonOperatorContext::THREE_WAY_TEST() {
  return getToken(NeoBasicParser::THREE_WAY_TEST, 0);
}


size_t NeoBasicParser::BinaryComparisonOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBinaryComparisonOperator;
}

void NeoBasicParser::BinaryComparisonOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryComparisonOperator(this);
}

void NeoBasicParser::BinaryComparisonOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryComparisonOperator(this);
}

NeoBasicParser::BinaryComparisonOperatorContext* NeoBasicParser::binaryComparisonOperator() {
  BinaryComparisonOperatorContext *_localctx = _tracker.createInstance<BinaryComparisonOperatorContext>(_ctx, getState());
  enterRule(_localctx, 122, NeoBasicParser::RuleBinaryComparisonOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(537);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::ELVIS_TEST

    || _la == NeoBasicParser::THREE_WAY_TEST)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryRelationalOperatorContext ------------------------------------------------------------------

NeoBasicParser::BinaryRelationalOperatorContext::BinaryRelationalOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BinaryRelationalOperatorContext::STRICT_EQUALITY() {
  return getToken(NeoBasicParser::STRICT_EQUALITY, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryRelationalOperatorContext::STRICT_INEQUALITY() {
  return getToken(NeoBasicParser::STRICT_INEQUALITY, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryRelationalOperatorContext::LOOSE_EQUALITY() {
  return getToken(NeoBasicParser::LOOSE_EQUALITY, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryRelationalOperatorContext::LOOSE_INEQUALITY() {
  return getToken(NeoBasicParser::LOOSE_INEQUALITY, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryRelationalOperatorContext::LEFT_ANGLE() {
  return getToken(NeoBasicParser::LEFT_ANGLE, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryRelationalOperatorContext::LESS_OR_EQUALS() {
  return getToken(NeoBasicParser::LESS_OR_EQUALS, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryRelationalOperatorContext::RIGHT_ANGLE() {
  return getToken(NeoBasicParser::RIGHT_ANGLE, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryRelationalOperatorContext::GREATER_OR_EQUALS() {
  return getToken(NeoBasicParser::GREATER_OR_EQUALS, 0);
}


size_t NeoBasicParser::BinaryRelationalOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBinaryRelationalOperator;
}

void NeoBasicParser::BinaryRelationalOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryRelationalOperator(this);
}

void NeoBasicParser::BinaryRelationalOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryRelationalOperator(this);
}

NeoBasicParser::BinaryRelationalOperatorContext* NeoBasicParser::binaryRelationalOperator() {
  BinaryRelationalOperatorContext *_localctx = _tracker.createInstance<BinaryRelationalOperatorContext>(_ctx, getState());
  enterRule(_localctx, 124, NeoBasicParser::RuleBinaryRelationalOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(539);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::LEFT_ANGLE

    || _la == NeoBasicParser::RIGHT_ANGLE || ((((_la - 67) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 67)) & 63) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryConditionalOperatorContext ------------------------------------------------------------------

NeoBasicParser::BinaryConditionalOperatorContext::BinaryConditionalOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BinaryConditionalOperatorContext::IS() {
  return getToken(NeoBasicParser::IS, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryConditionalOperatorContext::NOT() {
  return getToken(NeoBasicParser::NOT, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryConditionalOperatorContext::IN() {
  return getToken(NeoBasicParser::IN, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryConditionalOperatorContext::BETWEEN() {
  return getToken(NeoBasicParser::BETWEEN, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryConditionalOperatorContext::LIKE() {
  return getToken(NeoBasicParser::LIKE, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryConditionalOperatorContext::DIVISIBLE_BY() {
  return getToken(NeoBasicParser::DIVISIBLE_BY, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryConditionalOperatorContext::NOT_DIVISIBLE_BY() {
  return getToken(NeoBasicParser::NOT_DIVISIBLE_BY, 0);
}


size_t NeoBasicParser::BinaryConditionalOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBinaryConditionalOperator;
}

void NeoBasicParser::BinaryConditionalOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryConditionalOperator(this);
}

void NeoBasicParser::BinaryConditionalOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryConditionalOperator(this);
}

NeoBasicParser::BinaryConditionalOperatorContext* NeoBasicParser::binaryConditionalOperator() {
  BinaryConditionalOperatorContext *_localctx = _tracker.createInstance<BinaryConditionalOperatorContext>(_ctx, getState());
  enterRule(_localctx, 126, NeoBasicParser::RuleBinaryConditionalOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(555);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(541);
      match(NeoBasicParser::IS);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(542);
      match(NeoBasicParser::IS);
      setState(543);
      match(NeoBasicParser::NOT);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(544);
      match(NeoBasicParser::IN);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(545);
      match(NeoBasicParser::NOT);
      setState(546);
      match(NeoBasicParser::IN);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(547);
      match(NeoBasicParser::BETWEEN);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(548);
      match(NeoBasicParser::NOT);
      setState(549);
      match(NeoBasicParser::BETWEEN);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(550);
      match(NeoBasicParser::LIKE);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(551);
      match(NeoBasicParser::NOT);
      setState(552);
      match(NeoBasicParser::LIKE);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(553);
      match(NeoBasicParser::DIVISIBLE_BY);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(554);
      match(NeoBasicParser::NOT_DIVISIBLE_BY);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryConjunctionOperatorContext ------------------------------------------------------------------

NeoBasicParser::BinaryConjunctionOperatorContext::BinaryConjunctionOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BinaryConjunctionOperatorContext::AND() {
  return getToken(NeoBasicParser::AND, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryConjunctionOperatorContext::NAND() {
  return getToken(NeoBasicParser::NAND, 0);
}


size_t NeoBasicParser::BinaryConjunctionOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBinaryConjunctionOperator;
}

void NeoBasicParser::BinaryConjunctionOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryConjunctionOperator(this);
}

void NeoBasicParser::BinaryConjunctionOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryConjunctionOperator(this);
}

NeoBasicParser::BinaryConjunctionOperatorContext* NeoBasicParser::binaryConjunctionOperator() {
  BinaryConjunctionOperatorContext *_localctx = _tracker.createInstance<BinaryConjunctionOperatorContext>(_ctx, getState());
  enterRule(_localctx, 128, NeoBasicParser::RuleBinaryConjunctionOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(557);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::AND

    || _la == NeoBasicParser::NAND)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryExclusiveDisjunctionOperatorContext ------------------------------------------------------------------

NeoBasicParser::BinaryExclusiveDisjunctionOperatorContext::BinaryExclusiveDisjunctionOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BinaryExclusiveDisjunctionOperatorContext::XOR() {
  return getToken(NeoBasicParser::XOR, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryExclusiveDisjunctionOperatorContext::NXOR() {
  return getToken(NeoBasicParser::NXOR, 0);
}


size_t NeoBasicParser::BinaryExclusiveDisjunctionOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBinaryExclusiveDisjunctionOperator;
}

void NeoBasicParser::BinaryExclusiveDisjunctionOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryExclusiveDisjunctionOperator(this);
}

void NeoBasicParser::BinaryExclusiveDisjunctionOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryExclusiveDisjunctionOperator(this);
}

NeoBasicParser::BinaryExclusiveDisjunctionOperatorContext* NeoBasicParser::binaryExclusiveDisjunctionOperator() {
  BinaryExclusiveDisjunctionOperatorContext *_localctx = _tracker.createInstance<BinaryExclusiveDisjunctionOperatorContext>(_ctx, getState());
  enterRule(_localctx, 130, NeoBasicParser::RuleBinaryExclusiveDisjunctionOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(559);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::XOR

    || _la == NeoBasicParser::NXOR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryDisjunctionOperatorContext ------------------------------------------------------------------

NeoBasicParser::BinaryDisjunctionOperatorContext::BinaryDisjunctionOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BinaryDisjunctionOperatorContext::OR() {
  return getToken(NeoBasicParser::OR, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryDisjunctionOperatorContext::NOR() {
  return getToken(NeoBasicParser::NOR, 0);
}


size_t NeoBasicParser::BinaryDisjunctionOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBinaryDisjunctionOperator;
}

void NeoBasicParser::BinaryDisjunctionOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryDisjunctionOperator(this);
}

void NeoBasicParser::BinaryDisjunctionOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryDisjunctionOperator(this);
}

NeoBasicParser::BinaryDisjunctionOperatorContext* NeoBasicParser::binaryDisjunctionOperator() {
  BinaryDisjunctionOperatorContext *_localctx = _tracker.createInstance<BinaryDisjunctionOperatorContext>(_ctx, getState());
  enterRule(_localctx, 132, NeoBasicParser::RuleBinaryDisjunctionOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(561);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::OR

    || _la == NeoBasicParser::NOR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryCoalescingOperatorContext ------------------------------------------------------------------

NeoBasicParser::BinaryCoalescingOperatorContext::BinaryCoalescingOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BinaryCoalescingOperatorContext::EXCLAMATION() {
  return getToken(NeoBasicParser::EXCLAMATION, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryCoalescingOperatorContext::DOUBLE_EXCLAMATION() {
  return getToken(NeoBasicParser::DOUBLE_EXCLAMATION, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryCoalescingOperatorContext::ERROR_PROPAGATION_NONE_COALESCING() {
  return getToken(NeoBasicParser::ERROR_PROPAGATION_NONE_COALESCING, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryCoalescingOperatorContext::QUESTION() {
  return getToken(NeoBasicParser::QUESTION, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryCoalescingOperatorContext::DOUBLE_QUESTION() {
  return getToken(NeoBasicParser::DOUBLE_QUESTION, 0);
}

tree::TerminalNode* NeoBasicParser::BinaryCoalescingOperatorContext::OTHERWISE() {
  return getToken(NeoBasicParser::OTHERWISE, 0);
}


size_t NeoBasicParser::BinaryCoalescingOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleBinaryCoalescingOperator;
}

void NeoBasicParser::BinaryCoalescingOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryCoalescingOperator(this);
}

void NeoBasicParser::BinaryCoalescingOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryCoalescingOperator(this);
}

NeoBasicParser::BinaryCoalescingOperatorContext* NeoBasicParser::binaryCoalescingOperator() {
  BinaryCoalescingOperatorContext *_localctx = _tracker.createInstance<BinaryCoalescingOperatorContext>(_ctx, getState());
  enterRule(_localctx, 134, NeoBasicParser::RuleBinaryCoalescingOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(563);
    _la = _input->LA(1);
    if (!(((((_la - 13) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 13)) & 1152921506217459715) != 0) || _la == NeoBasicParser::OTHERWISE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentOperatorContext ------------------------------------------------------------------

NeoBasicParser::AssignmentOperatorContext::AssignmentOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::SingleAssignmentOperatorContext* NeoBasicParser::AssignmentOperatorContext::singleAssignmentOperator() {
  return getRuleContext<NeoBasicParser::SingleAssignmentOperatorContext>(0);
}

NeoBasicParser::MultipleAssignmentOperatorContext* NeoBasicParser::AssignmentOperatorContext::multipleAssignmentOperator() {
  return getRuleContext<NeoBasicParser::MultipleAssignmentOperatorContext>(0);
}

NeoBasicParser::CompoundAssignmentOperatorContext* NeoBasicParser::AssignmentOperatorContext::compoundAssignmentOperator() {
  return getRuleContext<NeoBasicParser::CompoundAssignmentOperatorContext>(0);
}


size_t NeoBasicParser::AssignmentOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleAssignmentOperator;
}

void NeoBasicParser::AssignmentOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentOperator(this);
}

void NeoBasicParser::AssignmentOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentOperator(this);
}

NeoBasicParser::AssignmentOperatorContext* NeoBasicParser::assignmentOperator() {
  AssignmentOperatorContext *_localctx = _tracker.createInstance<AssignmentOperatorContext>(_ctx, getState());
  enterRule(_localctx, 136, NeoBasicParser::RuleAssignmentOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(568);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(565);
      singleAssignmentOperator();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(566);
      multipleAssignmentOperator();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(567);
      compoundAssignmentOperator();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SingleAssignmentOperatorContext ------------------------------------------------------------------

NeoBasicParser::SingleAssignmentOperatorContext::SingleAssignmentOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::SingleAssignmentOperatorContext::EQUAL() {
  return getToken(NeoBasicParser::EQUAL, 0);
}

tree::TerminalNode* NeoBasicParser::SingleAssignmentOperatorContext::POP_ONE_ASSIGNMENT() {
  return getToken(NeoBasicParser::POP_ONE_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::SingleAssignmentOperatorContext::PULL_ALL_ASSIGNMENT() {
  return getToken(NeoBasicParser::PULL_ALL_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::SingleAssignmentOperatorContext::PIPE_ASSIGNMENT() {
  return getToken(NeoBasicParser::PIPE_ASSIGNMENT, 0);
}


size_t NeoBasicParser::SingleAssignmentOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleSingleAssignmentOperator;
}

void NeoBasicParser::SingleAssignmentOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingleAssignmentOperator(this);
}

void NeoBasicParser::SingleAssignmentOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingleAssignmentOperator(this);
}

NeoBasicParser::SingleAssignmentOperatorContext* NeoBasicParser::singleAssignmentOperator() {
  SingleAssignmentOperatorContext *_localctx = _tracker.createInstance<SingleAssignmentOperatorContext>(_ctx, getState());
  enterRule(_localctx, 138, NeoBasicParser::RuleSingleAssignmentOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(570);
    _la = _input->LA(1);
    if (!(((((_la - 31) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 31)) & 61572651155457) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MultipleAssignmentOperatorContext ------------------------------------------------------------------

NeoBasicParser::MultipleAssignmentOperatorContext::MultipleAssignmentOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::MultipleAssignmentOperatorContext::EQUAL() {
  return getToken(NeoBasicParser::EQUAL, 0);
}

tree::TerminalNode* NeoBasicParser::MultipleAssignmentOperatorContext::DESTRUCTURING_ASSIGNMENT() {
  return getToken(NeoBasicParser::DESTRUCTURING_ASSIGNMENT, 0);
}


size_t NeoBasicParser::MultipleAssignmentOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleMultipleAssignmentOperator;
}

void NeoBasicParser::MultipleAssignmentOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMultipleAssignmentOperator(this);
}

void NeoBasicParser::MultipleAssignmentOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMultipleAssignmentOperator(this);
}

NeoBasicParser::MultipleAssignmentOperatorContext* NeoBasicParser::multipleAssignmentOperator() {
  MultipleAssignmentOperatorContext *_localctx = _tracker.createInstance<MultipleAssignmentOperatorContext>(_ctx, getState());
  enterRule(_localctx, 140, NeoBasicParser::RuleMultipleAssignmentOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(572);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::EQUAL

    || _la == NeoBasicParser::DESTRUCTURING_ASSIGNMENT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompoundAssignmentOperatorContext ------------------------------------------------------------------

NeoBasicParser::CompoundAssignmentOperatorContext::CompoundAssignmentOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::ADDITION_ASSIGNMENT() {
  return getToken(NeoBasicParser::ADDITION_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::SUBTRACTION_ASSIGNMENT() {
  return getToken(NeoBasicParser::SUBTRACTION_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::MULTIPLICATION_ASSIGNMENT() {
  return getToken(NeoBasicParser::MULTIPLICATION_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::REAL_DIVISION_ASSIGNMENT() {
  return getToken(NeoBasicParser::REAL_DIVISION_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::INTEGER_DIVISION_ASSIGNMENT() {
  return getToken(NeoBasicParser::INTEGER_DIVISION_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::MODULO_ASSIGNMENT() {
  return getToken(NeoBasicParser::MODULO_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::NTH_POWER_ASSIGNMENT() {
  return getToken(NeoBasicParser::NTH_POWER_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::NTH_ROOT_ASSIGNMENT() {
  return getToken(NeoBasicParser::NTH_ROOT_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::PERCENTAGE_RATE_ASSIGNMENT() {
  return getToken(NeoBasicParser::PERCENTAGE_RATE_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::PERCENTAGE_AMOUNT_ASSIGNMENT() {
  return getToken(NeoBasicParser::PERCENTAGE_AMOUNT_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::PERCENTAGE_INCREASE_ASSIGNMENT() {
  return getToken(NeoBasicParser::PERCENTAGE_INCREASE_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::PERCENTAGE_DECREASE_ASSIGNMENT() {
  return getToken(NeoBasicParser::PERCENTAGE_DECREASE_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::PERCENTAGE_VARIATION_ASSIGNMENT() {
  return getToken(NeoBasicParser::PERCENTAGE_VARIATION_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::BIT_AND_ASSIGNMENT() {
  return getToken(NeoBasicParser::BIT_AND_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::BIT_CLEAR_ASSIGNMENT() {
  return getToken(NeoBasicParser::BIT_CLEAR_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::BIT_XOR_ASSIGNMENT() {
  return getToken(NeoBasicParser::BIT_XOR_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::BIT_OR_ASSIGNMENT() {
  return getToken(NeoBasicParser::BIT_OR_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::LEFT_SHIFT_ASSIGNMENT() {
  return getToken(NeoBasicParser::LEFT_SHIFT_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::SIGNED_RIGHT_SHIFT_ASSIGNMENT() {
  return getToken(NeoBasicParser::SIGNED_RIGHT_SHIFT_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::UNSIGNED_RIGHT_SHIFT_ASSIGNMENT() {
  return getToken(NeoBasicParser::UNSIGNED_RIGHT_SHIFT_ASSIGNMENT, 0);
}

tree::TerminalNode* NeoBasicParser::CompoundAssignmentOperatorContext::NONE_COALESCING_ASSIGNMENT() {
  return getToken(NeoBasicParser::NONE_COALESCING_ASSIGNMENT, 0);
}


size_t NeoBasicParser::CompoundAssignmentOperatorContext::getRuleIndex() const {
  return NeoBasicParser::RuleCompoundAssignmentOperator;
}

void NeoBasicParser::CompoundAssignmentOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompoundAssignmentOperator(this);
}

void NeoBasicParser::CompoundAssignmentOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompoundAssignmentOperator(this);
}

NeoBasicParser::CompoundAssignmentOperatorContext* NeoBasicParser::compoundAssignmentOperator() {
  CompoundAssignmentOperatorContext *_localctx = _tracker.createInstance<CompoundAssignmentOperatorContext>(_ctx, getState());
  enterRule(_localctx, 142, NeoBasicParser::RuleCompoundAssignmentOperator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(574);
    _la = _input->LA(1);
    if (!(((((_la - 78) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 78)) & 4194271) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelIdentifierContext ------------------------------------------------------------------

NeoBasicParser::LabelIdentifierContext::LabelIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::LabelIdentifierContext::TAG() {
  return getToken(NeoBasicParser::TAG, 0);
}


size_t NeoBasicParser::LabelIdentifierContext::getRuleIndex() const {
  return NeoBasicParser::RuleLabelIdentifier;
}

void NeoBasicParser::LabelIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabelIdentifier(this);
}

void NeoBasicParser::LabelIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabelIdentifier(this);
}

NeoBasicParser::LabelIdentifierContext* NeoBasicParser::labelIdentifier() {
  LabelIdentifierContext *_localctx = _tracker.createInstance<LabelIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 144, NeoBasicParser::RuleLabelIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(576);
    match(NeoBasicParser::TAG);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SymbolIdentifierContext ------------------------------------------------------------------

NeoBasicParser::SymbolIdentifierContext::SymbolIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::SymbolIdentifierContext::IDENTIFIER() {
  return getToken(NeoBasicParser::IDENTIFIER, 0);
}


size_t NeoBasicParser::SymbolIdentifierContext::getRuleIndex() const {
  return NeoBasicParser::RuleSymbolIdentifier;
}

void NeoBasicParser::SymbolIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSymbolIdentifier(this);
}

void NeoBasicParser::SymbolIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSymbolIdentifier(this);
}

NeoBasicParser::SymbolIdentifierContext* NeoBasicParser::symbolIdentifier() {
  SymbolIdentifierContext *_localctx = _tracker.createInstance<SymbolIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 146, NeoBasicParser::RuleSymbolIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(578);
    match(NeoBasicParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiedIdentifierContext ------------------------------------------------------------------

NeoBasicParser::QualifiedIdentifierContext::QualifiedIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> NeoBasicParser::QualifiedIdentifierContext::IDENTIFIER() {
  return getTokens(NeoBasicParser::IDENTIFIER);
}

tree::TerminalNode* NeoBasicParser::QualifiedIdentifierContext::IDENTIFIER(size_t i) {
  return getToken(NeoBasicParser::IDENTIFIER, i);
}

std::vector<tree::TerminalNode *> NeoBasicParser::QualifiedIdentifierContext::DOT() {
  return getTokens(NeoBasicParser::DOT);
}

tree::TerminalNode* NeoBasicParser::QualifiedIdentifierContext::DOT(size_t i) {
  return getToken(NeoBasicParser::DOT, i);
}


size_t NeoBasicParser::QualifiedIdentifierContext::getRuleIndex() const {
  return NeoBasicParser::RuleQualifiedIdentifier;
}

void NeoBasicParser::QualifiedIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifiedIdentifier(this);
}

void NeoBasicParser::QualifiedIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifiedIdentifier(this);
}

NeoBasicParser::QualifiedIdentifierContext* NeoBasicParser::qualifiedIdentifier() {
  QualifiedIdentifierContext *_localctx = _tracker.createInstance<QualifiedIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 148, NeoBasicParser::RuleQualifiedIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(580);
    match(NeoBasicParser::IDENTIFIER);
    setState(585);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(581);
        match(NeoBasicParser::DOT);
        setState(582);
        match(NeoBasicParser::IDENTIFIER); 
      }
      setState(587);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifiersContext ------------------------------------------------------------------

NeoBasicParser::IdentifiersContext::IdentifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> NeoBasicParser::IdentifiersContext::IDENTIFIER() {
  return getTokens(NeoBasicParser::IDENTIFIER);
}

tree::TerminalNode* NeoBasicParser::IdentifiersContext::IDENTIFIER(size_t i) {
  return getToken(NeoBasicParser::IDENTIFIER, i);
}

std::vector<tree::TerminalNode *> NeoBasicParser::IdentifiersContext::COMMA() {
  return getTokens(NeoBasicParser::COMMA);
}

tree::TerminalNode* NeoBasicParser::IdentifiersContext::COMMA(size_t i) {
  return getToken(NeoBasicParser::COMMA, i);
}


size_t NeoBasicParser::IdentifiersContext::getRuleIndex() const {
  return NeoBasicParser::RuleIdentifiers;
}

void NeoBasicParser::IdentifiersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifiers(this);
}

void NeoBasicParser::IdentifiersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifiers(this);
}

NeoBasicParser::IdentifiersContext* NeoBasicParser::identifiers() {
  IdentifiersContext *_localctx = _tracker.createInstance<IdentifiersContext>(_ctx, getState());
  enterRule(_localctx, 150, NeoBasicParser::RuleIdentifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(588);
    match(NeoBasicParser::IDENTIFIER);
    setState(593);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NeoBasicParser::COMMA) {
      setState(589);
      match(NeoBasicParser::COMMA);
      setState(590);
      match(NeoBasicParser::IDENTIFIER);
      setState(595);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SymbolIdentifiersContext ------------------------------------------------------------------

NeoBasicParser::SymbolIdentifiersContext::SymbolIdentifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NeoBasicParser::SymbolIdentifierContext *> NeoBasicParser::SymbolIdentifiersContext::symbolIdentifier() {
  return getRuleContexts<NeoBasicParser::SymbolIdentifierContext>();
}

NeoBasicParser::SymbolIdentifierContext* NeoBasicParser::SymbolIdentifiersContext::symbolIdentifier(size_t i) {
  return getRuleContext<NeoBasicParser::SymbolIdentifierContext>(i);
}

std::vector<tree::TerminalNode *> NeoBasicParser::SymbolIdentifiersContext::COMMA() {
  return getTokens(NeoBasicParser::COMMA);
}

tree::TerminalNode* NeoBasicParser::SymbolIdentifiersContext::COMMA(size_t i) {
  return getToken(NeoBasicParser::COMMA, i);
}


size_t NeoBasicParser::SymbolIdentifiersContext::getRuleIndex() const {
  return NeoBasicParser::RuleSymbolIdentifiers;
}

void NeoBasicParser::SymbolIdentifiersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSymbolIdentifiers(this);
}

void NeoBasicParser::SymbolIdentifiersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSymbolIdentifiers(this);
}

NeoBasicParser::SymbolIdentifiersContext* NeoBasicParser::symbolIdentifiers() {
  SymbolIdentifiersContext *_localctx = _tracker.createInstance<SymbolIdentifiersContext>(_ctx, getState());
  enterRule(_localctx, 152, NeoBasicParser::RuleSymbolIdentifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(596);
    symbolIdentifier();
    setState(601);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NeoBasicParser::COMMA) {
      setState(597);
      match(NeoBasicParser::COMMA);
      setState(598);
      symbolIdentifier();
      setState(603);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiedIdentifiersContext ------------------------------------------------------------------

NeoBasicParser::QualifiedIdentifiersContext::QualifiedIdentifiersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NeoBasicParser::QualifiedIdentifierContext *> NeoBasicParser::QualifiedIdentifiersContext::qualifiedIdentifier() {
  return getRuleContexts<NeoBasicParser::QualifiedIdentifierContext>();
}

NeoBasicParser::QualifiedIdentifierContext* NeoBasicParser::QualifiedIdentifiersContext::qualifiedIdentifier(size_t i) {
  return getRuleContext<NeoBasicParser::QualifiedIdentifierContext>(i);
}

std::vector<tree::TerminalNode *> NeoBasicParser::QualifiedIdentifiersContext::COMMA() {
  return getTokens(NeoBasicParser::COMMA);
}

tree::TerminalNode* NeoBasicParser::QualifiedIdentifiersContext::COMMA(size_t i) {
  return getToken(NeoBasicParser::COMMA, i);
}


size_t NeoBasicParser::QualifiedIdentifiersContext::getRuleIndex() const {
  return NeoBasicParser::RuleQualifiedIdentifiers;
}

void NeoBasicParser::QualifiedIdentifiersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifiedIdentifiers(this);
}

void NeoBasicParser::QualifiedIdentifiersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifiedIdentifiers(this);
}

NeoBasicParser::QualifiedIdentifiersContext* NeoBasicParser::qualifiedIdentifiers() {
  QualifiedIdentifiersContext *_localctx = _tracker.createInstance<QualifiedIdentifiersContext>(_ctx, getState());
  enterRule(_localctx, 154, NeoBasicParser::RuleQualifiedIdentifiers);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(604);
    qualifiedIdentifier();
    setState(609);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NeoBasicParser::COMMA) {
      setState(605);
      match(NeoBasicParser::COMMA);
      setState(606);
      qualifiedIdentifier();
      setState(611);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeContext ------------------------------------------------------------------

NeoBasicParser::TypeContext::TypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NeoBasicParser::NativeTypeContext *> NeoBasicParser::TypeContext::nativeType() {
  return getRuleContexts<NeoBasicParser::NativeTypeContext>();
}

NeoBasicParser::NativeTypeContext* NeoBasicParser::TypeContext::nativeType(size_t i) {
  return getRuleContext<NeoBasicParser::NativeTypeContext>(i);
}

NeoBasicParser::PosfixTypeWrapperContext* NeoBasicParser::TypeContext::posfixTypeWrapper() {
  return getRuleContext<NeoBasicParser::PosfixTypeWrapperContext>(0);
}

tree::TerminalNode* NeoBasicParser::TypeContext::AMPERSAND() {
  return getToken(NeoBasicParser::AMPERSAND, 0);
}

tree::TerminalNode* NeoBasicParser::TypeContext::PIPE() {
  return getToken(NeoBasicParser::PIPE, 0);
}

NeoBasicParser::TypeContext* NeoBasicParser::TypeContext::type() {
  return getRuleContext<NeoBasicParser::TypeContext>(0);
}


size_t NeoBasicParser::TypeContext::getRuleIndex() const {
  return NeoBasicParser::RuleType;
}

void NeoBasicParser::TypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType(this);
}

void NeoBasicParser::TypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType(this);
}

NeoBasicParser::TypeContext* NeoBasicParser::type() {
  TypeContext *_localctx = _tracker.createInstance<TypeContext>(_ctx, getState());
  enterRule(_localctx, 156, NeoBasicParser::RuleType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(625);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(612);
      nativeType();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(613);
      nativeType();
      setState(614);
      posfixTypeWrapper();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(616);
      nativeType();
      setState(617);
      match(NeoBasicParser::AMPERSAND);
      setState(618);
      nativeType();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(620);
      nativeType();
      setState(621);
      match(NeoBasicParser::PIPE);
      setState(622);
      type();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(624);
      nativeType();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NativeTypeContext ------------------------------------------------------------------

NeoBasicParser::NativeTypeContext::NativeTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::EscalarTypeContext* NeoBasicParser::NativeTypeContext::escalarType() {
  return getRuleContext<NeoBasicParser::EscalarTypeContext>(0);
}

NeoBasicParser::CompositeTypeContext* NeoBasicParser::NativeTypeContext::compositeType() {
  return getRuleContext<NeoBasicParser::CompositeTypeContext>(0);
}

NeoBasicParser::MetaTypeContext* NeoBasicParser::NativeTypeContext::metaType() {
  return getRuleContext<NeoBasicParser::MetaTypeContext>(0);
}


size_t NeoBasicParser::NativeTypeContext::getRuleIndex() const {
  return NeoBasicParser::RuleNativeType;
}

void NeoBasicParser::NativeTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNativeType(this);
}

void NeoBasicParser::NativeTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNativeType(this);
}

NeoBasicParser::NativeTypeContext* NeoBasicParser::nativeType() {
  NativeTypeContext *_localctx = _tracker.createInstance<NativeTypeContext>(_ctx, getState());
  enterRule(_localctx, 158, NeoBasicParser::RuleNativeType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(630);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::BOOL8:
      case NeoBasicParser::BOOL16:
      case NeoBasicParser::BOOL32:
      case NeoBasicParser::BOOL64:
      case NeoBasicParser::BOOL128:
      case NeoBasicParser::BOOL:
      case NeoBasicParser::DIG:
      case NeoBasicParser::BIT:
      case NeoBasicParser::OCT:
      case NeoBasicParser::HEX:
      case NeoBasicParser::NIBBLE:
      case NeoBasicParser::BYTE:
      case NeoBasicParser::NUMBER:
      case NeoBasicParser::NAT8:
      case NeoBasicParser::NAT16:
      case NeoBasicParser::NAT32:
      case NeoBasicParser::NAT64:
      case NeoBasicParser::NAT128:
      case NeoBasicParser::NAT:
      case NeoBasicParser::BIGNAT:
      case NeoBasicParser::INT8:
      case NeoBasicParser::INT16:
      case NeoBasicParser::INT32:
      case NeoBasicParser::INT64:
      case NeoBasicParser::INT128:
      case NeoBasicParser::INT:
      case NeoBasicParser::BIGINT:
      case NeoBasicParser::REAL16:
      case NeoBasicParser::REAL32:
      case NeoBasicParser::REAL64:
      case NeoBasicParser::REAL128:
      case NeoBasicParser::REAL:
      case NeoBasicParser::BIGREAL:
      case NeoBasicParser::DEC1:
      case NeoBasicParser::DEC2:
      case NeoBasicParser::DEC3:
      case NeoBasicParser::DEC4:
      case NeoBasicParser::DEC5:
      case NeoBasicParser::DEC6:
      case NeoBasicParser::DEC7:
      case NeoBasicParser::DEC8:
      case NeoBasicParser::DECIMAL:
      case NeoBasicParser::MONEY:
      case NeoBasicParser::BIGDECIMAL:
      case NeoBasicParser::RATIO8:
      case NeoBasicParser::RATIO16:
      case NeoBasicParser::RATIO32:
      case NeoBasicParser::RATIO64:
      case NeoBasicParser::RATIO128:
      case NeoBasicParser::RATIO:
      case NeoBasicParser::COMPLEX16:
      case NeoBasicParser::COMPLEX32:
      case NeoBasicParser::COMPLEX64:
      case NeoBasicParser::COMPLEX128:
      case NeoBasicParser::COMPLEX:
      case NeoBasicParser::QUATERN16:
      case NeoBasicParser::QUATERN32:
      case NeoBasicParser::QUATERN64:
      case NeoBasicParser::QUATERN128:
      case NeoBasicParser::QUATERN:
      case NeoBasicParser::DATE:
      case NeoBasicParser::ELAPSE:
      case NeoBasicParser::ASCII:
      case NeoBasicParser::CHAR8:
      case NeoBasicParser::CHAR16:
      case NeoBasicParser::CHAR32:
      case NeoBasicParser::CHAR:
      case NeoBasicParser::WCHAR:
      case NeoBasicParser::ANSI:
      case NeoBasicParser::STR8:
      case NeoBasicParser::STR16:
      case NeoBasicParser::STR32:
      case NeoBasicParser::STR:
      case NeoBasicParser::CSTR:
      case NeoBasicParser::WSTR:
      case NeoBasicParser::REGEX:
      case NeoBasicParser::BINARY: {
        enterOuterAlt(_localctx, 1);
        setState(627);
        escalarType();
        break;
      }

      case NeoBasicParser::RANGE:
      case NeoBasicParser::PAIR: {
        enterOuterAlt(_localctx, 2);
        setState(628);
        compositeType();
        break;
      }

      case NeoBasicParser::ATOM:
      case NeoBasicParser::AUTO:
      case NeoBasicParser::VOID: {
        enterOuterAlt(_localctx, 3);
        setState(629);
        metaType();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PosfixTypeWrapperContext ------------------------------------------------------------------

NeoBasicParser::PosfixTypeWrapperContext::PosfixTypeWrapperContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::PosfixTypeWrapperContext::EXCLAMATION() {
  return getToken(NeoBasicParser::EXCLAMATION, 0);
}

std::vector<tree::TerminalNode *> NeoBasicParser::PosfixTypeWrapperContext::QUESTION() {
  return getTokens(NeoBasicParser::QUESTION);
}

tree::TerminalNode* NeoBasicParser::PosfixTypeWrapperContext::QUESTION(size_t i) {
  return getToken(NeoBasicParser::QUESTION, i);
}

tree::TerminalNode* NeoBasicParser::PosfixTypeWrapperContext::PIPE() {
  return getToken(NeoBasicParser::PIPE, 0);
}

tree::TerminalNode* NeoBasicParser::PosfixTypeWrapperContext::RIGHT_ANGLE() {
  return getToken(NeoBasicParser::RIGHT_ANGLE, 0);
}


size_t NeoBasicParser::PosfixTypeWrapperContext::getRuleIndex() const {
  return NeoBasicParser::RulePosfixTypeWrapper;
}

void NeoBasicParser::PosfixTypeWrapperContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPosfixTypeWrapper(this);
}

void NeoBasicParser::PosfixTypeWrapperContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPosfixTypeWrapper(this);
}

NeoBasicParser::PosfixTypeWrapperContext* NeoBasicParser::posfixTypeWrapper() {
  PosfixTypeWrapperContext *_localctx = _tracker.createInstance<PosfixTypeWrapperContext>(_ctx, getState());
  enterRule(_localctx, 160, NeoBasicParser::RulePosfixTypeWrapper);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(646);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(632);
      match(NeoBasicParser::EXCLAMATION);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(633);
      match(NeoBasicParser::QUESTION);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(634);
      match(NeoBasicParser::QUESTION);
      setState(635);
      match(NeoBasicParser::QUESTION);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(636);
      match(NeoBasicParser::PIPE);
      setState(637);
      match(NeoBasicParser::RIGHT_ANGLE);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(638);
      match(NeoBasicParser::EXCLAMATION);
      setState(639);
      match(NeoBasicParser::QUESTION);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(640);
      match(NeoBasicParser::EXCLAMATION);
      setState(641);
      match(NeoBasicParser::QUESTION);
      setState(642);
      match(NeoBasicParser::QUESTION);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(643);
      match(NeoBasicParser::EXCLAMATION);
      setState(644);
      match(NeoBasicParser::PIPE);
      setState(645);
      match(NeoBasicParser::RIGHT_ANGLE);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EscalarTypeContext ------------------------------------------------------------------

NeoBasicParser::EscalarTypeContext::EscalarTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::BooleanTypeContext* NeoBasicParser::EscalarTypeContext::booleanType() {
  return getRuleContext<NeoBasicParser::BooleanTypeContext>(0);
}

NeoBasicParser::NumericTypeContext* NeoBasicParser::EscalarTypeContext::numericType() {
  return getRuleContext<NeoBasicParser::NumericTypeContext>(0);
}

NeoBasicParser::TemporalTypeContext* NeoBasicParser::EscalarTypeContext::temporalType() {
  return getRuleContext<NeoBasicParser::TemporalTypeContext>(0);
}

NeoBasicParser::CharacterTypeContext* NeoBasicParser::EscalarTypeContext::characterType() {
  return getRuleContext<NeoBasicParser::CharacterTypeContext>(0);
}

NeoBasicParser::SequenceTypeContext* NeoBasicParser::EscalarTypeContext::sequenceType() {
  return getRuleContext<NeoBasicParser::SequenceTypeContext>(0);
}


size_t NeoBasicParser::EscalarTypeContext::getRuleIndex() const {
  return NeoBasicParser::RuleEscalarType;
}

void NeoBasicParser::EscalarTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEscalarType(this);
}

void NeoBasicParser::EscalarTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEscalarType(this);
}

NeoBasicParser::EscalarTypeContext* NeoBasicParser::escalarType() {
  EscalarTypeContext *_localctx = _tracker.createInstance<EscalarTypeContext>(_ctx, getState());
  enterRule(_localctx, 162, NeoBasicParser::RuleEscalarType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(653);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::BOOL8:
      case NeoBasicParser::BOOL16:
      case NeoBasicParser::BOOL32:
      case NeoBasicParser::BOOL64:
      case NeoBasicParser::BOOL128:
      case NeoBasicParser::BOOL: {
        enterOuterAlt(_localctx, 1);
        setState(648);
        booleanType();
        break;
      }

      case NeoBasicParser::DIG:
      case NeoBasicParser::BIT:
      case NeoBasicParser::OCT:
      case NeoBasicParser::HEX:
      case NeoBasicParser::NIBBLE:
      case NeoBasicParser::BYTE:
      case NeoBasicParser::NUMBER:
      case NeoBasicParser::NAT8:
      case NeoBasicParser::NAT16:
      case NeoBasicParser::NAT32:
      case NeoBasicParser::NAT64:
      case NeoBasicParser::NAT128:
      case NeoBasicParser::NAT:
      case NeoBasicParser::BIGNAT:
      case NeoBasicParser::INT8:
      case NeoBasicParser::INT16:
      case NeoBasicParser::INT32:
      case NeoBasicParser::INT64:
      case NeoBasicParser::INT128:
      case NeoBasicParser::INT:
      case NeoBasicParser::BIGINT:
      case NeoBasicParser::REAL16:
      case NeoBasicParser::REAL32:
      case NeoBasicParser::REAL64:
      case NeoBasicParser::REAL128:
      case NeoBasicParser::REAL:
      case NeoBasicParser::BIGREAL:
      case NeoBasicParser::DEC1:
      case NeoBasicParser::DEC2:
      case NeoBasicParser::DEC3:
      case NeoBasicParser::DEC4:
      case NeoBasicParser::DEC5:
      case NeoBasicParser::DEC6:
      case NeoBasicParser::DEC7:
      case NeoBasicParser::DEC8:
      case NeoBasicParser::DECIMAL:
      case NeoBasicParser::MONEY:
      case NeoBasicParser::BIGDECIMAL:
      case NeoBasicParser::RATIO8:
      case NeoBasicParser::RATIO16:
      case NeoBasicParser::RATIO32:
      case NeoBasicParser::RATIO64:
      case NeoBasicParser::RATIO128:
      case NeoBasicParser::RATIO:
      case NeoBasicParser::COMPLEX16:
      case NeoBasicParser::COMPLEX32:
      case NeoBasicParser::COMPLEX64:
      case NeoBasicParser::COMPLEX128:
      case NeoBasicParser::COMPLEX:
      case NeoBasicParser::QUATERN16:
      case NeoBasicParser::QUATERN32:
      case NeoBasicParser::QUATERN64:
      case NeoBasicParser::QUATERN128:
      case NeoBasicParser::QUATERN: {
        enterOuterAlt(_localctx, 2);
        setState(649);
        numericType();
        break;
      }

      case NeoBasicParser::DATE:
      case NeoBasicParser::ELAPSE: {
        enterOuterAlt(_localctx, 3);
        setState(650);
        temporalType();
        break;
      }

      case NeoBasicParser::ASCII:
      case NeoBasicParser::CHAR8:
      case NeoBasicParser::CHAR16:
      case NeoBasicParser::CHAR32:
      case NeoBasicParser::CHAR:
      case NeoBasicParser::WCHAR: {
        enterOuterAlt(_localctx, 4);
        setState(651);
        characterType();
        break;
      }

      case NeoBasicParser::ANSI:
      case NeoBasicParser::STR8:
      case NeoBasicParser::STR16:
      case NeoBasicParser::STR32:
      case NeoBasicParser::STR:
      case NeoBasicParser::CSTR:
      case NeoBasicParser::WSTR:
      case NeoBasicParser::REGEX:
      case NeoBasicParser::BINARY: {
        enterOuterAlt(_localctx, 5);
        setState(652);
        sequenceType();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BooleanTypeContext ------------------------------------------------------------------

NeoBasicParser::BooleanTypeContext::BooleanTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BooleanTypeContext::BOOL8() {
  return getToken(NeoBasicParser::BOOL8, 0);
}

tree::TerminalNode* NeoBasicParser::BooleanTypeContext::BOOL16() {
  return getToken(NeoBasicParser::BOOL16, 0);
}

tree::TerminalNode* NeoBasicParser::BooleanTypeContext::BOOL32() {
  return getToken(NeoBasicParser::BOOL32, 0);
}

tree::TerminalNode* NeoBasicParser::BooleanTypeContext::BOOL64() {
  return getToken(NeoBasicParser::BOOL64, 0);
}

tree::TerminalNode* NeoBasicParser::BooleanTypeContext::BOOL128() {
  return getToken(NeoBasicParser::BOOL128, 0);
}

tree::TerminalNode* NeoBasicParser::BooleanTypeContext::BOOL() {
  return getToken(NeoBasicParser::BOOL, 0);
}


size_t NeoBasicParser::BooleanTypeContext::getRuleIndex() const {
  return NeoBasicParser::RuleBooleanType;
}

void NeoBasicParser::BooleanTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBooleanType(this);
}

void NeoBasicParser::BooleanTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBooleanType(this);
}

NeoBasicParser::BooleanTypeContext* NeoBasicParser::booleanType() {
  BooleanTypeContext *_localctx = _tracker.createInstance<BooleanTypeContext>(_ctx, getState());
  enterRule(_localctx, 164, NeoBasicParser::RuleBooleanType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(655);
    _la = _input->LA(1);
    if (!(((((_la - 324) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 324)) & 63) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericTypeContext ------------------------------------------------------------------

NeoBasicParser::NumericTypeContext::NumericTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::NumericDigitContext* NeoBasicParser::NumericTypeContext::numericDigit() {
  return getRuleContext<NeoBasicParser::NumericDigitContext>(0);
}

NeoBasicParser::NumericNaturalContext* NeoBasicParser::NumericTypeContext::numericNatural() {
  return getRuleContext<NeoBasicParser::NumericNaturalContext>(0);
}

NeoBasicParser::NumericIntegerContext* NeoBasicParser::NumericTypeContext::numericInteger() {
  return getRuleContext<NeoBasicParser::NumericIntegerContext>(0);
}

NeoBasicParser::NumericRealContext* NeoBasicParser::NumericTypeContext::numericReal() {
  return getRuleContext<NeoBasicParser::NumericRealContext>(0);
}

NeoBasicParser::NumericDecimalContext* NeoBasicParser::NumericTypeContext::numericDecimal() {
  return getRuleContext<NeoBasicParser::NumericDecimalContext>(0);
}

NeoBasicParser::NumericRatioContext* NeoBasicParser::NumericTypeContext::numericRatio() {
  return getRuleContext<NeoBasicParser::NumericRatioContext>(0);
}

NeoBasicParser::NumericComplexContext* NeoBasicParser::NumericTypeContext::numericComplex() {
  return getRuleContext<NeoBasicParser::NumericComplexContext>(0);
}

NeoBasicParser::NumericQuaternionContext* NeoBasicParser::NumericTypeContext::numericQuaternion() {
  return getRuleContext<NeoBasicParser::NumericQuaternionContext>(0);
}

tree::TerminalNode* NeoBasicParser::NumericTypeContext::NUMBER() {
  return getToken(NeoBasicParser::NUMBER, 0);
}


size_t NeoBasicParser::NumericTypeContext::getRuleIndex() const {
  return NeoBasicParser::RuleNumericType;
}

void NeoBasicParser::NumericTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericType(this);
}

void NeoBasicParser::NumericTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericType(this);
}

NeoBasicParser::NumericTypeContext* NeoBasicParser::numericType() {
  NumericTypeContext *_localctx = _tracker.createInstance<NumericTypeContext>(_ctx, getState());
  enterRule(_localctx, 166, NeoBasicParser::RuleNumericType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(666);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::DIG:
      case NeoBasicParser::BIT:
      case NeoBasicParser::OCT:
      case NeoBasicParser::HEX:
      case NeoBasicParser::NIBBLE:
      case NeoBasicParser::BYTE: {
        enterOuterAlt(_localctx, 1);
        setState(657);
        numericDigit();
        break;
      }

      case NeoBasicParser::NAT8:
      case NeoBasicParser::NAT16:
      case NeoBasicParser::NAT32:
      case NeoBasicParser::NAT64:
      case NeoBasicParser::NAT128:
      case NeoBasicParser::NAT:
      case NeoBasicParser::BIGNAT: {
        enterOuterAlt(_localctx, 2);
        setState(658);
        numericNatural();
        break;
      }

      case NeoBasicParser::INT8:
      case NeoBasicParser::INT16:
      case NeoBasicParser::INT32:
      case NeoBasicParser::INT64:
      case NeoBasicParser::INT128:
      case NeoBasicParser::INT:
      case NeoBasicParser::BIGINT: {
        enterOuterAlt(_localctx, 3);
        setState(659);
        numericInteger();
        break;
      }

      case NeoBasicParser::REAL16:
      case NeoBasicParser::REAL32:
      case NeoBasicParser::REAL64:
      case NeoBasicParser::REAL128:
      case NeoBasicParser::REAL:
      case NeoBasicParser::BIGREAL: {
        enterOuterAlt(_localctx, 4);
        setState(660);
        numericReal();
        break;
      }

      case NeoBasicParser::DEC1:
      case NeoBasicParser::DEC2:
      case NeoBasicParser::DEC3:
      case NeoBasicParser::DEC4:
      case NeoBasicParser::DEC5:
      case NeoBasicParser::DEC6:
      case NeoBasicParser::DEC7:
      case NeoBasicParser::DEC8:
      case NeoBasicParser::DECIMAL:
      case NeoBasicParser::MONEY:
      case NeoBasicParser::BIGDECIMAL: {
        enterOuterAlt(_localctx, 5);
        setState(661);
        numericDecimal();
        break;
      }

      case NeoBasicParser::RATIO8:
      case NeoBasicParser::RATIO16:
      case NeoBasicParser::RATIO32:
      case NeoBasicParser::RATIO64:
      case NeoBasicParser::RATIO128:
      case NeoBasicParser::RATIO: {
        enterOuterAlt(_localctx, 6);
        setState(662);
        numericRatio();
        break;
      }

      case NeoBasicParser::COMPLEX16:
      case NeoBasicParser::COMPLEX32:
      case NeoBasicParser::COMPLEX64:
      case NeoBasicParser::COMPLEX128:
      case NeoBasicParser::COMPLEX: {
        enterOuterAlt(_localctx, 7);
        setState(663);
        numericComplex();
        break;
      }

      case NeoBasicParser::QUATERN16:
      case NeoBasicParser::QUATERN32:
      case NeoBasicParser::QUATERN64:
      case NeoBasicParser::QUATERN128:
      case NeoBasicParser::QUATERN: {
        enterOuterAlt(_localctx, 8);
        setState(664);
        numericQuaternion();
        break;
      }

      case NeoBasicParser::NUMBER: {
        enterOuterAlt(_localctx, 9);
        setState(665);
        match(NeoBasicParser::NUMBER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericDigitContext ------------------------------------------------------------------

NeoBasicParser::NumericDigitContext::NumericDigitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::NumericDigitContext::DIG() {
  return getToken(NeoBasicParser::DIG, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDigitContext::BIT() {
  return getToken(NeoBasicParser::BIT, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDigitContext::OCT() {
  return getToken(NeoBasicParser::OCT, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDigitContext::HEX() {
  return getToken(NeoBasicParser::HEX, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDigitContext::NIBBLE() {
  return getToken(NeoBasicParser::NIBBLE, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDigitContext::BYTE() {
  return getToken(NeoBasicParser::BYTE, 0);
}


size_t NeoBasicParser::NumericDigitContext::getRuleIndex() const {
  return NeoBasicParser::RuleNumericDigit;
}

void NeoBasicParser::NumericDigitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericDigit(this);
}

void NeoBasicParser::NumericDigitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericDigit(this);
}

NeoBasicParser::NumericDigitContext* NeoBasicParser::numericDigit() {
  NumericDigitContext *_localctx = _tracker.createInstance<NumericDigitContext>(_ctx, getState());
  enterRule(_localctx, 168, NeoBasicParser::RuleNumericDigit);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(668);
    _la = _input->LA(1);
    if (!(((((_la - 330) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 330)) & 111) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericNaturalContext ------------------------------------------------------------------

NeoBasicParser::NumericNaturalContext::NumericNaturalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::NumericNaturalContext::NAT8() {
  return getToken(NeoBasicParser::NAT8, 0);
}

tree::TerminalNode* NeoBasicParser::NumericNaturalContext::NAT16() {
  return getToken(NeoBasicParser::NAT16, 0);
}

tree::TerminalNode* NeoBasicParser::NumericNaturalContext::NAT32() {
  return getToken(NeoBasicParser::NAT32, 0);
}

tree::TerminalNode* NeoBasicParser::NumericNaturalContext::NAT64() {
  return getToken(NeoBasicParser::NAT64, 0);
}

tree::TerminalNode* NeoBasicParser::NumericNaturalContext::NAT128() {
  return getToken(NeoBasicParser::NAT128, 0);
}

tree::TerminalNode* NeoBasicParser::NumericNaturalContext::NAT() {
  return getToken(NeoBasicParser::NAT, 0);
}

tree::TerminalNode* NeoBasicParser::NumericNaturalContext::BIGNAT() {
  return getToken(NeoBasicParser::BIGNAT, 0);
}


size_t NeoBasicParser::NumericNaturalContext::getRuleIndex() const {
  return NeoBasicParser::RuleNumericNatural;
}

void NeoBasicParser::NumericNaturalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericNatural(this);
}

void NeoBasicParser::NumericNaturalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericNatural(this);
}

NeoBasicParser::NumericNaturalContext* NeoBasicParser::numericNatural() {
  NumericNaturalContext *_localctx = _tracker.createInstance<NumericNaturalContext>(_ctx, getState());
  enterRule(_localctx, 170, NeoBasicParser::RuleNumericNatural);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(670);
    _la = _input->LA(1);
    if (!(((((_la - 338) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 338)) & 127) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericIntegerContext ------------------------------------------------------------------

NeoBasicParser::NumericIntegerContext::NumericIntegerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::NumericIntegerContext::INT8() {
  return getToken(NeoBasicParser::INT8, 0);
}

tree::TerminalNode* NeoBasicParser::NumericIntegerContext::INT16() {
  return getToken(NeoBasicParser::INT16, 0);
}

tree::TerminalNode* NeoBasicParser::NumericIntegerContext::INT32() {
  return getToken(NeoBasicParser::INT32, 0);
}

tree::TerminalNode* NeoBasicParser::NumericIntegerContext::INT64() {
  return getToken(NeoBasicParser::INT64, 0);
}

tree::TerminalNode* NeoBasicParser::NumericIntegerContext::INT128() {
  return getToken(NeoBasicParser::INT128, 0);
}

tree::TerminalNode* NeoBasicParser::NumericIntegerContext::INT() {
  return getToken(NeoBasicParser::INT, 0);
}

tree::TerminalNode* NeoBasicParser::NumericIntegerContext::BIGINT() {
  return getToken(NeoBasicParser::BIGINT, 0);
}


size_t NeoBasicParser::NumericIntegerContext::getRuleIndex() const {
  return NeoBasicParser::RuleNumericInteger;
}

void NeoBasicParser::NumericIntegerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericInteger(this);
}

void NeoBasicParser::NumericIntegerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericInteger(this);
}

NeoBasicParser::NumericIntegerContext* NeoBasicParser::numericInteger() {
  NumericIntegerContext *_localctx = _tracker.createInstance<NumericIntegerContext>(_ctx, getState());
  enterRule(_localctx, 172, NeoBasicParser::RuleNumericInteger);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(672);
    _la = _input->LA(1);
    if (!(((((_la - 345) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 345)) & 127) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericRealContext ------------------------------------------------------------------

NeoBasicParser::NumericRealContext::NumericRealContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::NumericRealContext::REAL16() {
  return getToken(NeoBasicParser::REAL16, 0);
}

tree::TerminalNode* NeoBasicParser::NumericRealContext::REAL32() {
  return getToken(NeoBasicParser::REAL32, 0);
}

tree::TerminalNode* NeoBasicParser::NumericRealContext::REAL64() {
  return getToken(NeoBasicParser::REAL64, 0);
}

tree::TerminalNode* NeoBasicParser::NumericRealContext::REAL128() {
  return getToken(NeoBasicParser::REAL128, 0);
}

tree::TerminalNode* NeoBasicParser::NumericRealContext::REAL() {
  return getToken(NeoBasicParser::REAL, 0);
}

tree::TerminalNode* NeoBasicParser::NumericRealContext::BIGREAL() {
  return getToken(NeoBasicParser::BIGREAL, 0);
}


size_t NeoBasicParser::NumericRealContext::getRuleIndex() const {
  return NeoBasicParser::RuleNumericReal;
}

void NeoBasicParser::NumericRealContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericReal(this);
}

void NeoBasicParser::NumericRealContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericReal(this);
}

NeoBasicParser::NumericRealContext* NeoBasicParser::numericReal() {
  NumericRealContext *_localctx = _tracker.createInstance<NumericRealContext>(_ctx, getState());
  enterRule(_localctx, 174, NeoBasicParser::RuleNumericReal);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(674);
    _la = _input->LA(1);
    if (!(((((_la - 352) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 352)) & 63) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericDecimalContext ------------------------------------------------------------------

NeoBasicParser::NumericDecimalContext::NumericDecimalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::NumericDecimalContext::DEC1() {
  return getToken(NeoBasicParser::DEC1, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDecimalContext::DEC2() {
  return getToken(NeoBasicParser::DEC2, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDecimalContext::DEC3() {
  return getToken(NeoBasicParser::DEC3, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDecimalContext::DEC4() {
  return getToken(NeoBasicParser::DEC4, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDecimalContext::DEC5() {
  return getToken(NeoBasicParser::DEC5, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDecimalContext::DEC6() {
  return getToken(NeoBasicParser::DEC6, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDecimalContext::DEC7() {
  return getToken(NeoBasicParser::DEC7, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDecimalContext::DEC8() {
  return getToken(NeoBasicParser::DEC8, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDecimalContext::DECIMAL() {
  return getToken(NeoBasicParser::DECIMAL, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDecimalContext::MONEY() {
  return getToken(NeoBasicParser::MONEY, 0);
}

tree::TerminalNode* NeoBasicParser::NumericDecimalContext::BIGDECIMAL() {
  return getToken(NeoBasicParser::BIGDECIMAL, 0);
}


size_t NeoBasicParser::NumericDecimalContext::getRuleIndex() const {
  return NeoBasicParser::RuleNumericDecimal;
}

void NeoBasicParser::NumericDecimalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericDecimal(this);
}

void NeoBasicParser::NumericDecimalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericDecimal(this);
}

NeoBasicParser::NumericDecimalContext* NeoBasicParser::numericDecimal() {
  NumericDecimalContext *_localctx = _tracker.createInstance<NumericDecimalContext>(_ctx, getState());
  enterRule(_localctx, 176, NeoBasicParser::RuleNumericDecimal);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(676);
    _la = _input->LA(1);
    if (!(((((_la - 358) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 358)) & 2047) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericRatioContext ------------------------------------------------------------------

NeoBasicParser::NumericRatioContext::NumericRatioContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::NumericRatioContext::RATIO8() {
  return getToken(NeoBasicParser::RATIO8, 0);
}

tree::TerminalNode* NeoBasicParser::NumericRatioContext::RATIO16() {
  return getToken(NeoBasicParser::RATIO16, 0);
}

tree::TerminalNode* NeoBasicParser::NumericRatioContext::RATIO32() {
  return getToken(NeoBasicParser::RATIO32, 0);
}

tree::TerminalNode* NeoBasicParser::NumericRatioContext::RATIO64() {
  return getToken(NeoBasicParser::RATIO64, 0);
}

tree::TerminalNode* NeoBasicParser::NumericRatioContext::RATIO128() {
  return getToken(NeoBasicParser::RATIO128, 0);
}

tree::TerminalNode* NeoBasicParser::NumericRatioContext::RATIO() {
  return getToken(NeoBasicParser::RATIO, 0);
}


size_t NeoBasicParser::NumericRatioContext::getRuleIndex() const {
  return NeoBasicParser::RuleNumericRatio;
}

void NeoBasicParser::NumericRatioContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericRatio(this);
}

void NeoBasicParser::NumericRatioContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericRatio(this);
}

NeoBasicParser::NumericRatioContext* NeoBasicParser::numericRatio() {
  NumericRatioContext *_localctx = _tracker.createInstance<NumericRatioContext>(_ctx, getState());
  enterRule(_localctx, 178, NeoBasicParser::RuleNumericRatio);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(678);
    _la = _input->LA(1);
    if (!(((((_la - 369) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 369)) & 63) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericComplexContext ------------------------------------------------------------------

NeoBasicParser::NumericComplexContext::NumericComplexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::NumericComplexContext::COMPLEX16() {
  return getToken(NeoBasicParser::COMPLEX16, 0);
}

tree::TerminalNode* NeoBasicParser::NumericComplexContext::COMPLEX32() {
  return getToken(NeoBasicParser::COMPLEX32, 0);
}

tree::TerminalNode* NeoBasicParser::NumericComplexContext::COMPLEX64() {
  return getToken(NeoBasicParser::COMPLEX64, 0);
}

tree::TerminalNode* NeoBasicParser::NumericComplexContext::COMPLEX128() {
  return getToken(NeoBasicParser::COMPLEX128, 0);
}

tree::TerminalNode* NeoBasicParser::NumericComplexContext::COMPLEX() {
  return getToken(NeoBasicParser::COMPLEX, 0);
}


size_t NeoBasicParser::NumericComplexContext::getRuleIndex() const {
  return NeoBasicParser::RuleNumericComplex;
}

void NeoBasicParser::NumericComplexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericComplex(this);
}

void NeoBasicParser::NumericComplexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericComplex(this);
}

NeoBasicParser::NumericComplexContext* NeoBasicParser::numericComplex() {
  NumericComplexContext *_localctx = _tracker.createInstance<NumericComplexContext>(_ctx, getState());
  enterRule(_localctx, 180, NeoBasicParser::RuleNumericComplex);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(680);
    _la = _input->LA(1);
    if (!(((((_la - 375) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 375)) & 31) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericQuaternionContext ------------------------------------------------------------------

NeoBasicParser::NumericQuaternionContext::NumericQuaternionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::NumericQuaternionContext::QUATERN16() {
  return getToken(NeoBasicParser::QUATERN16, 0);
}

tree::TerminalNode* NeoBasicParser::NumericQuaternionContext::QUATERN32() {
  return getToken(NeoBasicParser::QUATERN32, 0);
}

tree::TerminalNode* NeoBasicParser::NumericQuaternionContext::QUATERN64() {
  return getToken(NeoBasicParser::QUATERN64, 0);
}

tree::TerminalNode* NeoBasicParser::NumericQuaternionContext::QUATERN128() {
  return getToken(NeoBasicParser::QUATERN128, 0);
}

tree::TerminalNode* NeoBasicParser::NumericQuaternionContext::QUATERN() {
  return getToken(NeoBasicParser::QUATERN, 0);
}


size_t NeoBasicParser::NumericQuaternionContext::getRuleIndex() const {
  return NeoBasicParser::RuleNumericQuaternion;
}

void NeoBasicParser::NumericQuaternionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericQuaternion(this);
}

void NeoBasicParser::NumericQuaternionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericQuaternion(this);
}

NeoBasicParser::NumericQuaternionContext* NeoBasicParser::numericQuaternion() {
  NumericQuaternionContext *_localctx = _tracker.createInstance<NumericQuaternionContext>(_ctx, getState());
  enterRule(_localctx, 182, NeoBasicParser::RuleNumericQuaternion);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(682);
    _la = _input->LA(1);
    if (!(((((_la - 380) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 380)) & 31) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TemporalTypeContext ------------------------------------------------------------------

NeoBasicParser::TemporalTypeContext::TemporalTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::TemporalTypeContext::DATE() {
  return getToken(NeoBasicParser::DATE, 0);
}

tree::TerminalNode* NeoBasicParser::TemporalTypeContext::ELAPSE() {
  return getToken(NeoBasicParser::ELAPSE, 0);
}


size_t NeoBasicParser::TemporalTypeContext::getRuleIndex() const {
  return NeoBasicParser::RuleTemporalType;
}

void NeoBasicParser::TemporalTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemporalType(this);
}

void NeoBasicParser::TemporalTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemporalType(this);
}

NeoBasicParser::TemporalTypeContext* NeoBasicParser::temporalType() {
  TemporalTypeContext *_localctx = _tracker.createInstance<TemporalTypeContext>(_ctx, getState());
  enterRule(_localctx, 184, NeoBasicParser::RuleTemporalType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(684);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::DATE

    || _la == NeoBasicParser::ELAPSE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharacterTypeContext ------------------------------------------------------------------

NeoBasicParser::CharacterTypeContext::CharacterTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::CharacterTypeContext::ASCII() {
  return getToken(NeoBasicParser::ASCII, 0);
}

tree::TerminalNode* NeoBasicParser::CharacterTypeContext::CHAR8() {
  return getToken(NeoBasicParser::CHAR8, 0);
}

tree::TerminalNode* NeoBasicParser::CharacterTypeContext::CHAR16() {
  return getToken(NeoBasicParser::CHAR16, 0);
}

tree::TerminalNode* NeoBasicParser::CharacterTypeContext::CHAR32() {
  return getToken(NeoBasicParser::CHAR32, 0);
}

tree::TerminalNode* NeoBasicParser::CharacterTypeContext::CHAR() {
  return getToken(NeoBasicParser::CHAR, 0);
}

tree::TerminalNode* NeoBasicParser::CharacterTypeContext::WCHAR() {
  return getToken(NeoBasicParser::WCHAR, 0);
}


size_t NeoBasicParser::CharacterTypeContext::getRuleIndex() const {
  return NeoBasicParser::RuleCharacterType;
}

void NeoBasicParser::CharacterTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharacterType(this);
}

void NeoBasicParser::CharacterTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharacterType(this);
}

NeoBasicParser::CharacterTypeContext* NeoBasicParser::characterType() {
  CharacterTypeContext *_localctx = _tracker.createInstance<CharacterTypeContext>(_ctx, getState());
  enterRule(_localctx, 186, NeoBasicParser::RuleCharacterType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(686);
    _la = _input->LA(1);
    if (!(((((_la - 387) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 387)) & 63) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SequenceTypeContext ------------------------------------------------------------------

NeoBasicParser::SequenceTypeContext::SequenceTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::SequenceTypeContext::ANSI() {
  return getToken(NeoBasicParser::ANSI, 0);
}

tree::TerminalNode* NeoBasicParser::SequenceTypeContext::STR8() {
  return getToken(NeoBasicParser::STR8, 0);
}

tree::TerminalNode* NeoBasicParser::SequenceTypeContext::STR16() {
  return getToken(NeoBasicParser::STR16, 0);
}

tree::TerminalNode* NeoBasicParser::SequenceTypeContext::STR32() {
  return getToken(NeoBasicParser::STR32, 0);
}

tree::TerminalNode* NeoBasicParser::SequenceTypeContext::STR() {
  return getToken(NeoBasicParser::STR, 0);
}

tree::TerminalNode* NeoBasicParser::SequenceTypeContext::CSTR() {
  return getToken(NeoBasicParser::CSTR, 0);
}

tree::TerminalNode* NeoBasicParser::SequenceTypeContext::WSTR() {
  return getToken(NeoBasicParser::WSTR, 0);
}

tree::TerminalNode* NeoBasicParser::SequenceTypeContext::REGEX() {
  return getToken(NeoBasicParser::REGEX, 0);
}

tree::TerminalNode* NeoBasicParser::SequenceTypeContext::BINARY() {
  return getToken(NeoBasicParser::BINARY, 0);
}


size_t NeoBasicParser::SequenceTypeContext::getRuleIndex() const {
  return NeoBasicParser::RuleSequenceType;
}

void NeoBasicParser::SequenceTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSequenceType(this);
}

void NeoBasicParser::SequenceTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSequenceType(this);
}

NeoBasicParser::SequenceTypeContext* NeoBasicParser::sequenceType() {
  SequenceTypeContext *_localctx = _tracker.createInstance<SequenceTypeContext>(_ctx, getState());
  enterRule(_localctx, 188, NeoBasicParser::RuleSequenceType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(688);
    _la = _input->LA(1);
    if (!(((((_la - 393) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 393)) & 511) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompositeTypeContext ------------------------------------------------------------------

NeoBasicParser::CompositeTypeContext::CompositeTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::CompositeTypeContext::RANGE() {
  return getToken(NeoBasicParser::RANGE, 0);
}

tree::TerminalNode* NeoBasicParser::CompositeTypeContext::PAIR() {
  return getToken(NeoBasicParser::PAIR, 0);
}


size_t NeoBasicParser::CompositeTypeContext::getRuleIndex() const {
  return NeoBasicParser::RuleCompositeType;
}

void NeoBasicParser::CompositeTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompositeType(this);
}

void NeoBasicParser::CompositeTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompositeType(this);
}

NeoBasicParser::CompositeTypeContext* NeoBasicParser::compositeType() {
  CompositeTypeContext *_localctx = _tracker.createInstance<CompositeTypeContext>(_ctx, getState());
  enterRule(_localctx, 190, NeoBasicParser::RuleCompositeType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(690);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::RANGE

    || _la == NeoBasicParser::PAIR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MetaTypeContext ------------------------------------------------------------------

NeoBasicParser::MetaTypeContext::MetaTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::MetaTypeContext::ATOM() {
  return getToken(NeoBasicParser::ATOM, 0);
}

tree::TerminalNode* NeoBasicParser::MetaTypeContext::AUTO() {
  return getToken(NeoBasicParser::AUTO, 0);
}

tree::TerminalNode* NeoBasicParser::MetaTypeContext::VOID() {
  return getToken(NeoBasicParser::VOID, 0);
}


size_t NeoBasicParser::MetaTypeContext::getRuleIndex() const {
  return NeoBasicParser::RuleMetaType;
}

void NeoBasicParser::MetaTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMetaType(this);
}

void NeoBasicParser::MetaTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMetaType(this);
}

NeoBasicParser::MetaTypeContext* NeoBasicParser::metaType() {
  MetaTypeContext *_localctx = _tracker.createInstance<MetaTypeContext>(_ctx, getState());
  enterRule(_localctx, 192, NeoBasicParser::RuleMetaType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(692);
    _la = _input->LA(1);
    if (!(((((_la - 321) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 321)) & 7) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionsContext ------------------------------------------------------------------

NeoBasicParser::ExpressionsContext::ExpressionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NeoBasicParser::ExpressionContext *> NeoBasicParser::ExpressionsContext::expression() {
  return getRuleContexts<NeoBasicParser::ExpressionContext>();
}

NeoBasicParser::ExpressionContext* NeoBasicParser::ExpressionsContext::expression(size_t i) {
  return getRuleContext<NeoBasicParser::ExpressionContext>(i);
}

std::vector<tree::TerminalNode *> NeoBasicParser::ExpressionsContext::COMMA() {
  return getTokens(NeoBasicParser::COMMA);
}

tree::TerminalNode* NeoBasicParser::ExpressionsContext::COMMA(size_t i) {
  return getToken(NeoBasicParser::COMMA, i);
}


size_t NeoBasicParser::ExpressionsContext::getRuleIndex() const {
  return NeoBasicParser::RuleExpressions;
}

void NeoBasicParser::ExpressionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpressions(this);
}

void NeoBasicParser::ExpressionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpressions(this);
}

NeoBasicParser::ExpressionsContext* NeoBasicParser::expressions() {
  ExpressionsContext *_localctx = _tracker.createInstance<ExpressionsContext>(_ctx, getState());
  enterRule(_localctx, 194, NeoBasicParser::RuleExpressions);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(694);
    expression(0);
    setState(699);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(695);
        match(NeoBasicParser::COMMA);
        setState(696);
        expression(0); 
      }
      setState(701);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JuxtapositionExpressionsContext ------------------------------------------------------------------

NeoBasicParser::JuxtapositionExpressionsContext::JuxtapositionExpressionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NeoBasicParser::ExpressionContext *> NeoBasicParser::JuxtapositionExpressionsContext::expression() {
  return getRuleContexts<NeoBasicParser::ExpressionContext>();
}

NeoBasicParser::ExpressionContext* NeoBasicParser::JuxtapositionExpressionsContext::expression(size_t i) {
  return getRuleContext<NeoBasicParser::ExpressionContext>(i);
}


size_t NeoBasicParser::JuxtapositionExpressionsContext::getRuleIndex() const {
  return NeoBasicParser::RuleJuxtapositionExpressions;
}

void NeoBasicParser::JuxtapositionExpressionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJuxtapositionExpressions(this);
}

void NeoBasicParser::JuxtapositionExpressionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJuxtapositionExpressions(this);
}

NeoBasicParser::JuxtapositionExpressionsContext* NeoBasicParser::juxtapositionExpressions() {
  JuxtapositionExpressionsContext *_localctx = _tracker.createInstance<JuxtapositionExpressionsContext>(_ctx, getState());
  enterRule(_localctx, 196, NeoBasicParser::RuleJuxtapositionExpressions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(702);
    expression(0);
    setState(706);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 26880891280162818) != 0) || ((((_la - 123) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 123)) & 4399279987541) != 0) || ((((_la - 288) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 288)) & 17448451) != 0) || ((((_la - 420) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 420)) & 2243005863952383) != 0)) {
      setState(703);
      expression(0);
      setState(708);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrimaryExpressionsContext ------------------------------------------------------------------

NeoBasicParser::PrimaryExpressionsContext::PrimaryExpressionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NeoBasicParser::PrimaryExpressionContext *> NeoBasicParser::PrimaryExpressionsContext::primaryExpression() {
  return getRuleContexts<NeoBasicParser::PrimaryExpressionContext>();
}

NeoBasicParser::PrimaryExpressionContext* NeoBasicParser::PrimaryExpressionsContext::primaryExpression(size_t i) {
  return getRuleContext<NeoBasicParser::PrimaryExpressionContext>(i);
}

std::vector<tree::TerminalNode *> NeoBasicParser::PrimaryExpressionsContext::COMMA() {
  return getTokens(NeoBasicParser::COMMA);
}

tree::TerminalNode* NeoBasicParser::PrimaryExpressionsContext::COMMA(size_t i) {
  return getToken(NeoBasicParser::COMMA, i);
}


size_t NeoBasicParser::PrimaryExpressionsContext::getRuleIndex() const {
  return NeoBasicParser::RulePrimaryExpressions;
}

void NeoBasicParser::PrimaryExpressionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryExpressions(this);
}

void NeoBasicParser::PrimaryExpressionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryExpressions(this);
}

NeoBasicParser::PrimaryExpressionsContext* NeoBasicParser::primaryExpressions() {
  PrimaryExpressionsContext *_localctx = _tracker.createInstance<PrimaryExpressionsContext>(_ctx, getState());
  enterRule(_localctx, 198, NeoBasicParser::RulePrimaryExpressions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(709);
    primaryExpression(0);
    setState(714);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == NeoBasicParser::COMMA) {
      setState(710);
      match(NeoBasicParser::COMMA);
      setState(711);
      primaryExpression(0);
      setState(716);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExpressionContext ------------------------------------------------------------------

NeoBasicParser::ExpressionContext::ExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::PrimaryExpressionContext* NeoBasicParser::ExpressionContext::primaryExpression() {
  return getRuleContext<NeoBasicParser::PrimaryExpressionContext>(0);
}

NeoBasicParser::PrefixUnaryOperatorContext* NeoBasicParser::ExpressionContext::prefixUnaryOperator() {
  return getRuleContext<NeoBasicParser::PrefixUnaryOperatorContext>(0);
}

std::vector<NeoBasicParser::ExpressionContext *> NeoBasicParser::ExpressionContext::expression() {
  return getRuleContexts<NeoBasicParser::ExpressionContext>();
}

NeoBasicParser::ExpressionContext* NeoBasicParser::ExpressionContext::expression(size_t i) {
  return getRuleContext<NeoBasicParser::ExpressionContext>(i);
}

NeoBasicParser::AssignmentExpressionContext* NeoBasicParser::ExpressionContext::assignmentExpression() {
  return getRuleContext<NeoBasicParser::AssignmentExpressionContext>(0);
}

NeoBasicParser::CondicionalExpressionContext* NeoBasicParser::ExpressionContext::condicionalExpression() {
  return getRuleContext<NeoBasicParser::CondicionalExpressionContext>(0);
}

NeoBasicParser::MacroExpressionContext* NeoBasicParser::ExpressionContext::macroExpression() {
  return getRuleContext<NeoBasicParser::MacroExpressionContext>(0);
}

NeoBasicParser::BinaryExponentialOperatorContext* NeoBasicParser::ExpressionContext::binaryExponentialOperator() {
  return getRuleContext<NeoBasicParser::BinaryExponentialOperatorContext>(0);
}

NeoBasicParser::BinaryMultiplicativeOperatorContext* NeoBasicParser::ExpressionContext::binaryMultiplicativeOperator() {
  return getRuleContext<NeoBasicParser::BinaryMultiplicativeOperatorContext>(0);
}

NeoBasicParser::BinaryAdditiveOperatorContext* NeoBasicParser::ExpressionContext::binaryAdditiveOperator() {
  return getRuleContext<NeoBasicParser::BinaryAdditiveOperatorContext>(0);
}

NeoBasicParser::BitShiftOperatorContext* NeoBasicParser::ExpressionContext::bitShiftOperator() {
  return getRuleContext<NeoBasicParser::BitShiftOperatorContext>(0);
}

NeoBasicParser::BitConjunctionOperatorContext* NeoBasicParser::ExpressionContext::bitConjunctionOperator() {
  return getRuleContext<NeoBasicParser::BitConjunctionOperatorContext>(0);
}

NeoBasicParser::BitExclusiveDisjunctionOperatorContext* NeoBasicParser::ExpressionContext::bitExclusiveDisjunctionOperator() {
  return getRuleContext<NeoBasicParser::BitExclusiveDisjunctionOperatorContext>(0);
}

NeoBasicParser::BitDisjunctionOperatorContext* NeoBasicParser::ExpressionContext::bitDisjunctionOperator() {
  return getRuleContext<NeoBasicParser::BitDisjunctionOperatorContext>(0);
}

NeoBasicParser::BinaryComparisonOperatorContext* NeoBasicParser::ExpressionContext::binaryComparisonOperator() {
  return getRuleContext<NeoBasicParser::BinaryComparisonOperatorContext>(0);
}

NeoBasicParser::BinaryRelationalOperatorContext* NeoBasicParser::ExpressionContext::binaryRelationalOperator() {
  return getRuleContext<NeoBasicParser::BinaryRelationalOperatorContext>(0);
}

NeoBasicParser::BinaryConditionalOperatorContext* NeoBasicParser::ExpressionContext::binaryConditionalOperator() {
  return getRuleContext<NeoBasicParser::BinaryConditionalOperatorContext>(0);
}

NeoBasicParser::BinaryConjunctionOperatorContext* NeoBasicParser::ExpressionContext::binaryConjunctionOperator() {
  return getRuleContext<NeoBasicParser::BinaryConjunctionOperatorContext>(0);
}

NeoBasicParser::BinaryExclusiveDisjunctionOperatorContext* NeoBasicParser::ExpressionContext::binaryExclusiveDisjunctionOperator() {
  return getRuleContext<NeoBasicParser::BinaryExclusiveDisjunctionOperatorContext>(0);
}

NeoBasicParser::BinaryDisjunctionOperatorContext* NeoBasicParser::ExpressionContext::binaryDisjunctionOperator() {
  return getRuleContext<NeoBasicParser::BinaryDisjunctionOperatorContext>(0);
}

NeoBasicParser::PosfixUnaryOperatorContext* NeoBasicParser::ExpressionContext::posfixUnaryOperator() {
  return getRuleContext<NeoBasicParser::PosfixUnaryOperatorContext>(0);
}

NeoBasicParser::BinaryCoalescingOperatorContext* NeoBasicParser::ExpressionContext::binaryCoalescingOperator() {
  return getRuleContext<NeoBasicParser::BinaryCoalescingOperatorContext>(0);
}


size_t NeoBasicParser::ExpressionContext::getRuleIndex() const {
  return NeoBasicParser::RuleExpression;
}

void NeoBasicParser::ExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpression(this);
}

void NeoBasicParser::ExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpression(this);
}


NeoBasicParser::ExpressionContext* NeoBasicParser::expression() {
   return expression(0);
}

NeoBasicParser::ExpressionContext* NeoBasicParser::expression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  NeoBasicParser::ExpressionContext *_localctx = _tracker.createInstance<ExpressionContext>(_ctx, parentState);
  NeoBasicParser::ExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 200;
  enterRecursionRule(_localctx, 200, NeoBasicParser::RuleExpression, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(725);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
    case 1: {
      setState(718);
      primaryExpression(0);
      break;
    }

    case 2: {
      setState(719);
      prefixUnaryOperator();
      setState(720);
      expression(19);
      break;
    }

    case 3: {
      setState(722);
      assignmentExpression();
      break;
    }

    case 4: {
      setState(723);
      condicionalExpression();
      break;
    }

    case 5: {
      setState(724);
      macroExpression();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(788);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(786);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(727);

          if (!(precpred(_ctx, 17))) throw FailedPredicateException(this, "precpred(_ctx, 17)");
          setState(728);
          binaryExponentialOperator();
          setState(729);
          expression(18);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(731);

          if (!(precpred(_ctx, 16))) throw FailedPredicateException(this, "precpred(_ctx, 16)");
          setState(732);
          binaryMultiplicativeOperator();
          setState(733);
          expression(17);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(735);

          if (!(precpred(_ctx, 15))) throw FailedPredicateException(this, "precpred(_ctx, 15)");
          setState(736);
          binaryAdditiveOperator();
          setState(737);
          expression(16);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(739);

          if (!(precpred(_ctx, 14))) throw FailedPredicateException(this, "precpred(_ctx, 14)");
          setState(740);
          bitShiftOperator();
          setState(741);
          expression(15);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(743);

          if (!(precpred(_ctx, 13))) throw FailedPredicateException(this, "precpred(_ctx, 13)");
          setState(744);
          bitConjunctionOperator();
          setState(745);
          expression(14);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(747);

          if (!(precpred(_ctx, 12))) throw FailedPredicateException(this, "precpred(_ctx, 12)");
          setState(748);
          bitExclusiveDisjunctionOperator();
          setState(749);
          expression(13);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(751);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(752);
          bitDisjunctionOperator();
          setState(753);
          expression(12);
          break;
        }

        case 8: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(755);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(756);
          binaryComparisonOperator();
          setState(757);
          expression(11);
          break;
        }

        case 9: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(759);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(760);
          binaryRelationalOperator();
          setState(761);
          expression(10);
          break;
        }

        case 10: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(763);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(764);
          binaryConditionalOperator();
          setState(765);
          expression(9);
          break;
        }

        case 11: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(767);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(768);
          binaryConjunctionOperator();
          setState(769);
          expression(8);
          break;
        }

        case 12: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(771);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(772);
          binaryExclusiveDisjunctionOperator();
          setState(773);
          expression(7);
          break;
        }

        case 13: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(775);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(776);
          binaryDisjunctionOperator();
          setState(777);
          expression(6);
          break;
        }

        case 14: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(779);

          if (!(precpred(_ctx, 18))) throw FailedPredicateException(this, "precpred(_ctx, 18)");
          setState(780);
          posfixUnaryOperator();
          break;
        }

        case 15: {
          _localctx = _tracker.createInstance<ExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpression);
          setState(781);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(782);
          binaryCoalescingOperator();
          setState(784);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx)) {
          case 1: {
            setState(783);
            expression(0);
            break;
          }

          default:
            break;
          }
          break;
        }

        default:
          break;
        } 
      }
      setState(790);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- PrimaryExpressionContext ------------------------------------------------------------------

NeoBasicParser::PrimaryExpressionContext::PrimaryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::OperandContext* NeoBasicParser::PrimaryExpressionContext::operand() {
  return getRuleContext<NeoBasicParser::OperandContext>(0);
}

NeoBasicParser::PrimaryExpressionContext* NeoBasicParser::PrimaryExpressionContext::primaryExpression() {
  return getRuleContext<NeoBasicParser::PrimaryExpressionContext>(0);
}

NeoBasicParser::ConverterContext* NeoBasicParser::PrimaryExpressionContext::converter() {
  return getRuleContext<NeoBasicParser::ConverterContext>(0);
}

NeoBasicParser::SelectorContext* NeoBasicParser::PrimaryExpressionContext::selector() {
  return getRuleContext<NeoBasicParser::SelectorContext>(0);
}

NeoBasicParser::IndexingContext* NeoBasicParser::PrimaryExpressionContext::indexing() {
  return getRuleContext<NeoBasicParser::IndexingContext>(0);
}

NeoBasicParser::SlicingContext* NeoBasicParser::PrimaryExpressionContext::slicing() {
  return getRuleContext<NeoBasicParser::SlicingContext>(0);
}

NeoBasicParser::ArgumentsContext* NeoBasicParser::PrimaryExpressionContext::arguments() {
  return getRuleContext<NeoBasicParser::ArgumentsContext>(0);
}


size_t NeoBasicParser::PrimaryExpressionContext::getRuleIndex() const {
  return NeoBasicParser::RulePrimaryExpression;
}

void NeoBasicParser::PrimaryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryExpression(this);
}

void NeoBasicParser::PrimaryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryExpression(this);
}


NeoBasicParser::PrimaryExpressionContext* NeoBasicParser::primaryExpression() {
   return primaryExpression(0);
}

NeoBasicParser::PrimaryExpressionContext* NeoBasicParser::primaryExpression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  NeoBasicParser::PrimaryExpressionContext *_localctx = _tracker.createInstance<PrimaryExpressionContext>(_ctx, parentState);
  NeoBasicParser::PrimaryExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 202;
  enterRecursionRule(_localctx, 202, NeoBasicParser::RulePrimaryExpression, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(792);
    operand();
    _ctx->stop = _input->LT(-1);
    setState(806);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(804);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<PrimaryExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RulePrimaryExpression);
          setState(794);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(795);
          converter();
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<PrimaryExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RulePrimaryExpression);
          setState(796);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(797);
          selector();
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<PrimaryExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RulePrimaryExpression);
          setState(798);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(799);
          indexing();
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<PrimaryExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RulePrimaryExpression);
          setState(800);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(801);
          slicing();
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<PrimaryExpressionContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RulePrimaryExpression);
          setState(802);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(803);
          arguments();
          break;
        }

        default:
          break;
        } 
      }
      setState(808);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- OperandContext ------------------------------------------------------------------

NeoBasicParser::OperandContext::OperandContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::LiteralContext* NeoBasicParser::OperandContext::literal() {
  return getRuleContext<NeoBasicParser::LiteralContext>(0);
}

NeoBasicParser::PredeclaredValueContext* NeoBasicParser::OperandContext::predeclaredValue() {
  return getRuleContext<NeoBasicParser::PredeclaredValueContext>(0);
}

NeoBasicParser::QualifiedIdentifierContext* NeoBasicParser::OperandContext::qualifiedIdentifier() {
  return getRuleContext<NeoBasicParser::QualifiedIdentifierContext>(0);
}

NeoBasicParser::ExpressionContext* NeoBasicParser::OperandContext::expression() {
  return getRuleContext<NeoBasicParser::ExpressionContext>(0);
}

NeoBasicParser::FactScopeContext* NeoBasicParser::OperandContext::factScope() {
  return getRuleContext<NeoBasicParser::FactScopeContext>(0);
}

tree::TerminalNode* NeoBasicParser::OperandContext::BACKTICK() {
  return getToken(NeoBasicParser::BACKTICK, 0);
}

NeoBasicParser::ExpressionsContext* NeoBasicParser::OperandContext::expressions() {
  return getRuleContext<NeoBasicParser::ExpressionsContext>(0);
}

tree::TerminalNode* NeoBasicParser::OperandContext::LEFT_PARENTHESIS() {
  return getToken(NeoBasicParser::LEFT_PARENTHESIS, 0);
}

tree::TerminalNode* NeoBasicParser::OperandContext::RIGHT_PARENTHESIS() {
  return getToken(NeoBasicParser::RIGHT_PARENTHESIS, 0);
}


size_t NeoBasicParser::OperandContext::getRuleIndex() const {
  return NeoBasicParser::RuleOperand;
}

void NeoBasicParser::OperandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOperand(this);
}

void NeoBasicParser::OperandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOperand(this);
}

NeoBasicParser::OperandContext* NeoBasicParser::operand() {
  OperandContext *_localctx = _tracker.createInstance<OperandContext>(_ctx, getState());
  enterRule(_localctx, 204, NeoBasicParser::RuleOperand);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(824);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(809);
      literal();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(810);
      predeclaredValue();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(811);
      qualifiedIdentifier();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(812);
      qualifiedIdentifier();
      setState(813);
      expression(0);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(815);
      factScope();
      setState(816);
      match(NeoBasicParser::BACKTICK);
      setState(817);
      qualifiedIdentifier();
      setState(818);
      expressions();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(820);
      match(NeoBasicParser::LEFT_PARENTHESIS);
      setState(821);
      expressions();
      setState(822);
      match(NeoBasicParser::RIGHT_PARENTHESIS);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FactScopeContext ------------------------------------------------------------------

NeoBasicParser::FactScopeContext::FactScopeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::FactScopeContext::ALL() {
  return getToken(NeoBasicParser::ALL, 0);
}

tree::TerminalNode* NeoBasicParser::FactScopeContext::ANY() {
  return getToken(NeoBasicParser::ANY, 0);
}

tree::TerminalNode* NeoBasicParser::FactScopeContext::ONE() {
  return getToken(NeoBasicParser::ONE, 0);
}

tree::TerminalNode* NeoBasicParser::FactScopeContext::TWO() {
  return getToken(NeoBasicParser::TWO, 0);
}

tree::TerminalNode* NeoBasicParser::FactScopeContext::NIL() {
  return getToken(NeoBasicParser::NIL, 0);
}


size_t NeoBasicParser::FactScopeContext::getRuleIndex() const {
  return NeoBasicParser::RuleFactScope;
}

void NeoBasicParser::FactScopeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFactScope(this);
}

void NeoBasicParser::FactScopeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFactScope(this);
}

NeoBasicParser::FactScopeContext* NeoBasicParser::factScope() {
  FactScopeContext *_localctx = _tracker.createInstance<FactScopeContext>(_ctx, getState());
  enterRule(_localctx, 206, NeoBasicParser::RuleFactScope);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(826);
    _la = _input->LA(1);
    if (!(((((_la - 297) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 297)) & 31) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConverterContext ------------------------------------------------------------------

NeoBasicParser::ConverterContext::ConverterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::ConverterContext::SEMICOLON() {
  return getToken(NeoBasicParser::SEMICOLON, 0);
}

NeoBasicParser::QualifiedIdentifierContext* NeoBasicParser::ConverterContext::qualifiedIdentifier() {
  return getRuleContext<NeoBasicParser::QualifiedIdentifierContext>(0);
}


size_t NeoBasicParser::ConverterContext::getRuleIndex() const {
  return NeoBasicParser::RuleConverter;
}

void NeoBasicParser::ConverterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConverter(this);
}

void NeoBasicParser::ConverterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConverter(this);
}

NeoBasicParser::ConverterContext* NeoBasicParser::converter() {
  ConverterContext *_localctx = _tracker.createInstance<ConverterContext>(_ctx, getState());
  enterRule(_localctx, 208, NeoBasicParser::RuleConverter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(828);
    match(NeoBasicParser::SEMICOLON);
    setState(829);
    qualifiedIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectorContext ------------------------------------------------------------------

NeoBasicParser::SelectorContext::SelectorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::SelectorContext::DOT() {
  return getToken(NeoBasicParser::DOT, 0);
}

tree::TerminalNode* NeoBasicParser::SelectorContext::IDENTIFIER() {
  return getToken(NeoBasicParser::IDENTIFIER, 0);
}


size_t NeoBasicParser::SelectorContext::getRuleIndex() const {
  return NeoBasicParser::RuleSelector;
}

void NeoBasicParser::SelectorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelector(this);
}

void NeoBasicParser::SelectorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelector(this);
}

NeoBasicParser::SelectorContext* NeoBasicParser::selector() {
  SelectorContext *_localctx = _tracker.createInstance<SelectorContext>(_ctx, getState());
  enterRule(_localctx, 210, NeoBasicParser::RuleSelector);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(831);
    match(NeoBasicParser::DOT);
    setState(832);
    match(NeoBasicParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexingContext ------------------------------------------------------------------

NeoBasicParser::IndexingContext::IndexingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::IndexingContext::LEFT_BRACKET() {
  return getToken(NeoBasicParser::LEFT_BRACKET, 0);
}

NeoBasicParser::ExpressionsContext* NeoBasicParser::IndexingContext::expressions() {
  return getRuleContext<NeoBasicParser::ExpressionsContext>(0);
}

tree::TerminalNode* NeoBasicParser::IndexingContext::RIGHT_BRACKET() {
  return getToken(NeoBasicParser::RIGHT_BRACKET, 0);
}


size_t NeoBasicParser::IndexingContext::getRuleIndex() const {
  return NeoBasicParser::RuleIndexing;
}

void NeoBasicParser::IndexingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexing(this);
}

void NeoBasicParser::IndexingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexing(this);
}

NeoBasicParser::IndexingContext* NeoBasicParser::indexing() {
  IndexingContext *_localctx = _tracker.createInstance<IndexingContext>(_ctx, getState());
  enterRule(_localctx, 212, NeoBasicParser::RuleIndexing);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(834);
    match(NeoBasicParser::LEFT_BRACKET);
    setState(835);
    expressions();
    setState(836);
    match(NeoBasicParser::RIGHT_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SlicingContext ------------------------------------------------------------------

NeoBasicParser::SlicingContext::SlicingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::SlicingContext::LEFT_BRACKET() {
  return getToken(NeoBasicParser::LEFT_BRACKET, 0);
}

NeoBasicParser::SlicingRangeContext* NeoBasicParser::SlicingContext::slicingRange() {
  return getRuleContext<NeoBasicParser::SlicingRangeContext>(0);
}

tree::TerminalNode* NeoBasicParser::SlicingContext::RIGHT_BRACKET() {
  return getToken(NeoBasicParser::RIGHT_BRACKET, 0);
}


size_t NeoBasicParser::SlicingContext::getRuleIndex() const {
  return NeoBasicParser::RuleSlicing;
}

void NeoBasicParser::SlicingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSlicing(this);
}

void NeoBasicParser::SlicingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSlicing(this);
}

NeoBasicParser::SlicingContext* NeoBasicParser::slicing() {
  SlicingContext *_localctx = _tracker.createInstance<SlicingContext>(_ctx, getState());
  enterRule(_localctx, 214, NeoBasicParser::RuleSlicing);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(838);
    match(NeoBasicParser::LEFT_BRACKET);
    setState(839);
    slicingRange();
    setState(840);
    match(NeoBasicParser::RIGHT_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SlicingRangeContext ------------------------------------------------------------------

NeoBasicParser::SlicingRangeContext::SlicingRangeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::RangeExpressionContext* NeoBasicParser::SlicingRangeContext::rangeExpression() {
  return getRuleContext<NeoBasicParser::RangeExpressionContext>(0);
}

tree::TerminalNode* NeoBasicParser::SlicingRangeContext::COLON() {
  return getToken(NeoBasicParser::COLON, 0);
}

NeoBasicParser::ExpressionContext* NeoBasicParser::SlicingRangeContext::expression() {
  return getRuleContext<NeoBasicParser::ExpressionContext>(0);
}


size_t NeoBasicParser::SlicingRangeContext::getRuleIndex() const {
  return NeoBasicParser::RuleSlicingRange;
}

void NeoBasicParser::SlicingRangeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSlicingRange(this);
}

void NeoBasicParser::SlicingRangeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSlicingRange(this);
}

NeoBasicParser::SlicingRangeContext* NeoBasicParser::slicingRange() {
  SlicingRangeContext *_localctx = _tracker.createInstance<SlicingRangeContext>(_ctx, getState());
  enterRule(_localctx, 216, NeoBasicParser::RuleSlicingRange);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(847);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(842);
      rangeExpression(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(843);
      rangeExpression(0);
      setState(844);
      match(NeoBasicParser::COLON);
      setState(845);
      expression(0);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RangeExpressionContext ------------------------------------------------------------------

NeoBasicParser::RangeExpressionContext::RangeExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NeoBasicParser::ExpressionContext *> NeoBasicParser::RangeExpressionContext::expression() {
  return getRuleContexts<NeoBasicParser::ExpressionContext>();
}

NeoBasicParser::ExpressionContext* NeoBasicParser::RangeExpressionContext::expression(size_t i) {
  return getRuleContext<NeoBasicParser::ExpressionContext>(i);
}

tree::TerminalNode* NeoBasicParser::RangeExpressionContext::INTERVAL() {
  return getToken(NeoBasicParser::INTERVAL, 0);
}

tree::TerminalNode* NeoBasicParser::RangeExpressionContext::INTERVAL_LEFT() {
  return getToken(NeoBasicParser::INTERVAL_LEFT, 0);
}

tree::TerminalNode* NeoBasicParser::RangeExpressionContext::INTERVAL_RIGHT() {
  return getToken(NeoBasicParser::INTERVAL_RIGHT, 0);
}

NeoBasicParser::RangeExpressionContext* NeoBasicParser::RangeExpressionContext::rangeExpression() {
  return getRuleContext<NeoBasicParser::RangeExpressionContext>(0);
}

tree::TerminalNode* NeoBasicParser::RangeExpressionContext::COLON() {
  return getToken(NeoBasicParser::COLON, 0);
}

tree::TerminalNode* NeoBasicParser::RangeExpressionContext::INTEGER_NUMBER() {
  return getToken(NeoBasicParser::INTEGER_NUMBER, 0);
}


size_t NeoBasicParser::RangeExpressionContext::getRuleIndex() const {
  return NeoBasicParser::RuleRangeExpression;
}

void NeoBasicParser::RangeExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRangeExpression(this);
}

void NeoBasicParser::RangeExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRangeExpression(this);
}


NeoBasicParser::RangeExpressionContext* NeoBasicParser::rangeExpression() {
   return rangeExpression(0);
}

NeoBasicParser::RangeExpressionContext* NeoBasicParser::rangeExpression(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  NeoBasicParser::RangeExpressionContext *_localctx = _tracker.createInstance<RangeExpressionContext>(_ctx, parentState);
  NeoBasicParser::RangeExpressionContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 218;
  enterRecursionRule(_localctx, 218, NeoBasicParser::RuleRangeExpression, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(859);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
    case 1: {
      setState(850);
      expression(0);
      setState(851);
      match(NeoBasicParser::INTERVAL);
      setState(852);
      expression(0);
      break;
    }

    case 2: {
      setState(854);
      expression(0);
      setState(855);
      match(NeoBasicParser::INTERVAL_LEFT);
      break;
    }

    case 3: {
      setState(857);
      match(NeoBasicParser::INTERVAL_RIGHT);
      setState(858);
      expression(0);
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(866);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<RangeExpressionContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleRangeExpression);
        setState(861);

        if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
        setState(862);
        match(NeoBasicParser::COLON);
        setState(863);
        match(NeoBasicParser::INTEGER_NUMBER); 
      }
      setState(868);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- ArgumentsContext ------------------------------------------------------------------

NeoBasicParser::ArgumentsContext::ArgumentsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::ArgumentsContext::LEFT_PARENTHESIS() {
  return getToken(NeoBasicParser::LEFT_PARENTHESIS, 0);
}

NeoBasicParser::ExpressionsContext* NeoBasicParser::ArgumentsContext::expressions() {
  return getRuleContext<NeoBasicParser::ExpressionsContext>(0);
}

tree::TerminalNode* NeoBasicParser::ArgumentsContext::RIGHT_PARENTHESIS() {
  return getToken(NeoBasicParser::RIGHT_PARENTHESIS, 0);
}


size_t NeoBasicParser::ArgumentsContext::getRuleIndex() const {
  return NeoBasicParser::RuleArguments;
}

void NeoBasicParser::ArgumentsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArguments(this);
}

void NeoBasicParser::ArgumentsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArguments(this);
}

NeoBasicParser::ArgumentsContext* NeoBasicParser::arguments() {
  ArgumentsContext *_localctx = _tracker.createInstance<ArgumentsContext>(_ctx, getState());
  enterRule(_localctx, 220, NeoBasicParser::RuleArguments);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(869);
    match(NeoBasicParser::LEFT_PARENTHESIS);
    setState(870);
    expressions();
    setState(871);
    match(NeoBasicParser::RIGHT_PARENTHESIS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentExpressionContext ------------------------------------------------------------------

NeoBasicParser::AssignmentExpressionContext::AssignmentExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::PrimaryExpressionContext* NeoBasicParser::AssignmentExpressionContext::primaryExpression() {
  return getRuleContext<NeoBasicParser::PrimaryExpressionContext>(0);
}

NeoBasicParser::AssignmentOperatorContext* NeoBasicParser::AssignmentExpressionContext::assignmentOperator() {
  return getRuleContext<NeoBasicParser::AssignmentOperatorContext>(0);
}

NeoBasicParser::ExpressionContext* NeoBasicParser::AssignmentExpressionContext::expression() {
  return getRuleContext<NeoBasicParser::ExpressionContext>(0);
}


size_t NeoBasicParser::AssignmentExpressionContext::getRuleIndex() const {
  return NeoBasicParser::RuleAssignmentExpression;
}

void NeoBasicParser::AssignmentExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentExpression(this);
}

void NeoBasicParser::AssignmentExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentExpression(this);
}

NeoBasicParser::AssignmentExpressionContext* NeoBasicParser::assignmentExpression() {
  AssignmentExpressionContext *_localctx = _tracker.createInstance<AssignmentExpressionContext>(_ctx, getState());
  enterRule(_localctx, 222, NeoBasicParser::RuleAssignmentExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(873);
    primaryExpression(0);
    setState(874);
    assignmentOperator();
    setState(875);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CondicionalExpressionContext ------------------------------------------------------------------

NeoBasicParser::CondicionalExpressionContext::CondicionalExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::GuardsExpressionContext* NeoBasicParser::CondicionalExpressionContext::guardsExpression() {
  return getRuleContext<NeoBasicParser::GuardsExpressionContext>(0);
}


size_t NeoBasicParser::CondicionalExpressionContext::getRuleIndex() const {
  return NeoBasicParser::RuleCondicionalExpression;
}

void NeoBasicParser::CondicionalExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCondicionalExpression(this);
}

void NeoBasicParser::CondicionalExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCondicionalExpression(this);
}

NeoBasicParser::CondicionalExpressionContext* NeoBasicParser::condicionalExpression() {
  CondicionalExpressionContext *_localctx = _tracker.createInstance<CondicionalExpressionContext>(_ctx, getState());
  enterRule(_localctx, 224, NeoBasicParser::RuleCondicionalExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(877);
    guardsExpression();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GuardsExpressionContext ------------------------------------------------------------------

NeoBasicParser::GuardsExpressionContext::GuardsExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NeoBasicParser::GuardClauseContext *> NeoBasicParser::GuardsExpressionContext::guardClause() {
  return getRuleContexts<NeoBasicParser::GuardClauseContext>();
}

NeoBasicParser::GuardClauseContext* NeoBasicParser::GuardsExpressionContext::guardClause(size_t i) {
  return getRuleContext<NeoBasicParser::GuardClauseContext>(i);
}

NeoBasicParser::GuardDefaultContext* NeoBasicParser::GuardsExpressionContext::guardDefault() {
  return getRuleContext<NeoBasicParser::GuardDefaultContext>(0);
}


size_t NeoBasicParser::GuardsExpressionContext::getRuleIndex() const {
  return NeoBasicParser::RuleGuardsExpression;
}

void NeoBasicParser::GuardsExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGuardsExpression(this);
}

void NeoBasicParser::GuardsExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGuardsExpression(this);
}

NeoBasicParser::GuardsExpressionContext* NeoBasicParser::guardsExpression() {
  GuardsExpressionContext *_localctx = _tracker.createInstance<GuardsExpressionContext>(_ctx, getState());
  enterRule(_localctx, 226, NeoBasicParser::RuleGuardsExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(880); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(879);
              guardClause();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(882); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(885);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx)) {
    case 1: {
      setState(884);
      guardDefault();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GuardClauseContext ------------------------------------------------------------------

NeoBasicParser::GuardClauseContext::GuardClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::GuardClauseContext::PIPE() {
  return getToken(NeoBasicParser::PIPE, 0);
}

std::vector<NeoBasicParser::ExpressionContext *> NeoBasicParser::GuardClauseContext::expression() {
  return getRuleContexts<NeoBasicParser::ExpressionContext>();
}

NeoBasicParser::ExpressionContext* NeoBasicParser::GuardClauseContext::expression(size_t i) {
  return getRuleContext<NeoBasicParser::ExpressionContext>(i);
}

tree::TerminalNode* NeoBasicParser::GuardClauseContext::COLON() {
  return getToken(NeoBasicParser::COLON, 0);
}


size_t NeoBasicParser::GuardClauseContext::getRuleIndex() const {
  return NeoBasicParser::RuleGuardClause;
}

void NeoBasicParser::GuardClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGuardClause(this);
}

void NeoBasicParser::GuardClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGuardClause(this);
}

NeoBasicParser::GuardClauseContext* NeoBasicParser::guardClause() {
  GuardClauseContext *_localctx = _tracker.createInstance<GuardClauseContext>(_ctx, getState());
  enterRule(_localctx, 228, NeoBasicParser::RuleGuardClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(887);
    match(NeoBasicParser::PIPE);
    setState(888);
    expression(0);
    setState(889);
    match(NeoBasicParser::COLON);
    setState(890);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GuardDefaultContext ------------------------------------------------------------------

NeoBasicParser::GuardDefaultContext::GuardDefaultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::GuardDefaultContext::PIPE() {
  return getToken(NeoBasicParser::PIPE, 0);
}

NeoBasicParser::ExpressionContext* NeoBasicParser::GuardDefaultContext::expression() {
  return getRuleContext<NeoBasicParser::ExpressionContext>(0);
}


size_t NeoBasicParser::GuardDefaultContext::getRuleIndex() const {
  return NeoBasicParser::RuleGuardDefault;
}

void NeoBasicParser::GuardDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGuardDefault(this);
}

void NeoBasicParser::GuardDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGuardDefault(this);
}

NeoBasicParser::GuardDefaultContext* NeoBasicParser::guardDefault() {
  GuardDefaultContext *_localctx = _tracker.createInstance<GuardDefaultContext>(_ctx, getState());
  enterRule(_localctx, 230, NeoBasicParser::RuleGuardDefault);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(892);
    match(NeoBasicParser::PIPE);
    setState(893);
    expression(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MacroExpressionContext ------------------------------------------------------------------

NeoBasicParser::MacroExpressionContext::MacroExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<NeoBasicParser::MacroCallContext *> NeoBasicParser::MacroExpressionContext::macroCall() {
  return getRuleContexts<NeoBasicParser::MacroCallContext>();
}

NeoBasicParser::MacroCallContext* NeoBasicParser::MacroExpressionContext::macroCall(size_t i) {
  return getRuleContext<NeoBasicParser::MacroCallContext>(i);
}


size_t NeoBasicParser::MacroExpressionContext::getRuleIndex() const {
  return NeoBasicParser::RuleMacroExpression;
}

void NeoBasicParser::MacroExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMacroExpression(this);
}

void NeoBasicParser::MacroExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMacroExpression(this);
}

NeoBasicParser::MacroExpressionContext* NeoBasicParser::macroExpression() {
  MacroExpressionContext *_localctx = _tracker.createInstance<MacroExpressionContext>(_ctx, getState());
  enterRule(_localctx, 232, NeoBasicParser::RuleMacroExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(896); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(895);
              macroCall();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(898); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 55, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MacroCallContext ------------------------------------------------------------------

NeoBasicParser::MacroCallContext::MacroCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::QualifiedIdentifierContext* NeoBasicParser::MacroCallContext::qualifiedIdentifier() {
  return getRuleContext<NeoBasicParser::QualifiedIdentifierContext>(0);
}

std::vector<NeoBasicParser::ExpressionContext *> NeoBasicParser::MacroCallContext::expression() {
  return getRuleContexts<NeoBasicParser::ExpressionContext>();
}

NeoBasicParser::ExpressionContext* NeoBasicParser::MacroCallContext::expression(size_t i) {
  return getRuleContext<NeoBasicParser::ExpressionContext>(i);
}


size_t NeoBasicParser::MacroCallContext::getRuleIndex() const {
  return NeoBasicParser::RuleMacroCall;
}

void NeoBasicParser::MacroCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMacroCall(this);
}

void NeoBasicParser::MacroCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMacroCall(this);
}

NeoBasicParser::MacroCallContext* NeoBasicParser::macroCall() {
  MacroCallContext *_localctx = _tracker.createInstance<MacroCallContext>(_ctx, getState());
  enterRule(_localctx, 234, NeoBasicParser::RuleMacroCall);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(900);
    qualifiedIdentifier();
    setState(904);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 56, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(901);
        expression(0); 
      }
      setState(906);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 56, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

NeoBasicParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::EscalarLiteralContext* NeoBasicParser::LiteralContext::escalarLiteral() {
  return getRuleContext<NeoBasicParser::EscalarLiteralContext>(0);
}

NeoBasicParser::OptionLiteralContext* NeoBasicParser::LiteralContext::optionLiteral() {
  return getRuleContext<NeoBasicParser::OptionLiteralContext>(0);
}


size_t NeoBasicParser::LiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleLiteral;
}

void NeoBasicParser::LiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral(this);
}

void NeoBasicParser::LiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral(this);
}

NeoBasicParser::LiteralContext* NeoBasicParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 236, NeoBasicParser::RuleLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(909);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::DEC_LIT:
      case NeoBasicParser::REAL_LIT:
      case NeoBasicParser::RATIO_LIT:
      case NeoBasicParser::IMAGINARY_LIT:
      case NeoBasicParser::NATURAL_LIT:
      case NeoBasicParser::INTEGER_LIT:
      case NeoBasicParser::BINARY_LIT:
      case NeoBasicParser::HEREDOC_LITERAL:
      case NeoBasicParser::REGULAR_EXPRESSION_LIT:
      case NeoBasicParser::STRING_LIT:
      case NeoBasicParser::WSTRING_LIT:
      case NeoBasicParser::CHAR_LIT:
      case NeoBasicParser::WCHAR_LIT:
      case NeoBasicParser::ASCII_LIT:
      case NeoBasicParser::ATOM_DOT_LIT:
      case NeoBasicParser::TRUE:
      case NeoBasicParser::FALSE:
      case NeoBasicParser::NONZERO:
      case NeoBasicParser::ZERO:
      case NeoBasicParser::MINVALUE:
      case NeoBasicParser::MAXVALUE:
      case NeoBasicParser::NAN:
      case NeoBasicParser::POSITIVEINFINITY:
      case NeoBasicParser::NEGATIVEINFINITY:
      case NeoBasicParser::LOCALDATE:
      case NeoBasicParser::LOCALDATETIME:
      case NeoBasicParser::OFFSETDATE:
      case NeoBasicParser::OFFSETDATETIME:
      case NeoBasicParser::ZONEDDATE:
      case NeoBasicParser::ZONEDDATETIME:
      case NeoBasicParser::TOMORROW:
      case NeoBasicParser::TODAY:
      case NeoBasicParser::NOW:
      case NeoBasicParser::YESTERDAY:
      case NeoBasicParser::EON:
      case NeoBasicParser::EPOCH:
      case NeoBasicParser::LETTER:
      case NeoBasicParser::DIGIT:
      case NeoBasicParser::PUNCTUATION:
      case NeoBasicParser::SYMBOL:
      case NeoBasicParser::SEPARATOR:
      case NeoBasicParser::NONPRINTABLE:
      case NeoBasicParser::NULL_:
      case NeoBasicParser::BLANK:
      case NeoBasicParser::NONBLANK: {
        enterOuterAlt(_localctx, 1);
        setState(907);
        escalarLiteral();
        break;
      }

      case NeoBasicParser::OKAY:
      case NeoBasicParser::FAIL:
      case NeoBasicParser::SOME:
      case NeoBasicParser::NONE:
      case NeoBasicParser::YEA:
      case NeoBasicParser::NAY:
      case NeoBasicParser::DATA:
      case NeoBasicParser::EOT: {
        enterOuterAlt(_localctx, 2);
        setState(908);
        optionLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PredeclaredValueContext ------------------------------------------------------------------

NeoBasicParser::PredeclaredValueContext::PredeclaredValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::PredeclaredValueContext::THIS() {
  return getToken(NeoBasicParser::THIS, 0);
}

tree::TerminalNode* NeoBasicParser::PredeclaredValueContext::IOTA() {
  return getToken(NeoBasicParser::IOTA, 0);
}


size_t NeoBasicParser::PredeclaredValueContext::getRuleIndex() const {
  return NeoBasicParser::RulePredeclaredValue;
}

void NeoBasicParser::PredeclaredValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredeclaredValue(this);
}

void NeoBasicParser::PredeclaredValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredeclaredValue(this);
}

NeoBasicParser::PredeclaredValueContext* NeoBasicParser::predeclaredValue() {
  PredeclaredValueContext *_localctx = _tracker.createInstance<PredeclaredValueContext>(_ctx, getState());
  enterRule(_localctx, 238, NeoBasicParser::RulePredeclaredValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(911);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::THIS

    || _la == NeoBasicParser::IOTA)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueConstructContext ------------------------------------------------------------------

NeoBasicParser::ValueConstructContext::ValueConstructContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::ValueConstructContext::LEFT_PARENTHESIS() {
  return getToken(NeoBasicParser::LEFT_PARENTHESIS, 0);
}

NeoBasicParser::ExpressionContext* NeoBasicParser::ValueConstructContext::expression() {
  return getRuleContext<NeoBasicParser::ExpressionContext>(0);
}

tree::TerminalNode* NeoBasicParser::ValueConstructContext::RIGHT_PARENTHESIS() {
  return getToken(NeoBasicParser::RIGHT_PARENTHESIS, 0);
}


size_t NeoBasicParser::ValueConstructContext::getRuleIndex() const {
  return NeoBasicParser::RuleValueConstruct;
}

void NeoBasicParser::ValueConstructContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValueConstruct(this);
}

void NeoBasicParser::ValueConstructContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValueConstruct(this);
}

NeoBasicParser::ValueConstructContext* NeoBasicParser::valueConstruct() {
  ValueConstructContext *_localctx = _tracker.createInstance<ValueConstructContext>(_ctx, getState());
  enterRule(_localctx, 240, NeoBasicParser::RuleValueConstruct);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(913);
    match(NeoBasicParser::LEFT_PARENTHESIS);
    setState(914);
    expression(0);
    setState(915);
    match(NeoBasicParser::RIGHT_PARENTHESIS);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EscalarLiteralContext ------------------------------------------------------------------

NeoBasicParser::EscalarLiteralContext::EscalarLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::BooleanLiteralContext* NeoBasicParser::EscalarLiteralContext::booleanLiteral() {
  return getRuleContext<NeoBasicParser::BooleanLiteralContext>(0);
}

NeoBasicParser::NumericLiteralContext* NeoBasicParser::EscalarLiteralContext::numericLiteral() {
  return getRuleContext<NeoBasicParser::NumericLiteralContext>(0);
}

NeoBasicParser::TemporalLiteralContext* NeoBasicParser::EscalarLiteralContext::temporalLiteral() {
  return getRuleContext<NeoBasicParser::TemporalLiteralContext>(0);
}

NeoBasicParser::CharacterLiteralContext* NeoBasicParser::EscalarLiteralContext::characterLiteral() {
  return getRuleContext<NeoBasicParser::CharacterLiteralContext>(0);
}

NeoBasicParser::SequenceLiteralContext* NeoBasicParser::EscalarLiteralContext::sequenceLiteral() {
  return getRuleContext<NeoBasicParser::SequenceLiteralContext>(0);
}


size_t NeoBasicParser::EscalarLiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleEscalarLiteral;
}

void NeoBasicParser::EscalarLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEscalarLiteral(this);
}

void NeoBasicParser::EscalarLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEscalarLiteral(this);
}

NeoBasicParser::EscalarLiteralContext* NeoBasicParser::escalarLiteral() {
  EscalarLiteralContext *_localctx = _tracker.createInstance<EscalarLiteralContext>(_ctx, getState());
  enterRule(_localctx, 242, NeoBasicParser::RuleEscalarLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(922);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(917);
      booleanLiteral();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(918);
      numericLiteral();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(919);
      temporalLiteral();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(920);
      characterLiteral();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(921);
      sequenceLiteral();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BooleanLiteralContext ------------------------------------------------------------------

NeoBasicParser::BooleanLiteralContext::BooleanLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::BooleanLiteralContext::TRUE() {
  return getToken(NeoBasicParser::TRUE, 0);
}

tree::TerminalNode* NeoBasicParser::BooleanLiteralContext::FALSE() {
  return getToken(NeoBasicParser::FALSE, 0);
}


size_t NeoBasicParser::BooleanLiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleBooleanLiteral;
}

void NeoBasicParser::BooleanLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBooleanLiteral(this);
}

void NeoBasicParser::BooleanLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBooleanLiteral(this);
}

NeoBasicParser::BooleanLiteralContext* NeoBasicParser::booleanLiteral() {
  BooleanLiteralContext *_localctx = _tracker.createInstance<BooleanLiteralContext>(_ctx, getState());
  enterRule(_localctx, 244, NeoBasicParser::RuleBooleanLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(924);
    _la = _input->LA(1);
    if (!(_la == NeoBasicParser::TRUE

    || _la == NeoBasicParser::FALSE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumericLiteralContext ------------------------------------------------------------------

NeoBasicParser::NumericLiteralContext::NumericLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::NumericLiteralContext::NATURAL_LIT() {
  return getToken(NeoBasicParser::NATURAL_LIT, 0);
}

tree::TerminalNode* NeoBasicParser::NumericLiteralContext::INTEGER_LIT() {
  return getToken(NeoBasicParser::INTEGER_LIT, 0);
}

tree::TerminalNode* NeoBasicParser::NumericLiteralContext::DEC_LIT() {
  return getToken(NeoBasicParser::DEC_LIT, 0);
}

tree::TerminalNode* NeoBasicParser::NumericLiteralContext::REAL_LIT() {
  return getToken(NeoBasicParser::REAL_LIT, 0);
}

tree::TerminalNode* NeoBasicParser::NumericLiteralContext::RATIO_LIT() {
  return getToken(NeoBasicParser::RATIO_LIT, 0);
}

tree::TerminalNode* NeoBasicParser::NumericLiteralContext::IMAGINARY_LIT() {
  return getToken(NeoBasicParser::IMAGINARY_LIT, 0);
}

tree::TerminalNode* NeoBasicParser::NumericLiteralContext::NONZERO() {
  return getToken(NeoBasicParser::NONZERO, 0);
}

NeoBasicParser::ValueConstructContext* NeoBasicParser::NumericLiteralContext::valueConstruct() {
  return getRuleContext<NeoBasicParser::ValueConstructContext>(0);
}

tree::TerminalNode* NeoBasicParser::NumericLiteralContext::ZERO() {
  return getToken(NeoBasicParser::ZERO, 0);
}

tree::TerminalNode* NeoBasicParser::NumericLiteralContext::MINVALUE() {
  return getToken(NeoBasicParser::MINVALUE, 0);
}

tree::TerminalNode* NeoBasicParser::NumericLiteralContext::MAXVALUE() {
  return getToken(NeoBasicParser::MAXVALUE, 0);
}

tree::TerminalNode* NeoBasicParser::NumericLiteralContext::NAN() {
  return getToken(NeoBasicParser::NAN, 0);
}

tree::TerminalNode* NeoBasicParser::NumericLiteralContext::POSITIVEINFINITY() {
  return getToken(NeoBasicParser::POSITIVEINFINITY, 0);
}

tree::TerminalNode* NeoBasicParser::NumericLiteralContext::NEGATIVEINFINITY() {
  return getToken(NeoBasicParser::NEGATIVEINFINITY, 0);
}


size_t NeoBasicParser::NumericLiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleNumericLiteral;
}

void NeoBasicParser::NumericLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumericLiteral(this);
}

void NeoBasicParser::NumericLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumericLiteral(this);
}

NeoBasicParser::NumericLiteralContext* NeoBasicParser::numericLiteral() {
  NumericLiteralContext *_localctx = _tracker.createInstance<NumericLiteralContext>(_ctx, getState());
  enterRule(_localctx, 246, NeoBasicParser::RuleNumericLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(940);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::NATURAL_LIT: {
        enterOuterAlt(_localctx, 1);
        setState(926);
        match(NeoBasicParser::NATURAL_LIT);
        break;
      }

      case NeoBasicParser::INTEGER_LIT: {
        enterOuterAlt(_localctx, 2);
        setState(927);
        match(NeoBasicParser::INTEGER_LIT);
        break;
      }

      case NeoBasicParser::DEC_LIT: {
        enterOuterAlt(_localctx, 3);
        setState(928);
        match(NeoBasicParser::DEC_LIT);
        break;
      }

      case NeoBasicParser::REAL_LIT: {
        enterOuterAlt(_localctx, 4);
        setState(929);
        match(NeoBasicParser::REAL_LIT);
        break;
      }

      case NeoBasicParser::RATIO_LIT: {
        enterOuterAlt(_localctx, 5);
        setState(930);
        match(NeoBasicParser::RATIO_LIT);
        break;
      }

      case NeoBasicParser::IMAGINARY_LIT: {
        enterOuterAlt(_localctx, 6);
        setState(931);
        match(NeoBasicParser::IMAGINARY_LIT);
        break;
      }

      case NeoBasicParser::NONZERO: {
        enterOuterAlt(_localctx, 7);
        setState(932);
        match(NeoBasicParser::NONZERO);
        setState(933);
        valueConstruct();
        break;
      }

      case NeoBasicParser::ZERO: {
        enterOuterAlt(_localctx, 8);
        setState(934);
        match(NeoBasicParser::ZERO);
        break;
      }

      case NeoBasicParser::MINVALUE: {
        enterOuterAlt(_localctx, 9);
        setState(935);
        match(NeoBasicParser::MINVALUE);
        break;
      }

      case NeoBasicParser::MAXVALUE: {
        enterOuterAlt(_localctx, 10);
        setState(936);
        match(NeoBasicParser::MAXVALUE);
        break;
      }

      case NeoBasicParser::NAN: {
        enterOuterAlt(_localctx, 11);
        setState(937);
        match(NeoBasicParser::NAN);
        break;
      }

      case NeoBasicParser::POSITIVEINFINITY: {
        enterOuterAlt(_localctx, 12);
        setState(938);
        match(NeoBasicParser::POSITIVEINFINITY);
        break;
      }

      case NeoBasicParser::NEGATIVEINFINITY: {
        enterOuterAlt(_localctx, 13);
        setState(939);
        match(NeoBasicParser::NEGATIVEINFINITY);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TemporalLiteralContext ------------------------------------------------------------------

NeoBasicParser::TemporalLiteralContext::TemporalLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::ATOM_DOT_LIT() {
  return getToken(NeoBasicParser::ATOM_DOT_LIT, 0);
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::LOCALDATE() {
  return getToken(NeoBasicParser::LOCALDATE, 0);
}

NeoBasicParser::ValueConstructContext* NeoBasicParser::TemporalLiteralContext::valueConstruct() {
  return getRuleContext<NeoBasicParser::ValueConstructContext>(0);
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::LOCALDATETIME() {
  return getToken(NeoBasicParser::LOCALDATETIME, 0);
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::OFFSETDATE() {
  return getToken(NeoBasicParser::OFFSETDATE, 0);
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::OFFSETDATETIME() {
  return getToken(NeoBasicParser::OFFSETDATETIME, 0);
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::ZONEDDATE() {
  return getToken(NeoBasicParser::ZONEDDATE, 0);
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::ZONEDDATETIME() {
  return getToken(NeoBasicParser::ZONEDDATETIME, 0);
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::TOMORROW() {
  return getToken(NeoBasicParser::TOMORROW, 0);
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::TODAY() {
  return getToken(NeoBasicParser::TODAY, 0);
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::NOW() {
  return getToken(NeoBasicParser::NOW, 0);
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::YESTERDAY() {
  return getToken(NeoBasicParser::YESTERDAY, 0);
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::EON() {
  return getToken(NeoBasicParser::EON, 0);
}

tree::TerminalNode* NeoBasicParser::TemporalLiteralContext::EPOCH() {
  return getToken(NeoBasicParser::EPOCH, 0);
}


size_t NeoBasicParser::TemporalLiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleTemporalLiteral;
}

void NeoBasicParser::TemporalLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemporalLiteral(this);
}

void NeoBasicParser::TemporalLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemporalLiteral(this);
}

NeoBasicParser::TemporalLiteralContext* NeoBasicParser::temporalLiteral() {
  TemporalLiteralContext *_localctx = _tracker.createInstance<TemporalLiteralContext>(_ctx, getState());
  enterRule(_localctx, 248, NeoBasicParser::RuleTemporalLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(973);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::ATOM_DOT_LIT: {
        enterOuterAlt(_localctx, 1);
        setState(942);
        match(NeoBasicParser::ATOM_DOT_LIT);
        break;
      }

      case NeoBasicParser::LOCALDATE: {
        enterOuterAlt(_localctx, 2);
        setState(943);
        match(NeoBasicParser::LOCALDATE);
        setState(945);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx)) {
        case 1: {
          setState(944);
          valueConstruct();
          break;
        }

        default:
          break;
        }
        break;
      }

      case NeoBasicParser::LOCALDATETIME: {
        enterOuterAlt(_localctx, 3);
        setState(947);
        match(NeoBasicParser::LOCALDATETIME);
        setState(949);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx)) {
        case 1: {
          setState(948);
          valueConstruct();
          break;
        }

        default:
          break;
        }
        break;
      }

      case NeoBasicParser::OFFSETDATE: {
        enterOuterAlt(_localctx, 4);
        setState(951);
        match(NeoBasicParser::OFFSETDATE);
        setState(953);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx)) {
        case 1: {
          setState(952);
          valueConstruct();
          break;
        }

        default:
          break;
        }
        break;
      }

      case NeoBasicParser::OFFSETDATETIME: {
        enterOuterAlt(_localctx, 5);
        setState(955);
        match(NeoBasicParser::OFFSETDATETIME);
        setState(957);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx)) {
        case 1: {
          setState(956);
          valueConstruct();
          break;
        }

        default:
          break;
        }
        break;
      }

      case NeoBasicParser::ZONEDDATE: {
        enterOuterAlt(_localctx, 6);
        setState(959);
        match(NeoBasicParser::ZONEDDATE);
        setState(961);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx)) {
        case 1: {
          setState(960);
          valueConstruct();
          break;
        }

        default:
          break;
        }
        break;
      }

      case NeoBasicParser::ZONEDDATETIME: {
        enterOuterAlt(_localctx, 7);
        setState(963);
        match(NeoBasicParser::ZONEDDATETIME);
        setState(965);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx)) {
        case 1: {
          setState(964);
          valueConstruct();
          break;
        }

        default:
          break;
        }
        break;
      }

      case NeoBasicParser::TOMORROW: {
        enterOuterAlt(_localctx, 8);
        setState(967);
        match(NeoBasicParser::TOMORROW);
        break;
      }

      case NeoBasicParser::TODAY: {
        enterOuterAlt(_localctx, 9);
        setState(968);
        match(NeoBasicParser::TODAY);
        break;
      }

      case NeoBasicParser::NOW: {
        enterOuterAlt(_localctx, 10);
        setState(969);
        match(NeoBasicParser::NOW);
        break;
      }

      case NeoBasicParser::YESTERDAY: {
        enterOuterAlt(_localctx, 11);
        setState(970);
        match(NeoBasicParser::YESTERDAY);
        break;
      }

      case NeoBasicParser::EON: {
        enterOuterAlt(_localctx, 12);
        setState(971);
        match(NeoBasicParser::EON);
        break;
      }

      case NeoBasicParser::EPOCH: {
        enterOuterAlt(_localctx, 13);
        setState(972);
        match(NeoBasicParser::EPOCH);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharacterLiteralContext ------------------------------------------------------------------

NeoBasicParser::CharacterLiteralContext::CharacterLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::CharacterLiteralContext::ASCII_LIT() {
  return getToken(NeoBasicParser::ASCII_LIT, 0);
}

tree::TerminalNode* NeoBasicParser::CharacterLiteralContext::WCHAR_LIT() {
  return getToken(NeoBasicParser::WCHAR_LIT, 0);
}

tree::TerminalNode* NeoBasicParser::CharacterLiteralContext::CHAR_LIT() {
  return getToken(NeoBasicParser::CHAR_LIT, 0);
}

tree::TerminalNode* NeoBasicParser::CharacterLiteralContext::LETTER() {
  return getToken(NeoBasicParser::LETTER, 0);
}

NeoBasicParser::ValueConstructContext* NeoBasicParser::CharacterLiteralContext::valueConstruct() {
  return getRuleContext<NeoBasicParser::ValueConstructContext>(0);
}

tree::TerminalNode* NeoBasicParser::CharacterLiteralContext::DIGIT() {
  return getToken(NeoBasicParser::DIGIT, 0);
}

tree::TerminalNode* NeoBasicParser::CharacterLiteralContext::PUNCTUATION() {
  return getToken(NeoBasicParser::PUNCTUATION, 0);
}

tree::TerminalNode* NeoBasicParser::CharacterLiteralContext::SYMBOL() {
  return getToken(NeoBasicParser::SYMBOL, 0);
}

tree::TerminalNode* NeoBasicParser::CharacterLiteralContext::SEPARATOR() {
  return getToken(NeoBasicParser::SEPARATOR, 0);
}

tree::TerminalNode* NeoBasicParser::CharacterLiteralContext::NONPRINTABLE() {
  return getToken(NeoBasicParser::NONPRINTABLE, 0);
}

tree::TerminalNode* NeoBasicParser::CharacterLiteralContext::NULL_() {
  return getToken(NeoBasicParser::NULL_, 0);
}


size_t NeoBasicParser::CharacterLiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleCharacterLiteral;
}

void NeoBasicParser::CharacterLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharacterLiteral(this);
}

void NeoBasicParser::CharacterLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharacterLiteral(this);
}

NeoBasicParser::CharacterLiteralContext* NeoBasicParser::characterLiteral() {
  CharacterLiteralContext *_localctx = _tracker.createInstance<CharacterLiteralContext>(_ctx, getState());
  enterRule(_localctx, 250, NeoBasicParser::RuleCharacterLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(991);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::ASCII_LIT: {
        enterOuterAlt(_localctx, 1);
        setState(975);
        match(NeoBasicParser::ASCII_LIT);
        break;
      }

      case NeoBasicParser::WCHAR_LIT: {
        enterOuterAlt(_localctx, 2);
        setState(976);
        match(NeoBasicParser::WCHAR_LIT);
        break;
      }

      case NeoBasicParser::CHAR_LIT: {
        enterOuterAlt(_localctx, 3);
        setState(977);
        match(NeoBasicParser::CHAR_LIT);
        break;
      }

      case NeoBasicParser::LETTER: {
        enterOuterAlt(_localctx, 4);
        setState(978);
        match(NeoBasicParser::LETTER);
        setState(979);
        valueConstruct();
        break;
      }

      case NeoBasicParser::DIGIT: {
        enterOuterAlt(_localctx, 5);
        setState(980);
        match(NeoBasicParser::DIGIT);
        setState(981);
        valueConstruct();
        break;
      }

      case NeoBasicParser::PUNCTUATION: {
        enterOuterAlt(_localctx, 6);
        setState(982);
        match(NeoBasicParser::PUNCTUATION);
        setState(983);
        valueConstruct();
        break;
      }

      case NeoBasicParser::SYMBOL: {
        enterOuterAlt(_localctx, 7);
        setState(984);
        match(NeoBasicParser::SYMBOL);
        setState(985);
        valueConstruct();
        break;
      }

      case NeoBasicParser::SEPARATOR: {
        enterOuterAlt(_localctx, 8);
        setState(986);
        match(NeoBasicParser::SEPARATOR);
        setState(987);
        valueConstruct();
        break;
      }

      case NeoBasicParser::NONPRINTABLE: {
        enterOuterAlt(_localctx, 9);
        setState(988);
        match(NeoBasicParser::NONPRINTABLE);
        setState(989);
        valueConstruct();
        break;
      }

      case NeoBasicParser::NULL_: {
        enterOuterAlt(_localctx, 10);
        setState(990);
        match(NeoBasicParser::NULL_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SequenceLiteralContext ------------------------------------------------------------------

NeoBasicParser::SequenceLiteralContext::SequenceLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::SequenceLiteralContext::HEREDOC_LITERAL() {
  return getToken(NeoBasicParser::HEREDOC_LITERAL, 0);
}

tree::TerminalNode* NeoBasicParser::SequenceLiteralContext::REGULAR_EXPRESSION_LIT() {
  return getToken(NeoBasicParser::REGULAR_EXPRESSION_LIT, 0);
}

tree::TerminalNode* NeoBasicParser::SequenceLiteralContext::WSTRING_LIT() {
  return getToken(NeoBasicParser::WSTRING_LIT, 0);
}

tree::TerminalNode* NeoBasicParser::SequenceLiteralContext::STRING_LIT() {
  return getToken(NeoBasicParser::STRING_LIT, 0);
}

tree::TerminalNode* NeoBasicParser::SequenceLiteralContext::ATOM_DOT_LIT() {
  return getToken(NeoBasicParser::ATOM_DOT_LIT, 0);
}

tree::TerminalNode* NeoBasicParser::SequenceLiteralContext::BINARY_LIT() {
  return getToken(NeoBasicParser::BINARY_LIT, 0);
}

tree::TerminalNode* NeoBasicParser::SequenceLiteralContext::NONBLANK() {
  return getToken(NeoBasicParser::NONBLANK, 0);
}

NeoBasicParser::ValueConstructContext* NeoBasicParser::SequenceLiteralContext::valueConstruct() {
  return getRuleContext<NeoBasicParser::ValueConstructContext>(0);
}

tree::TerminalNode* NeoBasicParser::SequenceLiteralContext::BLANK() {
  return getToken(NeoBasicParser::BLANK, 0);
}


size_t NeoBasicParser::SequenceLiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleSequenceLiteral;
}

void NeoBasicParser::SequenceLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSequenceLiteral(this);
}

void NeoBasicParser::SequenceLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSequenceLiteral(this);
}

NeoBasicParser::SequenceLiteralContext* NeoBasicParser::sequenceLiteral() {
  SequenceLiteralContext *_localctx = _tracker.createInstance<SequenceLiteralContext>(_ctx, getState());
  enterRule(_localctx, 252, NeoBasicParser::RuleSequenceLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1002);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::HEREDOC_LITERAL: {
        enterOuterAlt(_localctx, 1);
        setState(993);
        match(NeoBasicParser::HEREDOC_LITERAL);
        break;
      }

      case NeoBasicParser::REGULAR_EXPRESSION_LIT: {
        enterOuterAlt(_localctx, 2);
        setState(994);
        match(NeoBasicParser::REGULAR_EXPRESSION_LIT);
        break;
      }

      case NeoBasicParser::WSTRING_LIT: {
        enterOuterAlt(_localctx, 3);
        setState(995);
        match(NeoBasicParser::WSTRING_LIT);
        break;
      }

      case NeoBasicParser::STRING_LIT: {
        enterOuterAlt(_localctx, 4);
        setState(996);
        match(NeoBasicParser::STRING_LIT);
        break;
      }

      case NeoBasicParser::ATOM_DOT_LIT: {
        enterOuterAlt(_localctx, 5);
        setState(997);
        match(NeoBasicParser::ATOM_DOT_LIT);
        break;
      }

      case NeoBasicParser::BINARY_LIT: {
        enterOuterAlt(_localctx, 6);
        setState(998);
        match(NeoBasicParser::BINARY_LIT);
        break;
      }

      case NeoBasicParser::NONBLANK: {
        enterOuterAlt(_localctx, 7);
        setState(999);
        match(NeoBasicParser::NONBLANK);
        setState(1000);
        valueConstruct();
        break;
      }

      case NeoBasicParser::BLANK: {
        enterOuterAlt(_localctx, 8);
        setState(1001);
        match(NeoBasicParser::BLANK);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionLiteralContext ------------------------------------------------------------------

NeoBasicParser::OptionLiteralContext::OptionLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

NeoBasicParser::ResultLiteralContext* NeoBasicParser::OptionLiteralContext::resultLiteral() {
  return getRuleContext<NeoBasicParser::ResultLiteralContext>(0);
}

NeoBasicParser::MaybeLiteralContext* NeoBasicParser::OptionLiteralContext::maybeLiteral() {
  return getRuleContext<NeoBasicParser::MaybeLiteralContext>(0);
}

NeoBasicParser::EitherLiteralContext* NeoBasicParser::OptionLiteralContext::eitherLiteral() {
  return getRuleContext<NeoBasicParser::EitherLiteralContext>(0);
}

NeoBasicParser::StreamLiteralContext* NeoBasicParser::OptionLiteralContext::streamLiteral() {
  return getRuleContext<NeoBasicParser::StreamLiteralContext>(0);
}


size_t NeoBasicParser::OptionLiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleOptionLiteral;
}

void NeoBasicParser::OptionLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionLiteral(this);
}

void NeoBasicParser::OptionLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionLiteral(this);
}

NeoBasicParser::OptionLiteralContext* NeoBasicParser::optionLiteral() {
  OptionLiteralContext *_localctx = _tracker.createInstance<OptionLiteralContext>(_ctx, getState());
  enterRule(_localctx, 254, NeoBasicParser::RuleOptionLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1008);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::OKAY:
      case NeoBasicParser::FAIL: {
        enterOuterAlt(_localctx, 1);
        setState(1004);
        resultLiteral();
        break;
      }

      case NeoBasicParser::SOME:
      case NeoBasicParser::NONE: {
        enterOuterAlt(_localctx, 2);
        setState(1005);
        maybeLiteral();
        break;
      }

      case NeoBasicParser::YEA:
      case NeoBasicParser::NAY: {
        enterOuterAlt(_localctx, 3);
        setState(1006);
        eitherLiteral();
        break;
      }

      case NeoBasicParser::DATA:
      case NeoBasicParser::EOT: {
        enterOuterAlt(_localctx, 4);
        setState(1007);
        streamLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResultLiteralContext ------------------------------------------------------------------

NeoBasicParser::ResultLiteralContext::ResultLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::ResultLiteralContext::OKAY() {
  return getToken(NeoBasicParser::OKAY, 0);
}

NeoBasicParser::ValueConstructContext* NeoBasicParser::ResultLiteralContext::valueConstruct() {
  return getRuleContext<NeoBasicParser::ValueConstructContext>(0);
}

tree::TerminalNode* NeoBasicParser::ResultLiteralContext::FAIL() {
  return getToken(NeoBasicParser::FAIL, 0);
}


size_t NeoBasicParser::ResultLiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleResultLiteral;
}

void NeoBasicParser::ResultLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResultLiteral(this);
}

void NeoBasicParser::ResultLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResultLiteral(this);
}

NeoBasicParser::ResultLiteralContext* NeoBasicParser::resultLiteral() {
  ResultLiteralContext *_localctx = _tracker.createInstance<ResultLiteralContext>(_ctx, getState());
  enterRule(_localctx, 256, NeoBasicParser::RuleResultLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1014);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::OKAY: {
        enterOuterAlt(_localctx, 1);
        setState(1010);
        match(NeoBasicParser::OKAY);
        setState(1011);
        valueConstruct();
        break;
      }

      case NeoBasicParser::FAIL: {
        enterOuterAlt(_localctx, 2);
        setState(1012);
        match(NeoBasicParser::FAIL);
        setState(1013);
        valueConstruct();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MaybeLiteralContext ------------------------------------------------------------------

NeoBasicParser::MaybeLiteralContext::MaybeLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::MaybeLiteralContext::SOME() {
  return getToken(NeoBasicParser::SOME, 0);
}

NeoBasicParser::ValueConstructContext* NeoBasicParser::MaybeLiteralContext::valueConstruct() {
  return getRuleContext<NeoBasicParser::ValueConstructContext>(0);
}

tree::TerminalNode* NeoBasicParser::MaybeLiteralContext::NONE() {
  return getToken(NeoBasicParser::NONE, 0);
}


size_t NeoBasicParser::MaybeLiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleMaybeLiteral;
}

void NeoBasicParser::MaybeLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMaybeLiteral(this);
}

void NeoBasicParser::MaybeLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMaybeLiteral(this);
}

NeoBasicParser::MaybeLiteralContext* NeoBasicParser::maybeLiteral() {
  MaybeLiteralContext *_localctx = _tracker.createInstance<MaybeLiteralContext>(_ctx, getState());
  enterRule(_localctx, 258, NeoBasicParser::RuleMaybeLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1019);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::SOME: {
        enterOuterAlt(_localctx, 1);
        setState(1016);
        match(NeoBasicParser::SOME);
        setState(1017);
        valueConstruct();
        break;
      }

      case NeoBasicParser::NONE: {
        enterOuterAlt(_localctx, 2);
        setState(1018);
        match(NeoBasicParser::NONE);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EitherLiteralContext ------------------------------------------------------------------

NeoBasicParser::EitherLiteralContext::EitherLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::EitherLiteralContext::YEA() {
  return getToken(NeoBasicParser::YEA, 0);
}

NeoBasicParser::ValueConstructContext* NeoBasicParser::EitherLiteralContext::valueConstruct() {
  return getRuleContext<NeoBasicParser::ValueConstructContext>(0);
}

tree::TerminalNode* NeoBasicParser::EitherLiteralContext::NAY() {
  return getToken(NeoBasicParser::NAY, 0);
}


size_t NeoBasicParser::EitherLiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleEitherLiteral;
}

void NeoBasicParser::EitherLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEitherLiteral(this);
}

void NeoBasicParser::EitherLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEitherLiteral(this);
}

NeoBasicParser::EitherLiteralContext* NeoBasicParser::eitherLiteral() {
  EitherLiteralContext *_localctx = _tracker.createInstance<EitherLiteralContext>(_ctx, getState());
  enterRule(_localctx, 260, NeoBasicParser::RuleEitherLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1025);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::YEA: {
        enterOuterAlt(_localctx, 1);
        setState(1021);
        match(NeoBasicParser::YEA);
        setState(1022);
        valueConstruct();
        break;
      }

      case NeoBasicParser::NAY: {
        enterOuterAlt(_localctx, 2);
        setState(1023);
        match(NeoBasicParser::NAY);
        setState(1024);
        valueConstruct();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StreamLiteralContext ------------------------------------------------------------------

NeoBasicParser::StreamLiteralContext::StreamLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::StreamLiteralContext::DATA() {
  return getToken(NeoBasicParser::DATA, 0);
}

NeoBasicParser::ValueConstructContext* NeoBasicParser::StreamLiteralContext::valueConstruct() {
  return getRuleContext<NeoBasicParser::ValueConstructContext>(0);
}

tree::TerminalNode* NeoBasicParser::StreamLiteralContext::EOT() {
  return getToken(NeoBasicParser::EOT, 0);
}


size_t NeoBasicParser::StreamLiteralContext::getRuleIndex() const {
  return NeoBasicParser::RuleStreamLiteral;
}

void NeoBasicParser::StreamLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStreamLiteral(this);
}

void NeoBasicParser::StreamLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStreamLiteral(this);
}

NeoBasicParser::StreamLiteralContext* NeoBasicParser::streamLiteral() {
  StreamLiteralContext *_localctx = _tracker.createInstance<StreamLiteralContext>(_ctx, getState());
  enterRule(_localctx, 262, NeoBasicParser::RuleStreamLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1030);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case NeoBasicParser::DATA: {
        enterOuterAlt(_localctx, 1);
        setState(1027);
        match(NeoBasicParser::DATA);
        setState(1028);
        valueConstruct();
        break;
      }

      case NeoBasicParser::EOT: {
        enterOuterAlt(_localctx, 2);
        setState(1029);
        match(NeoBasicParser::EOT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoggingLevelContext ------------------------------------------------------------------

NeoBasicParser::LoggingLevelContext::LoggingLevelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* NeoBasicParser::LoggingLevelContext::TRACE() {
  return getToken(NeoBasicParser::TRACE, 0);
}

tree::TerminalNode* NeoBasicParser::LoggingLevelContext::DEBUG() {
  return getToken(NeoBasicParser::DEBUG, 0);
}

tree::TerminalNode* NeoBasicParser::LoggingLevelContext::INFO() {
  return getToken(NeoBasicParser::INFO, 0);
}

tree::TerminalNode* NeoBasicParser::LoggingLevelContext::WARN() {
  return getToken(NeoBasicParser::WARN, 0);
}

tree::TerminalNode* NeoBasicParser::LoggingLevelContext::ERROR() {
  return getToken(NeoBasicParser::ERROR, 0);
}

tree::TerminalNode* NeoBasicParser::LoggingLevelContext::FATAL() {
  return getToken(NeoBasicParser::FATAL, 0);
}


size_t NeoBasicParser::LoggingLevelContext::getRuleIndex() const {
  return NeoBasicParser::RuleLoggingLevel;
}

void NeoBasicParser::LoggingLevelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoggingLevel(this);
}

void NeoBasicParser::LoggingLevelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<NeoBasicParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoggingLevel(this);
}

NeoBasicParser::LoggingLevelContext* NeoBasicParser::loggingLevel() {
  LoggingLevelContext *_localctx = _tracker.createInstance<LoggingLevelContext>(_ctx, getState());
  enterRule(_localctx, 264, NeoBasicParser::RuleLoggingLevel);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1032);
    _la = _input->LA(1);
    if (!(((((_la - 507) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 507)) & 63) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool NeoBasicParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 100: return expressionSempred(antlrcpp::downCast<ExpressionContext *>(context), predicateIndex);
    case 101: return primaryExpressionSempred(antlrcpp::downCast<PrimaryExpressionContext *>(context), predicateIndex);
    case 109: return rangeExpressionSempred(antlrcpp::downCast<RangeExpressionContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool NeoBasicParser::expressionSempred(ExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 17);
    case 1: return precpred(_ctx, 16);
    case 2: return precpred(_ctx, 15);
    case 3: return precpred(_ctx, 14);
    case 4: return precpred(_ctx, 13);
    case 5: return precpred(_ctx, 12);
    case 6: return precpred(_ctx, 11);
    case 7: return precpred(_ctx, 10);
    case 8: return precpred(_ctx, 9);
    case 9: return precpred(_ctx, 8);
    case 10: return precpred(_ctx, 7);
    case 11: return precpred(_ctx, 6);
    case 12: return precpred(_ctx, 5);
    case 13: return precpred(_ctx, 18);
    case 14: return precpred(_ctx, 4);

  default:
    break;
  }
  return true;
}

bool NeoBasicParser::primaryExpressionSempred(PrimaryExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 15: return precpred(_ctx, 5);
    case 16: return precpred(_ctx, 4);
    case 17: return precpred(_ctx, 3);
    case 18: return precpred(_ctx, 2);
    case 19: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool NeoBasicParser::rangeExpressionSempred(RangeExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 20: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

void NeoBasicParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  neobasicparserParserInitialize();
#else
  ::antlr4::internal::call_once(neobasicparserParserOnceFlag, neobasicparserParserInitialize);
#endif
}
